<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: software | Keen on Art of Tech]]></title>
  <link href="http://tinyxd.me/tags/software/atom.xml" rel="self"/>
  <link href="http://tinyxd.me/"/>
  <updated>2012-06-27T21:34:45+08:00</updated>
  <id>http://tinyxd.me/</id>
  <author>
    <name><![CDATA[Tiny]]></name>
    <email><![CDATA[admin@tinyxd.me]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[排序算法总结（二）]]></title>
    <link href="http://tinyxd.me/blog/2012/06/27/swap-sort/"/>
    <updated>2012-06-27T20:50:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/27/swap-sort</id>
    <content type="html"><![CDATA[<p>昨天总结了插入排序，今天总结交换排序。 <br/>
交换排序是一种主要以交换的方式对序列进行排序的方法。排序的基本方法或手段主要就是比较和交换，像选择法等都借助了交换的手段，但都不是主要以交换为手段，如在直接选择排序的时候，一轮比较就能确定最大元素的位置，最后再进行交换。交换排序被公认为“稳定”的排序方法。</p>

<h2>冒泡排序</h2>

<p>冒泡排序，是指计算机的一种排序方法，它的时间复杂度为O（ n<sup>2</sup> ），虽然不及堆排序、快速排序的O（nlog n，底数为2），但是有两个优点：</p>

<!--more-->


<p>
1. “编程复杂度”很低，很容易写出代码； <br/>
2. 具有稳定性，这里的稳定性是指原序列中相同元素的相对顺序仍然保持到排序后的序列，而堆排序、快速排序均不具有稳定性。不过，一路、二路归并排序、不平衡二叉树排序的速度均比冒泡排序快，且具有稳定性，但速度不及堆排序、快速排序。 <br/>
冒泡排序（BubbleSort）的基本概念是：依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。至此第一趟结束，将最大的数放到了最后。在第二趟：仍从第一对数开始比较（因为可能由于第2个数和第3个数的交换，使得第1个数不再小于第2个数），将小数放前，大数放后，一直比较到倒数第二个数（倒数第一的位置上已经是
最大的），第二趟结束，在倒数第二的位置上得到一个新的最大数（其实在整个数列中是第二大的数）。如此下去，重复以上过程，直至最终完成排序。 <br/>
由于在排序过程中总是小数往前放，大数往后放，相当于气泡往上升，所以称作冒泡排序。 <br/>
若记录序列的初始状态为"正序"，则冒泡排序过程只需进行一趟排序，在排序过程中只需进行n-1次比较，且不移动记录；反之，若记录序列的初始状态为"逆序"，则需进行n(n-1）/2次比较和记录移动。因此冒泡排序总的时间复杂度为O(n*n)。</p>

<h2>快速排序（不稳定）</h2>

<p>快速排序（Quicksort）是对冒泡排序的一种改进。由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。  <br/>
``` c++ C++，快速排续
//C++，快速排序</p>

<p>void sort(int *a,int left,int right)
{</p>

<pre><code>int i=left,j=right;
int k=a[left];
if(left&gt;=right) return ;
while(i!=j)
{
    while(i&lt;j&amp;&amp; a[j]&gt;=k) j--;
    a[i]=a[j];
    while(i&lt;j&amp;&amp; a[i]&lt;=k) i++;
    a[j]=a[i];
}
a[i]=k;
sort(a,left,i-1);
sort(a,i+1,right);
</code></pre>

<p>}
```
本文是查阅书籍和网络资料整理而来，转载请注明出处。并以超链接的形式注明本文地址：http://tinyxd.me/blog/2012/06/27/swap-sort/ <br/>
下一节更新选择排序。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[排序算法总结（一）]]></title>
    <link href="http://tinyxd.me/blog/2012/06/27/straight-insertion-sort/"/>
    <updated>2012-06-27T08:00:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/27/straight-insertion-sort</id>
    <content type="html"><![CDATA[<p>排序算法是在学习数据结构的过程中，必须熟练掌握的。而由于其算法种类比较多，所以总结一下还是有必要的。今天先把插入排序总结下。 <br/>
插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n<sup>2)。是稳定的排序方法。</sup></p>

<h2>直接插入排序(straight insertion sort)</h2>

<p>每次从无序表中取出第一个元素，把它插入到有序表的合适位置，使有序表仍然有序。 <br/>
C/C++代码实现直接插入排序：  <br/>
``` c++  插入排序代码(straight insertion sort)
void insert_sort(int a[], int n)
{</p>

<pre><code>int i, j, temp;
for (i = 1; i &lt; n; ++i)
{
    temp = a[i];
    for (j = i; j&gt;0 &amp;&amp; temp &lt; a[j - 1]; --j)
    {
        a[j] = a[j - 1];
    }
    a[j] = temp;
}
</code></pre>

<p>}
```</p>

<!--more-->


<h2>希尔排序 (shell sort)</h2>

<p>概念：先取一个小于n（待排序的数据个数）的整数d1作为第一个增量，把文件的全部记录分成d1个组。把所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序，然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量dt=1（dt&lt;dt-1&lt;…&lt;d2&lt;d1），即所有记录放在同一组中进行直接插入排序为止。该方法实质上是一种分组直接插入方法。  <br/>
``` c++ 希尔排序(shell sort)
//希尔排序</p>

<h1>include &lt;stdio.h></h1>

<h1>define LEN 8</h1>

<p>void main (void)
{</p>

<pre><code>int d=LEN;
int R[LEN]={76,81,50,22,98,33,12,79};
int i,j,t=1,temp;
while(d&gt;0)
{
d/=2;
if(d&gt;0)
for(int y=0;y&lt;d ;y++)
{
    for(i=(d+y);i&lt;LEN;i=(i+d))
    {
        if(R[i]&lt;R[i-d])
        {
            temp=R[i];
            j=i-d;
            do{
                printf("%d -&gt; %d,",R[j],R[j+d]);
                R[j+d]=R[j];
                j=j-d;
            }while(j&gt;=0 &amp;&amp; temp &lt;R[j]);
            printf("%d -&gt; %d",temp,R[j+d]);
            R[j+d] = temp;
        }
        printf("\n");
        for(int a=0;a&lt;LEN;a++)
        {
            printf("%d",R[a]);
        }
        printf("%d\n",y+1);
        printf("\n");
        }
    printf("\n");
    }
}
</code></pre>

<p>}
<code>``
本文是查阅书籍和网络资料整理而来，转载请注明出处。并以超链接的形式注明本文地址：</code>http://tinyxd.me/blog/2012/06/27/straight-insertion-sort/ `<br/>
下一节更新交换排序。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用new申请动态空间的问题]]></title>
    <link href="http://tinyxd.me/blog/2012/06/14/yong-newshen-qing-dong-tai-kong-jian-de-wen-ti/"/>
    <updated>2012-06-14T07:27:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/14/yong-newshen-qing-dong-tai-kong-jian-de-wen-ti</id>
    <content type="html"><![CDATA[<p>先分析一下new的分配：</p>

<p>1.T*   p   =   new   T;  ···   delete   p;
等价于
T*   p   =   new   T[1]; ··· delete[]   p;</p>

<p>2.int   (*p)[n]   =   new   int[m][n];这种方式是可行的</p>

<p>3.所以new一个3x3的数组，也就是T   =   int[3][3] ，  那么可以这样写：
int   (*p)[3][3]   =   new   int[1][3][3];     删除时请调用delete[]   p;</p>

<!--more-->


<p>4.int** a；很容易造成内存泄漏最好不要用。</p>

<p>下面是自己写的一个test：
``` c++</p>

<h1>include <iostream></h1>

<p>using namespace std;
int main()</p>

<p>{</p>

<pre><code>size_t m=10;
int (*p)[10]=new int[m][10]();
for(size_t i=0;i!=10;++i)
    for(size_t j=0;j!=10;++j)
    {
        cout&lt;&lt; p[i]+j &lt;&lt;endl;

    }
cout&lt;&lt;sizeof(p)&lt;&lt;endl;
delete  [] p;
return 0;
</code></pre>

<p>}
```</p>

<p>还有一个问题是 ，c++中new的空间地址是连续的么？？</p>

<p>由于学习过linux内核，经过分析，有些时候是虚拟地址是连续的，而物理地址是不连续的。由于在内核中需要申请连续的物理地址空间的时候，使用类似kmalloc（）的函数，这样的话，如果size比较小的话，申请成功的概率还算高（尤其是刚开机不久），而申请大内存的话就有可能申请失败。申请虚拟地址的时候用vmalloc（），这个只能确保在虚拟地址上是连续的，而不能保证在物理地址是连续的，但是这个可以申请比较大的空间。</p>

<p>而看到网上说不同的操作系统会有不同的内存管理机制，而至于windows是咋样的，还需要进一步查找资料。</p>

<p>下面是转载的如何申请连续的地址空间（c++）（http://blog.csdn.net/zhongshengjun/article/details/4632156）：</p>

<blockquote><p>   地址连续的二维数组在C语言数值计算中有重要意义，很多二维数组的算法是基于一维数组写的。另外，在序列化时或内存复制时，连续空间易于进行整块内存的操作。</p>

<p>   子程序说明：</p>

<p>   1- Array2D和FreeArray2D可实现地址连续的动态二维数组的地址分配和释放。</p>

<p>  2- 作为对照，下面给出了地址不连续的二维数组地址分配与释放的子程序。</p>

<p>``` c++</p>

<pre><code>// 创建 n X m 的动态数组，该数组的元素地址在内存中是连续的
// n - 输入参数，数组的行数
// m - 输入参数，数组的列数
// 返回，double **，指向指针的指针，用于以二维数组的方式访问一段内存。
double **Array2D(int n,int m)
{
 // 建立数组的存储区，即在内存中分配一片连续的空间，元素个数为 n*m，
 // 返回指向double的指针。
    double *Array1D=new double[n*m];
 // 建立数组的索引区，返回指向 double *的指针（指向指针的指针），长度为 n。
    double **Array2D=new double* [n];
 // 将索引区的每个元素指向数据存储区对应元素的地址，Array2D[0] 指向 Array1D[0]，
 // Array2D[1] 指向 Array1D[m]，其余类推。
    for(int i=0;i&lt;n;i++)
    {
     Array2D[i]=&amp;Array1D[i*m];
    }
    return Array2D;
}
</code></pre></blockquote>

<pre><code>// 释放数组的空间，首先释放一维数组占用的n*m个double空间
// 再释放索引数组（指针数组）占用的n个double*空间
 void FreeArray2D(double **Array2D)
{
  delete[] Array2D[0];
  delete[] Array2D;
}

// 二维数组空间分配，地址一般不连续，不是推荐的方法
 double **Array2D_A(int n,int m)
{
 // 建立数组的索引区，返回指向 double *的指针（指向指针的指针），长度为 n。
    double **Array2D=new double* [n];

 // 建立数组的存储区，对于Array2D的每一个指针元素，分配m个double空间
    for(int i=0;i&lt;n;i++)
     Array2D[i]=new double[m];

    return Array2D;
}

// 释放数组的空间，与Array2D_A配套使用

// 首先释放n个一维数组（每个占用m个double空间）
// 再释放索引数组（指针数组）占用的n个double*空间
 void FreeArray2D_A(double **Array2D,int n)
{
    for(int i=0;i&lt;n;i++)
    delete[] Array2D[i];
  delete[] Array2D;
}
</code></pre>

<p>```</p>

<blockquote></blockquote>
]]></content>
  </entry>
  
</feed>
