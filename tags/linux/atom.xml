<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: linux | Keen on Art of Tech]]></title>
  <link href="http://tinyxd.me/tags/linux/atom.xml" rel="self"/>
  <link href="http://tinyxd.me/"/>
  <updated>2012-07-17T10:34:29+08:00</updated>
  <id>http://tinyxd.me/</id>
  <author>
    <name><![CDATA[Tiny]]></name>
    <email><![CDATA[admin@tinyxd.me]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[archlinux 无线网络连接]]></title>
    <link href="http://tinyxd.me/blog/2012/07/16/archlinux-wireless-network-connection/"/>
    <updated>2012-07-16T11:24:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/16/archlinux-wireless-network-connection</id>
    <content type="html"><![CDATA[<p>今天，回家了。由于家里用的无线路由器，我的本是archlinux系统，所以这就涉及到archlinux的无线网络配置。 <br/>
本文参考了<a href="https://wiki.archlinux.org/index.php/Wireless_Setup">archlinux官方wiki</a>。 <br/>
配置无线网络一般分两步： <br/>
第一步是识别硬件、安装正确的驱动程序并进行配置； <br/>
第二步是选择一种管理无线连接的方式。 <br/>
关于第一步，wiki中有详细的介绍，我就不多叙述。 <br/>
第二步，有几个命令和无线网络的加密方法，需要说说。 <br/>
大概有两种方法：一个是手动，一个是自动。</p>

<!--more-->


<h2>方法一：手动</h2>

<p>不加密/WEP ：ifconfig + iwconfig + dhcpcd/ifconfig  <br/>
WPA/WPA2 PSK：ifconfig + iwconfig + wpa_supplicant + dhcpcd/ifconfig  <br/>
1.激活内核接口:</p>

<pre><code># ifconfig wlan0 up    
</code></pre>

<p>2.查看可以的无线接入点信息：</p>

<pre><code># iwlist wlan0 scan
</code></pre>

<p>3.根据加密方式不同，需要使用密码将无线设备关联到接入点。
假设要使用的接入点 ESSID 为 MyEssid:  <br/>
a.无加密</p>

<pre><code># iwconfig wlan0 essid "MyEssid"   
</code></pre>

<p>b.WEP  <br/>
使用十六进制密码：</p>

<pre><code># iwconfig wlan0 essid "MyEssid" key 1234567890   
</code></pre>

<p>使用 ascii 密码：</p>

<pre><code># iwconfig wlan0 essid "MyEssid" key s:asciikey   
</code></pre>

<p>c.WPA/WPA2   <br/>
需要安装 WPA_Supplicant 编辑 /etc/wpa_supplicant.conf 文件。 <br/>
a.先备份下 /etc/wpa_supplicant.conf：</p>

<pre><code>mv /etc/wpa_supplicant.conf /etc/wpa_supplicant.conf.original   
</code></pre>

<p>b.修改此文件，适合你的无线网络环境。当然可以阅读系统自带的/etc/wpa_supplicant.conf ，然后根据自己的无线环境来手动编辑。也可以使用下面的命令。</p>

<pre><code>wpa_passphrase linksys "my_secret_passkey" &gt; /etc/wpa_supplicant.conf   
</code></pre>

<p>这里，linksys代表的是要连接的无线网络的essid,而my_secret_passkey则是无线网络的密码。然后运行：</p>

<pre><code># wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf
</code></pre>

<p>假设设备使用 wext 驱动。如果无法工作，可能需要调整选项，参见 <a href="https://wiki.archlinux.org/index.php/WPA_Supplicant">WPA_Supplicant</a>。 <br/>
4.获取IP地址。
静态IP：</p>

<pre><code># ifconfig wlan0 192.168.0.2
# route add default gw 192.168.0.1
</code></pre>

<p>动态IP获取使用 DHCP：</p>

<pre><code># dhcpcd wlan0
</code></pre>

<p>如果因为“waiting for carrier”出现超时错误，可以设置通道模式为 auto</p>

<pre><code># iwconfig wlan0 channel auto 
</code></pre>

<p>注意: 尽管手动配置可以帮助解决无线问题，每次重启都需要执行这些步骤。</p>

<h2>方法二：使用管理工具来管理</h2>

<p>netcfg, newlan (AUR), wicd, NetworkManager, 等。
我使用的是NetworkManager，地址在<a href="https://wiki.archlinux.org/index.php/NetworkManager">这里</a>。</p>

<br />   


<p>本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<a href="http://tinyxd.me/blog/2012/07/16/archlinux-wireless-network-connection/">http://tinyxd.me/blog/2012/07/16/archlinux-wireless-network-connection/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[archlinux下的时间时区设置]]></title>
    <link href="http://tinyxd.me/blog/2012/07/14/archlinux-time-config/"/>
    <updated>2012-07-14T23:56:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/14/archlinux-time-config</id>
    <content type="html"><![CDATA[<p>本文方法适合于archlinux，archbang等衍生版本。archbang亲测。 <br/>
1.打开<code>/etc/rc.conf</code>，将<code>TIMEZONE</code>改为<code>"Asia/Shanghai"</code>。 <br/>
2.打开<code>/etc/rc.conf</code>，将<code>HARDWARECLOCK</code>改为<code>"localtime"</code>。 <br/>
下面是改完的rc.conf：</p>

<!--more-->


<p> <br/>
{% codeblock  %}
#</p>

<h1>/etc/rc.conf - Main Configuration for Arch Linux</h1>

<p>LOCALE="en_US.UTF-8"
DAEMON_LOCALE="no"
HARDWARECLOCK="localtime"
TIMEZONE="Asia/Shanghai"
KEYMAP="us"
CONSOLEFONT=
CONSOLEMAP=
USECOLOR="yes"</p>

<p>MODULES=()</p>

<p>UDEV_TIMEOUT=30
USEDMRAID="no"
USEBTRFS="no"
USELVM="no"</p>

<p>HOSTNAME="archbang"</p>

<p>interface=eth0
address=
netmask=
broadcast=
gateway=</p>

<p>DAEMONS=(dbus networkmanager !network !dhcdbd syslog-ng @alsa @iNodeAuthService @openntpd)
{% endcodeblock %} <br/>
3.在<code>/etc/localtime</code>做个软链接给具体的<code>zoneinfo</code>：</p>

<pre><code>sudo ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime     
</code></pre>

<p>4.这个时候时区应该算是正确设置好了，把硬件时钟再同步回系统来。</p>

<pre><code>$ sudo hwclock --hctosys   
</code></pre>

<p>5.现在看时间正确了没，如果还有问题，参照archlinux的官方wiki（题外话：wiki是个好东西，可以找到你需要的）安装openNTPD，自动同步时间。</p>

<pre><code>$ sudo pacman -S openntpd   
</code></pre>

<p>配置文件看了下，基本都不用修改，直接起服务：</p>

<pre><code>$ sudo /etc/rc.d/openntpd start   
</code></pre>

<p>确保网络通畅，等一会，系统时间应该就会更新了，确实蛮方便 <br/>
最后在<code>rc.conf</code>的DAEMONS里面加上<code>@openntpd</code>，确保开机后台运行。</p>

<br />   


<p>本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<a href="http://tinyxd.me/blog/2012/07/14/archlinux-time-config/">http://tinyxd.me/blog/2012/07/14/archlinux-time-config/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[debian硬盘安装笔记]]></title>
    <link href="http://tinyxd.me/blog/2012/07/13/debian-setup/"/>
    <updated>2012-07-13T11:29:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/13/debian-setup</id>
    <content type="html"><![CDATA[<p>以前安装的时候都有光盘，这次换的机器，光驱坏了，那么有没有可能硬盘安装debian么？答案当然是可以的。 <br/>
1.下载debian最新ISO映像。 <br/>
2.下载安装所需要的vmlinuz  initrd.gz  boot.img.gz的这三个文件. <br/>
   下载地址：<a href="http://debian.osuosl.org/debian/dists/Debian6.0.5/main/installer-i386/current/images/hd-media/">http://debian.osuosl.org/debian/dists/Debian6.0.5/main/installer-i386/current/images/hd-media/</a> <br/>
3.下载grub4 for DOS    <br/>
下载地址：<a href="http://download.gna.org/grub4dos/grub4dos-0.4.4-2009-06-20.zip">http://download.gna.org/grub4dos/grub4dos-0.4.4-2009-06-20.zip</a></p>

<h2>安装过程：</h2>

<p>1、先把WINXP安装到C盘，这里唯一要说的是如果在安装WINXP时，选择了把C盘格式化为NTFS格式，那么之后安装用的DEBIAN的ISO文件就不能放在C盘了，必须放在FAT32格式的分区的根目录下。切记哦！否则硬盘安装DEBIAN时后找不到ISO文件哦。</p>

<p>WINXP安装好以后，把下载的GRUB4 for DOS包解压缩到C盘根目录，并将目录名改为grub，（个人认为不改也应该可以，不过没试，你可以试下呵），并进入GRUB目录将grldr文件复制到C盘根目录下；把vmlinuz、initrd.gz、boot.img.gz三个文件也复制到C盘根目录下：（基本上这个时候C盘是NTFS格式还是FAT32格式都没有关系的）</p>

<!--more-->


<p>2、打开C盘根目录下的boot.ini文件，打开boot.ini后在文件的最后一行加上    C:\grldr=”GRUB FOR DOS”</p>

<p>之后保存并关闭boot.ini文件。</p>

<p>3、把前面下载的DEBIAN安装CD的ISO文件复制到C盘根目录下，（要保证C盘是FAT32格式的），否则就复制到其它FAT32分区的根目录下。</p>

<p>4、以上检查没有问题后重新启动电脑，这时应该会出现如下启动菜单：</p>

<p>5、选第二项“GRUB FOR DOS”后，等屏幕出现如下画面时，按键盘上的“C”进入命令行状态。</p>

<p>6、按“C”键后屏幕显示如下：</p>

<p>7、这个时候输入如下三行命令：</p>

<pre><code>kernel (hd0,0)/vmlinuz

initrd (hd0,0)/initrd.gz

boot
</code></pre>

<p>这里的（hd0,0）指的是C盘，hd是指硬盘啦，第一个0是指电脑里的第一块硬盘，第二个0是指该硬盘上的第一个主分区，如果是第二个主分区就是（hd0,1）啦，如果你有兴趣上网查一下相关的知识了，这里不说了。</p>

<p>8、接下来就是安装debian，先会自动寻找ISO映像，找到后就开始安装，不再赘述。</p>

<p>9、如果你的C盘是FAT32格式的，ISO文件也复制到C盘根目录，那么就不用担心了，安装程序会自动找到的。（ISO文件在其它FAT32分区根目录下也一样，我已试过呵）</p>

<p>10、我的分区是这样的：/boot 200M  、2G swap、15G / 、其余大概40G的/home</p>

<p>11、等系统装好后，需要设置中文字体，还需要安装一些必要软件等等。见我以前的文章，下面是链接：<a href="http://blog.chinaunix.net/uid-26053577-id-3011222.html">http://blog.chinaunix.net/uid-26053577-id-3011222.html</a></p>

<p>本文章来自本人<strong><a href="http://blog.chinaunix.net/uid/26053577.html">ChinaUnix</a></strong>博客。  <br/>
本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<a href="http://tinyxd.me/blog/2012/07/13/debian-setup/">http://tinyxd.me/blog/2012/07/13/debian-setup/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[本地备份octopress]]></title>
    <link href="http://tinyxd.me/blog/2012/07/12/python-backup-octopress/"/>
    <updated>2012-07-12T22:42:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/12/python-backup-octopress</id>
    <content type="html"><![CDATA[<p>用python脚本备份octopress，当然也可以备份其他的目录。只要修改对应路径就可以了。
``` python octopress_backup.py</p>

<h1>!/usr/bin/python2</h1>

<h1>Filename: octopress_backup.py</h1>

<p>import os
import time</p>

<h1>1. 需要备份的目录(也可以将其他的文件夹一起打包)</h1>

<p>source = ['/home/tiny/octopress', '/home/tiny/mytest']</p>

<h1>2. 备份的目标位置</h1>

<p>target_dir = '/home/tiny/backup/' # Remember to change this to what you will be using</p>

<h1>3. 本脚本备份成tar，当然也可以压缩gzip。</h1>

<h1>4. 日期是目录名</h1>

<p>today = target_dir + time.strftime('%Y%m%d')</p>

<h1>当前时间是备份文件的名称</h1>

<p>now = time.strftime('%H%M%S')</p>

<h1>可以对备份的文件进行一些说明</h1>

<p>comment = raw_input('Enter a comment --> ')
if len(comment) == 0: # check if a comment was entered</p>

<pre><code>target = today + os.sep + now + '.tar'
</code></pre>

<p>else:</p>

<pre><code>target = today + os.sep + now + '_' +\
    comment.replace(' ', '_') + '.tar'
</code></pre>

<h1>创建子文件夹</h1>

<p>if not os.path.exists(today):</p>

<pre><code>os.mkdir(today) # make directory
print 'Successfully created directory', today
</code></pre>

<h1>5. tar压缩命令（unix/linux）</h1>

<p>tar_command = "tar -cvf '%s' %s" % (target, ' '.join(source))</p>

<h1>运行备份命令</h1>

<p>if os.system(tar_command) == 0:</p>

<pre><code>print 'Successful backup to', target
</code></pre>

<p>else:</p>

<pre><code>print 'Backup FAILED'
</code></pre>

<p>```</p>

<br />


<p>本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<a href="http://tinyxd.me/blog/2012/07/12/python-backup-octopress/">http://tinyxd.me/blog/2012/07/12/python-backup-octopress/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux工作队列]]></title>
    <link href="http://tinyxd.me/blog/2012/07/11/linux-workqueue/"/>
    <updated>2012-07-11T23:08:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/11/linux-workqueue</id>
    <content type="html"><![CDATA[<h2>工作队列(workqueue)</h2>

<p>Linux中的Workqueue机制就是为了简化内核线程的创建。通过调用workqueue的接口就能创建内核线程。并且可以根据当前系统CPU的个数创建线程的数量，使得线程处理的事务能够并行化。</p>

<p>workqueue是内核中实现简单而有效的机制，他显然简化了内核daemon的创建，方便了用户的编程，</p>

<p>尽管可延迟函数和工作队列非常相似，但是它们的区别还是很大的。主要区别在于：可延迟函数运行在中断上下文中，而工作队列中的函数运行在进程上下文中。执行可阻塞函数（例如：需要访问磁盘数据块的函数）的唯一方式是在进程上下文中运行。因为在中断上下文中不可能发生进程切换。可延迟函数和工作队列中的函数都不能访问进程的用户态地址空间。事实上，可延迟函数被执行时不可能有任何正在运行的进程。另一方面，工作队列中的函数是由内核线程来执行的，因此，根本不存在它要访问的用户态地址空间。</p>

<h2>工作队列的数据结构</h2>

<p style="text-indent:2em">与工作队列相关的主要数据结构有两个：cpu_workqueue_struct和work_struct。名为workqueue_struct的描述符，包括一个有NR_CPUS个元素的数组，NR_CPUS是系统中CPU的最大数量（双核是有两个工作队列）。每个元素都是cpu_workqueue_struct类型的描述符。 

</p>


<p></p>

<!--more-->


<p>work_struct结构是对任务的抽象。在该结构中需要维护具体的任务方法，需要处理的数据，以及任务处理的时间。该结构定义如下：</p>

<p>``` c
struct work_struct {</p>

<pre><code>unsigned long pending;                /*如果函数已经在工作队列链表中，该字段值设为1，否则设为0*/ 
    struct list_head entry;                  /* 将任务挂载到queue的挂载点 */ 
    void (*func)(void *);                   /* 任务方法 */ 
    void *data;                                  /* 任务处理的数据*/ 
   void *wq_data;                           /* work的属主（通常是指向cpu_workqueue_struct描述符的父结点的指针） */ 
   strut timer_list timer;                   /* 任务延时处理定时器 */ 
</code></pre>

<p>};
```</p>

<h2>工作队列函数</h2>

<p>当用户调用workqueue的初始化接口create_workqueue或者create_singlethread_workqueue对workqueue队列进行初始化时，内核就开始为用户分配一个workqueue对象，并且将其链到一个全局的workqueue队列中。然后Linux根据当前CPU的情况，为workqueue对象分配与CPU个数相同的cpu_workqueue_struct对象，每个cpu_workqueue_struct对象都会存在一条任务队列。紧接着，Linux为每个cpu_workqueue_struct对象分配一个内核thread，即内核daemon去处理每个队列中的任务。至此，用户调用初始化接口将workqueue初始化完毕，返回workqueue的指针。</p>

<p>在初始化workqueue过程中，内核需要初始化内核线程，注册的内核线程工作比较简单，就是不断的扫描对应cpu_workqueue_struct中的任务队列，从中获取一个有效任务，然后执行该任务。所以如果任务队列为空，那么内核daemon就在cpu_workqueue_struct中的等待队列上睡眠，直到有人唤醒daemon去处理任务队列.</p>

<p>Workqueue初始化完毕之后，将任务运行的上下文环境构建起来了，但是具体还没有可执行的任务，所以，需要定义具体的work_struct对象。然后将work_struct加入到任务队列中，Linux会唤醒daemon去处理任务。</p>

<p>queue_work()（封装在work_struct描述符中）把函数插入工作队列，它接收wq和work两个指针。wq指向workqueue_struct描述符，work指向work_struct描述符。queue_work（）主要执行下面的步骤：</p>

<p>1.检查要插入的函数是否已经在工作队列中（work->pending字段等于1），如果是就结束。</p>

<p>2.把work_struct描述符加到工作队列链表中，然后把work->pending置为1。</p>

<p>3.如果工作者线程在本地CPU的cpu_workqueue_struct描述符的more_work等待队列上睡眠，该函数唤醒这个线程。</p>

<h2>预定义工作队列</h2>

<p>在绝大多数情况下，为了运行一个函数而创建整个工作者线程开销太大了。因此，内核引入叫做events的预定义工作队列，所有的内核开发者都可以随便使用它。预定义工作队列只是一个包含不同内核层函数和IO驱动程序的标准工作队列，它的workququq_struct描述符存放在keventd_wq数组中。</p>

<p>工作队列编程接口：</p>

<table border="1"> 
<tr> 
    <th>序号</th> 
    <th>接口函数</th>  
    <th>函数说明</th> 
</tr>  
<tr>  
    <td>1</td>  
    <td>create_workqueue</td> 
    <td>用于创建一个workqueue队列，为系统中的每个CPU都创建一个内核线程。输入参数：@name：workqueue的名称</td> 
</tr>  
<tr>  
    <td>2</td>  
    <td>create_singlethread_workqueue</td>  
    <td>用于创建一个workqueue队列，为系统中的每个CPU都创建一个内核线程。输入参数：@name：workqueue的名称</td> 
</tr> 
<tr> 
    <td>3</td> 
    <td>destroy_workqueue</td> 
    <td>释放workqueue队列。输入参数：@ workqueue_struct：需要释放的workqueue队列指针</td> 
</tr>  
<tr> 
    <td>4</td> 
    <td>schedule_work</td> 
    <td>调度执行一个具体的任务，执行的任务将会被挂入Linux系统提供的workqueue——keventd_wq输入参数：@ work_struct：具体任务对象指针 
</td> 
</tr>  
<tr> 
    <td>5</td> 
    <td>schedule_delayed_work</td> 
    <td>延迟一定时间去执行一个具体的任务，功能与schedule_work类似，多了一个延迟时间，输入参数：@work_struct：具体任务对象指针@delay：延迟时间</td> 
</tr>  
<tr> 
    <td>6</td> 
    <td>queue_work</td> 
    <td>调度执行一个指定workqueue中的任务。输入参数：@ workqueue_struct：指定的workqueue指针@work_struct：具体任务对象指针</td> 
</tr>  
<tr> 
    <td>7</td> 
    <td>queue_delayed_work</td> 
    <td>延迟调度执行一个指定workqueue中的任务，功能与queue_work类似，输入参数多了一个delay</td> 
</tr>  
</table>


<p></p>

<p>预定义工作队列支持函数:</p>

<table > 
<tr> 
    <td>预定义工作队列函数</td> 
    <td>等价的标准工作队列函数</td> 
</tr> 
<tr> 
    <td>schedule_work(w)</td>     
    <td>queue_work( keventd_wq,w)</td> 
</tr> 
<tr> 
    <td>schedule_delayed_work(w,d)</td>     
    <td>queue_delayed_work(keventd_wq,w,d)在任何CPU上</td> 
</tr> 
<tr> 
    <td>schedule_delayed_work_on(cpu,w,d)</td>     
    <td>queue_delayed_work(keventd_wq,w,d)（在某个指定的CPU上）</td> 
</tr> 
<tr> 
    <td>flush_scheduled_work</td>     
    <td>flush_workqueue(keventd_wq)</td> 
</tr> 
</table>


<p></p>

<p>除了一般的events队列，在linux2.6中你还会发现一些专用的工作队列。其中最重要的是快设备层使用的kblockd工作队列。</p>

<p>本文章整理自网络和《深入理解linux内核》。  <br/>
本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<a href="http://tinyxd.me/blog/2012/07/11/linux-workqueue/">http://tinyxd.me/blog/2012/07/11/linux-workqueue/</a></p>
]]></content>
  </entry>
  
</feed>
