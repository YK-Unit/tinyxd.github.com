<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: linux | Keen on Art of Tech]]></title>
  <link href="http://tinyxd.me/tags/linux/atom.xml" rel="self"/>
  <link href="http://tinyxd.me/"/>
  <updated>2012-07-18T16:14:26+08:00</updated>
  <id>http://tinyxd.me/</id>
  <author>
    <name><![CDATA[Tiny]]></name>
    <email><![CDATA[admin@tinyxd.me]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[linux内核同步]]></title>
    <link href="http://tinyxd.me/blog/2012/07/18/linux-kernel-synchronization/"/>
    <updated>2012-07-18T15:57:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/18/linux-kernel-synchronization</id>
    <content type="html"><![CDATA[<h2>内核抢占</h2>

<p>抢占内核的主要特点是：一个在内核态运行的进程，可能在执行内核函数期间被另外一个进程取代。 <br/>
只有当内核正在执行异常处理程序（尤其是系统调用），而且内核抢占没有被显式地禁用时，才可能抢占内核。 <br/>
内核使用的各种同步技术：每CPU变量、原子操作、内存屏障、自旋锁、信号量、顺序锁、本地中断的禁止、本地软中断的禁止、读-拷贝-更新（RCU）。</p>

<h2>每CPU变量</h2>

<p>主要是数据结构的数组，系统的每个CPU对应数组的一个元素。 <br/>
一个CPU不应该访问与其他CPU对应的数组元素。另外，它可以随意读或修改它自己的元素而不用担心出现竞争条件，因为它是唯一有资格这么做的CPU。在单处理器和多处理器系统中，内核抢占都可能使每CPU变量产生竞争条件。总的原则是内核控制路径应该在禁用抢占的情况下访问每CPU变量。</p>

<!--more-->


<h2>原子操作</h2>

<p>若干汇编语言指令具有“读-修改-写”类型----也就是说，它们访问存储器单元两次，第一次读原值，第二次写新值。 <br/>
Linux内核提供了一个专门的atomic_t类型（一个原子计数器）和一些专门的函数和宏。在多处理器系统中，每条这样的指令都有一个lock字节（“锁定内存总线，直到这条指令执行完成”）的前缀。</p>

<h2>优化和内存屏障</h2>

<p>当使用优化的编译器时，编译器为了优化可能会重新安排汇编语言指令以便寄存器以最优的方式使用。 <br/>
内存屏障（memory barrier）原语确保，在原语之后的操作开始执行之前，原语之前的操作已经完成。</p>

<h2>自旋锁</h2>

<p>自旋锁（spin lock）是用来在多处理器环境中工作的一种特殊的锁。如果内核控制路径发现自旋锁“开着”，就获取锁并继续自己的执行。相反，如果内核控制路径发现锁由运行在另一个CPU上的内核控制路径“锁着”，就在周围“旋转”。反复执行一条紧凑的循环指令，直到锁被释放。   <br/>
一般来说，由自旋锁所保护的每个临界区都是禁止内核抢占的。在单处理器系统上，这种锁本身并不起锁的作用，自旋锁原语仅仅是禁止或启用内核抢占。  <br/>
在linux中，每个自旋锁都用spinlock_t结构表示，其中包含两个字段：</p>

<p>1.slock----表示自旋锁的状态。（1--未加锁  负数和0--加锁） <br/>
2.break_lock----表示进程正在忙等自旋锁（只在内核支持SMP和内核抢占的情况下使用该标志）</p>

<p>读写自旋锁的引入是为了增加内核的并发能力。只要没有内核控制路径堆数据结构进行修改，读写自旋锁就允许多个内核控制路径读同一数据结构。允许对数据结构并发度可以提高系统性能。 <br/>
顺序锁：与读写自旋锁非常相似，只是它为写者赋予了较高的优先级；事实上，即使在读者正在读的时候也允许写者继续运行。这种策略的好处是写者永远不会等待（除非另外一个写者正在写），缺点是有些时候读者不得不反复多次读相同的数据直到获得有效的副本。 <br/>
当读者进入临界区时，不必禁用内核抢占；另一方面，由于写者获取自旋锁，所以它进入临界区时自动禁用内核抢占。 <br/>
一般来说，在满足以下条件时才能使用顺序锁：</p>

<p>1.被保护的数据结构不包括被写者修改和被读者间接引用的指针（否则，写者可能在读者的眼鼻下就修改指针）。 <br/>
2.读者的临界区代码没有副作用（否则，多个读者的操作会与单独的读操作有不同的结果）。</p>

<h2>读-拷贝-更新（RCU）</h2>

<p>读-拷贝-更新（RCU）是为了保护在多数情况下被多个CPU读的数据结构而设计的另一种同步技术。RCU允许多个读者和写者并发执行，RCU不使用锁，就是说它不使用被所有CPU共享的锁或计数器。  <br/>
RCU同步的关键思想是：</p>

<p>1.RCU只保护被动态分配并通过指针引用的数据结构。 <br/>
2.在被RCU保护的临界区中，任何内核控制路径都不能睡眠。</p>

<p>使用RCU技术的真正困难在于：写者修改指针时不能立即释放数据结构的旧副本。实际上，写着开始修改时，正在访问数据结构的读者可能还在读旧副本。只有在CPU上的所有（潜在的）读者都执行完宏rcu_read_unlock()之后，才可以释放旧副本。 <br/>
RCU是Linux2.6中新加的功能，用在网络层和虚拟文件系统中。</p>

<h2>信号量</h2>

<p>Linux提供两种信号量：</p>

<p>1.内核信号量，由内核控制路径使用 <br/>
2.Systerm V IPC 信号量，由用户态进程使用</p>

<p>内核信号量：类似于自旋锁，因为当锁关闭着时，它不允许内核控制路径继续进行。只有可以睡眠的函数才能获取内核信号量；中断处理程序和可延迟函数都不能使用内核控制量。 <br/>
内核信号量是struct semaphore类型的对象。 <br/>
TASK_INTERRUPTIBLE是可以被信号和wake_up()唤醒的，当信号到来时，进程会被设置为可运行。 <br/>
而TASK_UNINTERRUPTIBLE只能被wake_up()唤醒。 <br/>
读/写信号量：类似于前面的“读写自旋锁”，有一点不同的是，在信号量再次变为打开之前，等待进程挂起而不是自旋。内核以严格的FIFO顺序处理等待读写信号量的所有进程。 <br/>
每个读写信号量都是有rw_semaphore结构描述的。 <br/>
补充原语（completion）：其和信号量之间的真正区别在于如何使用等待队列中包含的自旋锁。在补充原语中，自旋锁用来确保complete()和wait_for_completion()不会并发执行。在信号量中，自旋锁用于避免并发执行的down()函数弄乱信号量的数据结构。</p>

<br />


<p>本文章参考自《深入理解linux内核》。 <br/>
本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<a href="http://tinyxd.me/blog/2012/07/18/linux-kernel-synchronization/">http://tinyxd.me/blog/2012/07/18/linux-kernel-synchronization/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[archlinux 无线网络连接]]></title>
    <link href="http://tinyxd.me/blog/2012/07/16/archlinux-wireless-network-connection/"/>
    <updated>2012-07-16T11:24:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/16/archlinux-wireless-network-connection</id>
    <content type="html"><![CDATA[<p>今天，回家了。由于家里用的无线路由器，我的本是archlinux系统，所以这就涉及到archlinux的无线网络配置。 <br/>
本文参考了<a href="https://wiki.archlinux.org/index.php/Wireless_Setup">archlinux官方wiki</a>。 <br/>
配置无线网络一般分两步： <br/>
第一步是识别硬件、安装正确的驱动程序并进行配置； <br/>
第二步是选择一种管理无线连接的方式。 <br/>
关于第一步，wiki中有详细的介绍，我就不多叙述。 <br/>
第二步，有几个命令和无线网络的加密方法，需要说说。 <br/>
大概有两种方法：一个是手动，一个是自动。</p>

<!--more-->


<h2>方法一：手动</h2>

<p>不加密/WEP ：ifconfig + iwconfig + dhcpcd/ifconfig  <br/>
WPA/WPA2 PSK：ifconfig + iwconfig + wpa_supplicant + dhcpcd/ifconfig  <br/>
1.激活内核接口:</p>

<pre><code># ifconfig wlan0 up    
</code></pre>

<p>2.查看可以的无线接入点信息：</p>

<pre><code># iwlist wlan0 scan
</code></pre>

<p>3.根据加密方式不同，需要使用密码将无线设备关联到接入点。
假设要使用的接入点 ESSID 为 MyEssid:  <br/>
a.无加密</p>

<pre><code># iwconfig wlan0 essid "MyEssid"   
</code></pre>

<p>b.WEP  <br/>
使用十六进制密码：</p>

<pre><code># iwconfig wlan0 essid "MyEssid" key 1234567890   
</code></pre>

<p>使用 ascii 密码：</p>

<pre><code># iwconfig wlan0 essid "MyEssid" key s:asciikey   
</code></pre>

<p>c.WPA/WPA2   <br/>
需要安装 WPA_Supplicant 编辑 /etc/wpa_supplicant.conf 文件。 <br/>
a.先备份下 /etc/wpa_supplicant.conf：</p>

<pre><code>mv /etc/wpa_supplicant.conf /etc/wpa_supplicant.conf.original   
</code></pre>

<p>b.修改此文件，适合你的无线网络环境。当然可以阅读系统自带的/etc/wpa_supplicant.conf ，然后根据自己的无线环境来手动编辑。也可以使用下面的命令。</p>

<pre><code>wpa_passphrase linksys "my_secret_passkey" &gt; /etc/wpa_supplicant.conf   
</code></pre>

<p>这里，linksys代表的是要连接的无线网络的essid,而my_secret_passkey则是无线网络的密码。然后运行：</p>

<pre><code># wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf
</code></pre>

<p>假设设备使用 wext 驱动。如果无法工作，可能需要调整选项，参见 <a href="https://wiki.archlinux.org/index.php/WPA_Supplicant">WPA_Supplicant</a>。 <br/>
4.获取IP地址。
静态IP：</p>

<pre><code># ifconfig wlan0 192.168.0.2
# route add default gw 192.168.0.1
</code></pre>

<p>动态IP获取使用 DHCP：</p>

<pre><code># dhcpcd wlan0
</code></pre>

<p>如果因为“waiting for carrier”出现超时错误，可以设置通道模式为 auto</p>

<pre><code># iwconfig wlan0 channel auto 
</code></pre>

<p>注意: 尽管手动配置可以帮助解决无线问题，每次重启都需要执行这些步骤。</p>

<h2>方法二：使用管理工具来管理</h2>

<p>netcfg, newlan (AUR), wicd, NetworkManager, 等。
我使用的是NetworkManager，地址在<a href="https://wiki.archlinux.org/index.php/NetworkManager">这里</a>。</p>

<br />   


<p>本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<a href="http://tinyxd.me/blog/2012/07/16/archlinux-wireless-network-connection/">http://tinyxd.me/blog/2012/07/16/archlinux-wireless-network-connection/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[archlinux下的时间时区设置]]></title>
    <link href="http://tinyxd.me/blog/2012/07/14/archlinux-time-config/"/>
    <updated>2012-07-14T23:56:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/14/archlinux-time-config</id>
    <content type="html"><![CDATA[<p>本文方法适合于archlinux，archbang等衍生版本。archbang亲测。 <br/>
1.打开<code>/etc/rc.conf</code>，将<code>TIMEZONE</code>改为<code>"Asia/Shanghai"</code>。 <br/>
2.打开<code>/etc/rc.conf</code>，将<code>HARDWARECLOCK</code>改为<code>"localtime"</code>。 <br/>
下面是改完的rc.conf：</p>

<!--more-->


<p> <br/>
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1>/etc/rc.conf - Main Configuration for Arch Linux&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;p>LOCALE="en_US.UTF-8"
</span><span class='line'>DAEMON_LOCALE="no"
</span><span class='line'>HARDWARECLOCK="localtime"
</span><span class='line'>TIMEZONE="Asia/Shanghai"
</span><span class='line'>KEYMAP="us"
</span><span class='line'>CONSOLEFONT=
</span><span class='line'>CONSOLEMAP=
</span><span class='line'>USECOLOR="yes"&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>MODULES=()&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>UDEV_TIMEOUT=30
</span><span class='line'>USEDMRAID="no"
</span><span class='line'>USEBTRFS="no"
</span><span class='line'>USELVM="no"&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>HOSTNAME="archbang"&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>interface=eth0
</span><span class='line'>address=
</span><span class='line'>netmask=
</span><span class='line'>broadcast=
</span><span class='line'>gateway=&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>DAEMONS=(dbus networkmanager !network !dhcdbd syslog-ng @alsa @iNodeAuthService @openntpd)</span></code></pre></td></tr></table></div></figure></notextile></div> <br/>
3.在<code>/etc/localtime</code>做个软链接给具体的<code>zoneinfo</code>：</p>

<pre><code>sudo ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime     
</code></pre>

<p>4.这个时候时区应该算是正确设置好了，把硬件时钟再同步回系统来。</p>

<pre><code>$ sudo hwclock --hctosys   
</code></pre>

<p>5.现在看时间正确了没，如果还有问题，参照archlinux的官方wiki（题外话：wiki是个好东西，可以找到你需要的）安装openNTPD，自动同步时间。</p>

<pre><code>$ sudo pacman -S openntpd   
</code></pre>

<p>配置文件看了下，基本都不用修改，直接起服务：</p>

<pre><code>$ sudo /etc/rc.d/openntpd start   
</code></pre>

<p>确保网络通畅，等一会，系统时间应该就会更新了，确实蛮方便 <br/>
最后在<code>rc.conf</code>的DAEMONS里面加上<code>@openntpd</code>，确保开机后台运行。</p>

<br />   


<p>本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<a href="http://tinyxd.me/blog/2012/07/14/archlinux-time-config/">http://tinyxd.me/blog/2012/07/14/archlinux-time-config/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[debian硬盘安装笔记]]></title>
    <link href="http://tinyxd.me/blog/2012/07/13/debian-setup/"/>
    <updated>2012-07-13T11:29:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/13/debian-setup</id>
    <content type="html"><![CDATA[<p>以前安装的时候都有光盘，这次换的机器，光驱坏了，那么有没有可能硬盘安装debian么？答案当然是可以的。 <br/>
1.下载debian最新ISO映像。 <br/>
2.下载安装所需要的vmlinuz  initrd.gz  boot.img.gz的这三个文件. <br/>
   下载地址：<a href="http://debian.osuosl.org/debian/dists/Debian6.0.5/main/installer-i386/current/images/hd-media/">http://debian.osuosl.org/debian/dists/Debian6.0.5/main/installer-i386/current/images/hd-media/</a> <br/>
3.下载grub4 for DOS    <br/>
下载地址：<a href="http://download.gna.org/grub4dos/grub4dos-0.4.4-2009-06-20.zip">http://download.gna.org/grub4dos/grub4dos-0.4.4-2009-06-20.zip</a></p>

<h2>安装过程：</h2>

<p>1、先把WINXP安装到C盘，这里唯一要说的是如果在安装WINXP时，选择了把C盘格式化为NTFS格式，那么之后安装用的DEBIAN的ISO文件就不能放在C盘了，必须放在FAT32格式的分区的根目录下。切记哦！否则硬盘安装DEBIAN时后找不到ISO文件哦。</p>

<p>WINXP安装好以后，把下载的GRUB4 for DOS包解压缩到C盘根目录，并将目录名改为grub，（个人认为不改也应该可以，不过没试，你可以试下呵），并进入GRUB目录将grldr文件复制到C盘根目录下；把vmlinuz、initrd.gz、boot.img.gz三个文件也复制到C盘根目录下：（基本上这个时候C盘是NTFS格式还是FAT32格式都没有关系的）</p>

<!--more-->


<p>2、打开C盘根目录下的boot.ini文件，打开boot.ini后在文件的最后一行加上    C:\grldr=”GRUB FOR DOS”</p>

<p>之后保存并关闭boot.ini文件。</p>

<p>3、把前面下载的DEBIAN安装CD的ISO文件复制到C盘根目录下，（要保证C盘是FAT32格式的），否则就复制到其它FAT32分区的根目录下。</p>

<p>4、以上检查没有问题后重新启动电脑，这时应该会出现如下启动菜单：</p>

<p>5、选第二项“GRUB FOR DOS”后，等屏幕出现如下画面时，按键盘上的“C”进入命令行状态。</p>

<p>6、按“C”键后屏幕显示如下：</p>

<p>7、这个时候输入如下三行命令：</p>

<pre><code>kernel (hd0,0)/vmlinuz

initrd (hd0,0)/initrd.gz

boot
</code></pre>

<p>这里的（hd0,0）指的是C盘，hd是指硬盘啦，第一个0是指电脑里的第一块硬盘，第二个0是指该硬盘上的第一个主分区，如果是第二个主分区就是（hd0,1）啦，如果你有兴趣上网查一下相关的知识了，这里不说了。</p>

<p>8、接下来就是安装debian，先会自动寻找ISO映像，找到后就开始安装，不再赘述。</p>

<p>9、如果你的C盘是FAT32格式的，ISO文件也复制到C盘根目录，那么就不用担心了，安装程序会自动找到的。（ISO文件在其它FAT32分区根目录下也一样，我已试过呵）</p>

<p>10、我的分区是这样的：/boot 200M  、2G swap、15G / 、其余大概40G的/home</p>

<p>11、等系统装好后，需要设置中文字体，还需要安装一些必要软件等等。见我以前的文章，下面是链接：<a href="http://blog.chinaunix.net/uid-26053577-id-3011222.html">http://blog.chinaunix.net/uid-26053577-id-3011222.html</a></p>

<p>本文章来自本人<strong><a href="http://blog.chinaunix.net/uid/26053577.html">ChinaUnix</a></strong>博客。  <br/>
本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<a href="http://tinyxd.me/blog/2012/07/13/debian-setup/">http://tinyxd.me/blog/2012/07/13/debian-setup/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[本地备份octopress]]></title>
    <link href="http://tinyxd.me/blog/2012/07/12/python-backup-octopress/"/>
    <updated>2012-07-12T22:42:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/12/python-backup-octopress</id>
    <content type="html"><![CDATA[<p>用python脚本备份octopress，当然也可以备份其他的目录。只要修改对应路径就可以了。
``` python octopress_backup.py</p>

<h1>!/usr/bin/python2</h1>

<h1>Filename: octopress_backup.py</h1>

<p>import os
import time</p>

<h1>1. 需要备份的目录(也可以将其他的文件夹一起打包)</h1>

<p>source = ['/home/tiny/octopress', '/home/tiny/mytest']</p>

<h1>2. 备份的目标位置</h1>

<p>target_dir = '/home/tiny/backup/' # Remember to change this to what you will be using</p>

<h1>3. 本脚本备份成tar，当然也可以压缩gzip。</h1>

<h1>4. 日期是目录名</h1>

<p>today = target_dir + time.strftime('%Y%m%d')</p>

<h1>当前时间是备份文件的名称</h1>

<p>now = time.strftime('%H%M%S')</p>

<h1>可以对备份的文件进行一些说明</h1>

<p>comment = raw_input('Enter a comment --> ')
if len(comment) == 0: # check if a comment was entered</p>

<pre><code>target = today + os.sep + now + '.tar'
</code></pre>

<p>else:</p>

<pre><code>target = today + os.sep + now + '_' +\
    comment.replace(' ', '_') + '.tar'
</code></pre>

<h1>创建子文件夹</h1>

<p>if not os.path.exists(today):</p>

<pre><code>os.mkdir(today) # make directory
print 'Successfully created directory', today
</code></pre>

<h1>5. tar压缩命令（unix/linux）</h1>

<p>tar_command = "tar -cvf '%s' %s" % (target, ' '.join(source))</p>

<h1>运行备份命令</h1>

<p>if os.system(tar_command) == 0:</p>

<pre><code>print 'Successful backup to', target
</code></pre>

<p>else:</p>

<pre><code>print 'Backup FAILED'
</code></pre>

<p>```</p>

<br />


<p>本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<a href="http://tinyxd.me/blog/2012/07/12/python-backup-octopress/">http://tinyxd.me/blog/2012/07/12/python-backup-octopress/</a></p>
]]></content>
  </entry>
  
</feed>
