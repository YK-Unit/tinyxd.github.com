<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: linux | Keen on Art of Tech]]></title>
  <link href="http://tinyxd.me/tags/linux/atom.xml" rel="self"/>
  <link href="http://tinyxd.me/"/>
  <updated>2012-07-26T12:54:00+08:00</updated>
  <id>http://tinyxd.me/</id>
  <author>
    <name><![CDATA[Tiny]]></name>
    <email><![CDATA[admin@tinyxd.me]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[linux系统定时测量]]></title>
    <link href="http://tinyxd.me/blog/2012/07/26/linux-timing-measurements/"/>
    <updated>2012-07-26T12:48:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/26/linux-timing-measurements</id>
    <content type="html"><![CDATA[<p>Linux内核必须完成的两种主要定时测量：</p>

<p>保存当前的时间和日期，以便通过time()、ftime()、gettimeofday()系统调用把它们返回给用户程序，也可以由内核本身把当前时间作为文件和网络包的时间戳。</p>

<p>维持定时器，这种机制能够告诉内核或用户程序某一时间间隔已经过去了。</p>

<p>一般会遇到的几种时钟和定时器电路：实时时钟（Real Time Clock RTC）、时间戳计数器（Time Stamp Counter TSC）、可编程间隔定时器（Programmable Interval Timer PIT）、CPU本地定时器（APIC中）、高精度事件定时器（HPET）、ACPI电源管理定时器。</p>

<p>Linux的计时体系结构是一组与时间流相关的内核数据结构和函数。实际上，基于80x86多处理器机器所具有的计时体系结构与单处理器机器所具有的稍有不同：</p>

<p>在三处理器系统上，所有的计时活动都是由全局定时器（可以是可编程间隔定时器也可以是高精度事件定时器）产生的中断触发的。</p>

<!--more-->


<p>在多处理器系统上，所有普通的活动（像软定时器处理）都是由全局定时器产生的中断触发的，而具体的CPU的活动（像监控当前运行进程的执行时间）是由本地APIC定时器产生的中断触发的。</p>

<p>jiffies</p>

<p>jiffies是一个计数器，用来记录自系统启动依赖产生的节拍总数。启动时，内核将该变量初始化为0，此后，每次时钟中断处理程序都会增加该变量的值。因为一秒内时钟中断的次数等于Hz，所以jiffies一秒内增加的值也就为Hz。系统运行时间以秒为单位计算，就等于jiffies/Hz。</p>

<p>xtime</p>

<p>xtime变量存放当前时间和日期；它是一个timespec类型的数据结构，该结构有两个字段：</p>

<p>1.tv_sec 存放自1970年1月1日（UTC）午夜以来经过的秒数。</p>

<p>2.tv_nsec存放自上一秒开始经过的纳秒数（它的值域范围在0-999999999之间）</p>

<p>在单处理器系统上，所有与定时有关的活动都是由IRQ线0上的可编程间隔定时器产生的中断触发的。</p>

<p>多处理器系统可以依赖两种不同的时钟中断源：可编程间隔定时器或高精度事件定时器产生的中断，以及CPU本地定时器产生的中断(监管内核代码并检测当前进程在特定CPU上已经运行了多长时间)。</p>

<p>内核在于定时相关的其他任务中必须周期性地收集若干数据用于：</p>

<pre><code>检查运行进程的CPU资源限制  

更新与本地CPU工作负载有关的统计数  

计算平均系统负载  

监管内核代码  
</code></pre>

<p>软定时器和延迟函数</p>

<p>定时器是一种软件功能，即允许在将来的某个时期，函数在给定的时间间隔用完时被调用。超时（time-out）表示与定时器相关的时间间隔已经用完的那个时刻。</p>

<p>Linux考虑两种类型的定时器，即动态定时器（dynamic timer）和间隔定时器（interval timer）。第一种类型由内核使用，而间隔定时器可以由进程在用户态创建。</p>

<p>延迟函数</p>

<p>当内核需要等待一个较短的时间间隔（比方说，不超过几毫秒）时，就不需要使用软定时器。</p>

<p>开发驱动，需要较短的时间间隔，在以上情况下，内核使用udelay()和ndelay()函数：前者接收一个微妙级的时间间隔作为它的参数，并在指定的延迟结束后返回；后者与前者类似，但是指定的延迟参数是纳秒级的。</p>

<p>本文章参考自《深入理解linux内核》。 <br/>
本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<a href="http://tinyxd.me/blog/2012/07/26/linux-timing-measurements/">http://tinyxd.me/blog/2012/07/26/linux-timing-measurements/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[archlinux升级出现关于glibc的问题解决办法]]></title>
    <link href="http://tinyxd.me/blog/2012/07/25/archlinux-update-about-glibc/"/>
    <updated>2012-07-25T18:44:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/25/archlinux-update-about-glibc</id>
    <content type="html"><![CDATA[<p>好久没更新archlinux，今天更新，发现由于archlinux系统根目录结构的改变，导致好多人遇到问题，不错，笔者必然也遇到了。由于有前人的探索，再加上查阅archlinux官网论坛，得以顺利解决问题。
运行<code>pacman -Syu</code>时会出现 <br/>
<code>
error: failed to commit transaction (conflicting files)
glibc: /lib exists in filesystem
Errors occurred, no packages were upgraded.
</code> <br/>
由于这次是glibc的升级，绝对不可以用<code>--force</code>，而之前是filesysterm的升级，必须用<code>--force</code>。 <br/>
那么接下来该怎么办呢？ <br/>
查阅了archlinux论坛地址：<a href="https://bbs.archlinux.org/viewforum.php?id=44">https://bbs.archlinux.org/viewforum.php?id=44</a>，并参考了<a href="http://www.j927.net/arch/archlinux%E5%8D%87%E7%BA%A7%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95.html">这篇文章</a>。    <br/>
发现这个<a href="https://bbs.archlinux.org/viewtopic.php?id=145186">帖子</a>，其中提到这两篇文章：<a href="http://allanmcrae.com/2012/07/updating-arch-linux-from-a-core-install/">updating-arch-linux-from-a-core-install</a> 和<a href="https://wiki.archlinux.org/index.php/DeveloperWiki:usrlib">DeveloperWiki:usrlib</a>，总结以下命令：</p>

<!--more-->


<p> <br/>
<code>
shell &gt; pacman -Sy
shell &gt; rm -rf /var/run /var/lock &amp;&amp; pacman -Sf filesystem
shell &gt; pacman -S tzdata
shell &gt; pacman -U http://pkgbuild.com/~allan/glibc-2.16.0-1-i686.pkg.tar.xz #32位的用这个包(和下面的一条命令二选一)
shell &gt; pacman -U http://pkgbuild.com/~allan/glibc-2.16.0-1-x86_64.pkg.tar.xz #64位的用这个包 具体的包名称可以打开http://pkgbuild.com/~allan/看一下
shell &gt; rm /etc/profile.d/locale.sh
shell &gt; pacman -Su --ignore glibc #因为pacman也升级了，新版本开启了软件包签名验证，故还需要运行下面2条命令
shell &gt; pacman-key --init #该命令运行后不要什么都不做，随机敲键盘或者切换到其它终端(Alt+F2)运行些命令或做些其它操作
shell &gt; pacman-key --populate archlinux
shell &gt; pacman -Su #再更新被忽略的glibc
</code>
执行完上述命令后，系统顺利更新好了，但是依然出现下述问题： <br/>
<code>
error: failed to commit transaction (conflicting files)
glibc: /lib exists in filesystem
Errors occurred, no packages were upgraded.
</code> <br/>
我就去论坛中寻找，果不其然也有类似于我的情况，原帖<a href="http://bbs.archbang.org/viewtopic.php?pid=16509">在此</a>。
<code>
shell &gt; pacman -R broadcom-wl
shell &gt; pacman -Su
shell &gt; pacman -S broadcom-wl #如果需要的话，再次安装即可
</code>
至此，升级结束。</p>

<br />


<p>本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<a href="http://tinyxd.me/blog/2012/07/25/archlinux-update-about-glibc/">http://tinyxd.me/blog/2012/07/25/archlinux-update-about-glibc/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux内核同步]]></title>
    <link href="http://tinyxd.me/blog/2012/07/18/linux-kernel-synchronization/"/>
    <updated>2012-07-18T15:57:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/18/linux-kernel-synchronization</id>
    <content type="html"><![CDATA[<h2>内核抢占</h2>

<p>抢占内核的主要特点是：一个在内核态运行的进程，可能在执行内核函数期间被另外一个进程取代。 <br/>
只有当内核正在执行异常处理程序（尤其是系统调用），而且内核抢占没有被显式地禁用时，才可能抢占内核。 <br/>
内核使用的各种同步技术：每CPU变量、原子操作、内存屏障、自旋锁、信号量、顺序锁、本地中断的禁止、本地软中断的禁止、读-拷贝-更新（RCU）。</p>

<h2>每CPU变量</h2>

<p>主要是数据结构的数组，系统的每个CPU对应数组的一个元素。 <br/>
一个CPU不应该访问与其他CPU对应的数组元素。另外，它可以随意读或修改它自己的元素而不用担心出现竞争条件，因为它是唯一有资格这么做的CPU。在单处理器和多处理器系统中，内核抢占都可能使每CPU变量产生竞争条件。总的原则是内核控制路径应该在禁用抢占的情况下访问每CPU变量。</p>

<!--more-->


<h2>原子操作</h2>

<p>若干汇编语言指令具有“读-修改-写”类型----也就是说，它们访问存储器单元两次，第一次读原值，第二次写新值。 <br/>
Linux内核提供了一个专门的atomic_t类型（一个原子计数器）和一些专门的函数和宏。在多处理器系统中，每条这样的指令都有一个lock字节（“锁定内存总线，直到这条指令执行完成”）的前缀。</p>

<h2>优化和内存屏障</h2>

<p>当使用优化的编译器时，编译器为了优化可能会重新安排汇编语言指令以便寄存器以最优的方式使用。 <br/>
内存屏障（memory barrier）原语确保，在原语之后的操作开始执行之前，原语之前的操作已经完成。</p>

<h2>自旋锁</h2>

<p>自旋锁（spin lock）是用来在多处理器环境中工作的一种特殊的锁。如果内核控制路径发现自旋锁“开着”，就获取锁并继续自己的执行。相反，如果内核控制路径发现锁由运行在另一个CPU上的内核控制路径“锁着”，就在周围“旋转”。反复执行一条紧凑的循环指令，直到锁被释放。   <br/>
一般来说，由自旋锁所保护的每个临界区都是禁止内核抢占的。在单处理器系统上，这种锁本身并不起锁的作用，自旋锁原语仅仅是禁止或启用内核抢占。  <br/>
在linux中，每个自旋锁都用spinlock_t结构表示，其中包含两个字段：</p>

<p>1.slock----表示自旋锁的状态。（1--未加锁  负数和0--加锁） <br/>
2.break_lock----表示进程正在忙等自旋锁（只在内核支持SMP和内核抢占的情况下使用该标志）</p>

<p>读写自旋锁的引入是为了增加内核的并发能力。只要没有内核控制路径堆数据结构进行修改，读写自旋锁就允许多个内核控制路径读同一数据结构。允许对数据结构并发度可以提高系统性能。 <br/>
顺序锁：与读写自旋锁非常相似，只是它为写者赋予了较高的优先级；事实上，即使在读者正在读的时候也允许写者继续运行。这种策略的好处是写者永远不会等待（除非另外一个写者正在写），缺点是有些时候读者不得不反复多次读相同的数据直到获得有效的副本。 <br/>
当读者进入临界区时，不必禁用内核抢占；另一方面，由于写者获取自旋锁，所以它进入临界区时自动禁用内核抢占。 <br/>
一般来说，在满足以下条件时才能使用顺序锁：</p>

<p>1.被保护的数据结构不包括被写者修改和被读者间接引用的指针（否则，写者可能在读者的眼鼻下就修改指针）。 <br/>
2.读者的临界区代码没有副作用（否则，多个读者的操作会与单独的读操作有不同的结果）。</p>

<h2>读-拷贝-更新（RCU）</h2>

<p>读-拷贝-更新（RCU）是为了保护在多数情况下被多个CPU读的数据结构而设计的另一种同步技术。RCU允许多个读者和写者并发执行，RCU不使用锁，就是说它不使用被所有CPU共享的锁或计数器。  <br/>
RCU同步的关键思想是：</p>

<p>1.RCU只保护被动态分配并通过指针引用的数据结构。 <br/>
2.在被RCU保护的临界区中，任何内核控制路径都不能睡眠。</p>

<p>使用RCU技术的真正困难在于：写者修改指针时不能立即释放数据结构的旧副本。实际上，写着开始修改时，正在访问数据结构的读者可能还在读旧副本。只有在CPU上的所有（潜在的）读者都执行完宏rcu_read_unlock()之后，才可以释放旧副本。 <br/>
RCU是Linux2.6中新加的功能，用在网络层和虚拟文件系统中。</p>

<h2>信号量</h2>

<p>Linux提供两种信号量：</p>

<p>1.内核信号量，由内核控制路径使用 <br/>
2.Systerm V IPC 信号量，由用户态进程使用</p>

<p>内核信号量：类似于自旋锁，因为当锁关闭着时，它不允许内核控制路径继续进行。只有可以睡眠的函数才能获取内核信号量；中断处理程序和可延迟函数都不能使用内核控制量。 <br/>
内核信号量是struct semaphore类型的对象。 <br/>
TASK_INTERRUPTIBLE是可以被信号和wake_up()唤醒的，当信号到来时，进程会被设置为可运行。 <br/>
而TASK_UNINTERRUPTIBLE只能被wake_up()唤醒。 <br/>
读/写信号量：类似于前面的“读写自旋锁”，有一点不同的是，在信号量再次变为打开之前，等待进程挂起而不是自旋。内核以严格的FIFO顺序处理等待读写信号量的所有进程。 <br/>
每个读写信号量都是有rw_semaphore结构描述的。 <br/>
补充原语（completion）：其和信号量之间的真正区别在于如何使用等待队列中包含的自旋锁。在补充原语中，自旋锁用来确保complete()和wait_for_completion()不会并发执行。在信号量中，自旋锁用于避免并发执行的down()函数弄乱信号量的数据结构。</p>

<br />


<p>本文章参考自《深入理解linux内核》。 <br/>
本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<a href="http://tinyxd.me/blog/2012/07/18/linux-kernel-synchronization/">http://tinyxd.me/blog/2012/07/18/linux-kernel-synchronization/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[archlinux 无线网络连接]]></title>
    <link href="http://tinyxd.me/blog/2012/07/16/archlinux-wireless-network-connection/"/>
    <updated>2012-07-16T11:24:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/16/archlinux-wireless-network-connection</id>
    <content type="html"><![CDATA[<p>今天，回家了。由于家里用的无线路由器，我的本是archlinux系统，所以这就涉及到archlinux的无线网络配置。 <br/>
本文参考了<a href="https://wiki.archlinux.org/index.php/Wireless_Setup">archlinux官方wiki</a>。 <br/>
配置无线网络一般分两步： <br/>
第一步是识别硬件、安装正确的驱动程序并进行配置； <br/>
第二步是选择一种管理无线连接的方式。 <br/>
关于第一步，wiki中有详细的介绍，我就不多叙述。 <br/>
第二步，有几个命令和无线网络的加密方法，需要说说。 <br/>
大概有两种方法：一个是手动，一个是自动。</p>

<!--more-->


<h2>方法一：手动</h2>

<p>不加密/WEP ：ifconfig + iwconfig + dhcpcd/ifconfig  <br/>
WPA/WPA2 PSK：ifconfig + iwconfig + wpa_supplicant + dhcpcd/ifconfig  <br/>
1.激活内核接口:</p>

<pre><code># ifconfig wlan0 up    
</code></pre>

<p>2.查看可以的无线接入点信息：</p>

<pre><code># iwlist wlan0 scan
</code></pre>

<p>3.根据加密方式不同，需要使用密码将无线设备关联到接入点。
假设要使用的接入点 ESSID 为 MyEssid:  <br/>
a.无加密</p>

<pre><code># iwconfig wlan0 essid "MyEssid"   
</code></pre>

<p>b.WEP  <br/>
使用十六进制密码：</p>

<pre><code># iwconfig wlan0 essid "MyEssid" key 1234567890   
</code></pre>

<p>使用 ascii 密码：</p>

<pre><code># iwconfig wlan0 essid "MyEssid" key s:asciikey   
</code></pre>

<p>c.WPA/WPA2   <br/>
需要安装 WPA_Supplicant 编辑 /etc/wpa_supplicant.conf 文件。 <br/>
a.先备份下 /etc/wpa_supplicant.conf：</p>

<pre><code>mv /etc/wpa_supplicant.conf /etc/wpa_supplicant.conf.original   
</code></pre>

<p>b.修改此文件，适合你的无线网络环境。当然可以阅读系统自带的/etc/wpa_supplicant.conf ，然后根据自己的无线环境来手动编辑。也可以使用下面的命令。</p>

<pre><code>wpa_passphrase linksys "my_secret_passkey" &gt; /etc/wpa_supplicant.conf   
</code></pre>

<p>这里，linksys代表的是要连接的无线网络的essid,而my_secret_passkey则是无线网络的密码。然后运行：</p>

<pre><code># wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf
</code></pre>

<p>假设设备使用 wext 驱动。如果无法工作，可能需要调整选项，参见 <a href="https://wiki.archlinux.org/index.php/WPA_Supplicant">WPA_Supplicant</a>。 <br/>
4.获取IP地址。
静态IP：</p>

<pre><code># ifconfig wlan0 192.168.0.2
# route add default gw 192.168.0.1
</code></pre>

<p>动态IP获取使用 DHCP：</p>

<pre><code># dhcpcd wlan0
</code></pre>

<p>如果因为“waiting for carrier”出现超时错误，可以设置通道模式为 auto</p>

<pre><code># iwconfig wlan0 channel auto 
</code></pre>

<p>注意: 尽管手动配置可以帮助解决无线问题，每次重启都需要执行这些步骤。</p>

<h2>方法二：使用管理工具来管理</h2>

<p>netcfg, newlan (AUR), wicd, NetworkManager, 等。
我使用的是NetworkManager，地址在<a href="https://wiki.archlinux.org/index.php/NetworkManager">这里</a>。</p>

<br />   


<p>本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<a href="http://tinyxd.me/blog/2012/07/16/archlinux-wireless-network-connection/">http://tinyxd.me/blog/2012/07/16/archlinux-wireless-network-connection/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[archlinux下的时间时区设置]]></title>
    <link href="http://tinyxd.me/blog/2012/07/14/archlinux-time-config/"/>
    <updated>2012-07-14T23:56:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/14/archlinux-time-config</id>
    <content type="html"><![CDATA[<p>本文方法适合于archlinux，archbang等衍生版本。archbang亲测。 <br/>
1.打开<code>/etc/rc.conf</code>，将<code>TIMEZONE</code>改为<code>"Asia/Shanghai"</code>。 <br/>
2.打开<code>/etc/rc.conf</code>，将<code>HARDWARECLOCK</code>改为<code>"localtime"</code>。 <br/>
下面是改完的rc.conf：</p>

<!--more-->


<p> <br/>
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1>/etc/rc.conf - Main Configuration for Arch Linux&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;p>LOCALE="en_US.UTF-8"
</span><span class='line'>DAEMON_LOCALE="no"
</span><span class='line'>HARDWARECLOCK="localtime"
</span><span class='line'>TIMEZONE="Asia/Shanghai"
</span><span class='line'>KEYMAP="us"
</span><span class='line'>CONSOLEFONT=
</span><span class='line'>CONSOLEMAP=
</span><span class='line'>USECOLOR="yes"&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>MODULES=()&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>UDEV_TIMEOUT=30
</span><span class='line'>USEDMRAID="no"
</span><span class='line'>USEBTRFS="no"
</span><span class='line'>USELVM="no"&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>HOSTNAME="archbang"&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>interface=eth0
</span><span class='line'>address=
</span><span class='line'>netmask=
</span><span class='line'>broadcast=
</span><span class='line'>gateway=&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>DAEMONS=(dbus networkmanager !network !dhcdbd syslog-ng @alsa @iNodeAuthService @openntpd)</span></code></pre></td></tr></table></div></figure></notextile></div> <br/>
3.在<code>/etc/localtime</code>做个软链接给具体的<code>zoneinfo</code>：</p>

<pre><code>sudo ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime     
</code></pre>

<p>4.这个时候时区应该算是正确设置好了，把硬件时钟再同步回系统来。</p>

<pre><code>$ sudo hwclock --hctosys   
</code></pre>

<p>5.现在看时间正确了没，如果还有问题，参照archlinux的官方wiki（题外话：wiki是个好东西，可以找到你需要的）安装openNTPD，自动同步时间。</p>

<pre><code>$ sudo pacman -S openntpd   
</code></pre>

<p>配置文件看了下，基本都不用修改，直接起服务：</p>

<pre><code>$ sudo /etc/rc.d/openntpd start   
</code></pre>

<p>确保网络通畅，等一会，系统时间应该就会更新了，确实蛮方便 <br/>
最后在<code>rc.conf</code>的DAEMONS里面加上<code>@openntpd</code>，确保开机后台运行。</p>

<br />   


<p>本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<a href="http://tinyxd.me/blog/2012/07/14/archlinux-time-config/">http://tinyxd.me/blog/2012/07/14/archlinux-time-config/</a></p>
]]></content>
  </entry>
  
</feed>
