<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: linux | Keen on Art of Tech]]></title>
  <link href="http://tinyxd.me/tags/linux/atom.xml" rel="self"/>
  <link href="http://tinyxd.me/"/>
  <updated>2012-07-09T00:38:19+08:00</updated>
  <id>http://tinyxd.me/</id>
  <author>
    <name><![CDATA[Tiny]]></name>
    <email><![CDATA[admin@tinyxd.me]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[linux sleep 的用法]]></title>
    <link href="http://tinyxd.me/blog/2012/07/06/linux-sleep-usage/"/>
    <updated>2012-07-06T12:40:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/06/linux-sleep-usage</id>
    <content type="html"><![CDATA[<p><strong>应用程序</strong>：</p>

<pre><code>#include &lt;syswait.h&gt;
usleep(n) //n微秒
Sleep（n）//n毫秒
sleep（n）//n秒
</code></pre>

<!--more-->


<p><strong>驱动程序</strong>：</p>

<pre><code>#include &lt;linux/delay.h&gt;
mdelay(n) //milliseconds 其实现
</code></pre>

<p>```</p>

<h1>ifdef notdef</h1>

<h1>define mdelay(n) (\</h1>

<p>{unsigned long msec=(n); while (msec--) udelay(1000);})</p>

<h1>else</h1>

<h1>define mdelay(n) (\</h1>

<p>(__builtin_constant_p(n) &amp;&amp; (n)&lt;=MAX_UDELAY_MS) ? udelay((n)*1000) : \
({unsigned long msec=(n); while (msec--) udelay(1000);}))</p>

<h1>endif</h1>

<p>```
调用asm/delay.h的udelay,udelay应该是纳秒级的延时</p>

<p>dos:</p>

<pre><code>sleep(1); //停留1秒 
delay(100); //停留100毫秒   
</code></pre>

<p>Windows:</p>

<pre><code>Sleep(100); //停留100毫秒 
</code></pre>

<p>Linux:</p>

<pre><code>sleep(1); //停留1秒 
usleep(1000); //停留1毫秒 
</code></pre>

<p>每一个平台不太一样,最好自己定义一套跨平台的宏进行控制   <br/>
附：Linux下（使用的gcc的库），sleep()函数是以秒为单位的，sleep(1);就是休眠1秒。而MFC下的sleep()函数是以微秒为单位的，sleep(1000);才是休眠1秒。而如果在Linux下也用微妙为单位休眠，可以使用线程休眠函数:void usleep(unsigned long usec);当然，使用的时候别忘记#include &lt;system.h>哦。另外，linux下还有个delay()函数，原型为extern void delay(unsigned int msec);它可以延时msec*4毫秒，也就是如果想延时一秒钟的话，可以这么用 delay(250)。 <br/>
转载请注明出处：<a href="http://tinyxd.me/blog/2012/07/06/linux-sleep-usage/">http://tinyxd.me/blog/2012/07/06/linux-sleep-usage/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[中国大陆linux源镜像地址]]></title>
    <link href="http://tinyxd.me/blog/2012/07/05/linux-mirrors-china/"/>
    <updated>2012-07-05T09:39:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/05/linux-mirrors-china</id>
    <content type="html"><![CDATA[<p>1.企业 <br/>
搜狐开源镜像站：</p>

<pre><code>http://mirrors.sohu.com/
</code></pre>

<p>网易开源镜像站：</p>

<pre><code>http://mirrors.163.com/
</code></pre>

<p>2.大学 <br/>
西安电子科技大学：</p>

<pre><code>http://ftp.xdlinux.info/  (IPv4+IPv6)
ftp://linux.xidian.edu.cn/
</code></pre>

<p>中国科学技术大学：</p>

<pre><code>http://mirrors.ustc.edu.cn/ (IPv4+IPv6)
http://mirrors4.ustc.edu.cn/
http://mirrors6.ustc.edu.cn/
</code></pre>

<!--more-->


<p>上海交通大学：</p>

<pre><code>http://ftp.sjtu.edu.cn/ (IPv4 only)
http://ftp6.sjtu.edu.cn (IPv6 only)
</code></pre>

<p>清华大学：</p>

<pre><code>http://mirrors.tuna.tsinghua.edu.cn/ (IPv4+IPv6)
http://mirrors.6.tuna.tsinghua.edu.cn/ (IPv6 only)
http://mirrors.4.tuna.tsinghua.edu.cn/ (IPv4 only)
</code></pre>

<p>天津大学：</p>

<pre><code>http://mirror.tju.edu.cn/
</code></pre>

<p>西南大学：</p>

<pre><code>http://linux.swu.edu.cn/swudownload/Distributions/
</code></pre>

<p>东北大学：</p>

<pre><code>http://mirror.neu.edu.cn/ (IPv4 only)
http://mirror.neu6.edu.cn/ (IPv6 only)
</code></pre>

<p>电子科技大学：</p>

<pre><code>http://ubuntu.uestc.edu.cn/
</code></pre>

<p>青岛大学：</p>

<pre><code>http://mirror.qdu.edu.cn/
</code></pre>

<p>兰州大学：</p>

<pre><code>http://mirror.lzu.edu.cn/
</code></pre>

<p>厦门大学：</p>

<pre><code>http://mirrors.xmu.edu.cn/
</code></pre>

<p>北京理工大学：</p>

<pre><code>http://mirror.bit.edu.cn (IPv4 only)
http://mirror.bit6.edu.cn (IPv6 only)
</code></pre>

<p>北京交通大学：</p>

<pre><code>http://mirror.bjtu.edu.cn (IPv4 only)
http://mirror6.bjtu.edu.cn (IPv6 only)
http://debian.bjtu.edu.cn (IPv4+IPv6)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[让Debian支持ntfs文件系统读写]]></title>
    <link href="http://tinyxd.me/blog/2012/06/30/debian-ntfs-filesysterm/"/>
    <updated>2012-06-30T15:45:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/30/debian-ntfs-filesysterm</id>
    <content type="html"><![CDATA[<p>刚装好debian发现在debian下往windows盘下拷贝不过去资料，上网查了些资料发现是因为不知道ntfs的读写。 <br/>
查看我的版本号6.0.5</p>

<pre><code>#more /etc/debian_version   
6.0.5   
</code></pre>

<p>我的Debian系统: 6.0.5 <br/>
要是用的软件使用软件:ntfs-3g <br/>
1.修改默认源 <br/>
因为我们学校有自己的源，故而修改成我们学校的源，而后进行更新</p>

<pre><code>apt-get update   
</code></pre>

<!--more-->


<p>2.执行安装 <br/>
执行命令:</p>

<pre><code>apt-get install ntfs-3g   
</code></pre>

<p>3.使用 <br/>
直接使用执行命令:</p>

<pre><code>mount -t ntfs-3g /dev/hdax /mnt/windows   
</code></pre>

<p>这里的/dev/hdax 请改为你自己的windows磁盘分区，可利用fdisk -l 查看。  <br/>
如下： <br/>
``` <br/>
debian:/mnt# fdisk -l
Disk /dev/sda: 500.1 GB, 500107862016 bytes
255 heads, 63 sectors/track, 60801 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x559ed1e5</p>

<p>  Device Boot      Start         End      Blocks   Id  System
/dev/sda1               1        6528    52436128+   7  HPFS/NTFS
/dev/sda2            6529       60802   435949345+   f  W95 Ext'd (LBA)
/dev/sda5            6529       24543   144705456    7  HPFS/NTFS
/dev/sda6           24544       42558   144705456    7  HPFS/NTFS
/dev/sda7           42559       53060    84357283+   7  HPFS/NTFS
/dev/sda8           53061       53321     2096451    b  W95 FAT32
/dev/sda9   *       53322       53346      194560   83  Linux
/dev/sda10          53346       53589     1951744   82  Linux swap / Solaris
/dev/sda11          53589       55413    14647296   83  Linux
/dev/sda12          55413       60802    43287552   83  Linux <br/>
```</p>

<p>如果是加入开机自动映射的话，编辑/etc/fstab,加入如下内容就可以了。</p>

<pre><code>/dev/hdax /mnt/windows ntfs-3g defaults 0 0   
</code></pre>

<p>下面是我的系统加载NTFS文件系统的相关命令：</p>

<pre><code>mount -t ntfs-3g /dev/sda6 /mnt/D
mount -t ntfs-3g /dev/sda7 /mnt/E   
</code></pre>

<p>以上文章是对网上搜集的资料的整理。如需转载请注明出处，本文地址： <br/>
<code>http://tinyxd.me/blog/2012/06/30/debian-ntfs-filesysterm/</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[debian安装nvidia显卡驱动]]></title>
    <link href="http://tinyxd.me/blog/2012/06/18/debianan-zhuang-nvidiaxian-qia-qu-dong/"/>
    <updated>2012-06-18T20:31:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/18/debianan-zhuang-nvidiaxian-qia-qu-dong</id>
    <content type="html"><![CDATA[<p>在自己的电脑上硬盘安装了Debian.下面介绍一下我是如何安装显卡驱动的.我的显卡是GForce 7100GS的.</p>

<p>1>下载显卡驱动.</p>

<p>这个可以到Nvidia的官网上去找,找到自己对应的版本就可以了。</p>

<p>2>安装gcc并设置版本.</p>

<p>#apt-get install gcc 这样安装的是gcc-4.4,如果在安装过程中提示您安装的gcc版本有问题,你可以再安装一下gcc-4.3并将gcc版本设置为4.3,具体做法:</p>

<p>#apt-get install gcc-4.3</p>

<p>#ln -sf /usr/bin/gcc-4.3 /usr/bin/gcc 这一句用来将gcc的版本设置为4.3</p>

<p>#ls -l /usr/bin/gcc* 这一句用来查看当前使用的gcc版本</p>

<!--more-->


<p>3>安装make</p>

<p>#apt-get install make</p>

<p>4>安装编译头文件</p>

<p>#apt-get install build-essential linux-headers-$(uname -r)</p>

<p>5>编辑 /boot/gurb/grub.cfg</p>

<p>在linux /vmlinuz -2.6.32-5.........quite 后面加上 nomodeset  (作用是将原来普适的显卡驱动禁用)</p>

<p>6>进入字符界面 Ctrl+Alt+F1</p>

<p>7>停用X-Server:</p>

<p>#/etc/init.d/gdm3 stop</p>

<p>8>安装显卡驱动:</p>

<p> # sh .... (省略号部分为你下载的显卡驱动的名称) 你将会看到安装的进度条.</p>

<p>9>#startx</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[嵌入式linux应用程序自启动]]></title>
    <link href="http://tinyxd.me/blog/2012/06/10/qian-ru-shi-linuxying-yong-cheng-xu-zi-qi-dong/"/>
    <updated>2012-06-10T19:46:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/10/qian-ru-shi-linuxying-yong-cheng-xu-zi-qi-dong</id>
    <content type="html"><![CDATA[<p>在很多嵌入式系统中，由于可用资源较少，常常在系统启动后就直接让应用程序自动启动，以减少用户操作和节省资源。如何让自己的应用程序自动启动呢？    在Linux系统中，配置应用程序自动启动的方法有以下三种：</p>

<!--more-->


<h2>1.通过/Linuxrc脚本直接启动</h2>

<p>Linux内核一旦开始执行，它将通过驱动程序来初始化所有硬件设备，这个初始化过程可以在启动时的PC显示器上看到，每个驱动程序都打印一些相关信息。初始化完成后，通常调用的是init，通过loader调用init内的init=/app_program语句（通过loader向核心传入init=/program可以定制首先运行的程序）。 <br/>
比如在桌面Linux系统中，init进程会读取/etc/inittab文件，来决定执行级别和哪些脚本和命令。嵌入式应用开发中，可以根据实际情况决定是否使用标准的init执行方式，也许这个init是个静态程序，它能够完成我们的嵌入应用的特定任务，那完全不用考虑inittab了，在这里可以采用比较灵活的措施。</p>

<h2>2.在/etc/init.d下添加启动脚本</h2>

<p>一般情况下，大多数的Linux操作系统使用/etc/init.d/(或/etc/rc.d/init.d)下的脚本来配置应用程序的自动启动。 <br/>
例如，在某些Linux系统中，corn程序通过/etc/init.d/corn脚本启动，Apache通过/etc/init.d/httpd启动，syslogd通过/etc/init.d/syslogd启动，而sshd则通过/etc/init.d/sshd脚本启动。 <br/>
通常这些脚本通过来自特定rc.d目录的符号链接运行。为了配置从哪个rc.d目录运行脚本，Linux系统提供了许多不同的工具，同时也可以手工进行配置。Linux系统有一个包含所有实际启动脚本文件的目录。它可能是/etc/init.d，也可能是/etc/rc.d/rc.d。同时对应每个运行级别（runlevel）又有一个另外的目录，它们可能是/etc/rc2.d，也可能是/etc/rc.d/rc2.d。这些目录中的文件通常是指向实际脚本文件的符号链接。</p>

<h2>3.直接在/etc/rc.d/rc.local脚本中添加命令</h2>

<p>在Linux系统中，有一个类似Windows系统中autoexec.bat的文件，它就是/etc/rc.d/rc.local，系统开机后自动运行用户的应用程序或启动系统服务的命令保存在开发板根文件系统的这个文件中。因此可以编辑rc.local文件，将要执行的程序（命令）添加到该文件夹中。Linux系统在启动后还未登录前，将自动执行该程序（命令），达到开机自动运行用户的应用程序的目的。 <br/>
下面具体说明：  <br/>
首先解压ramdisk.image.gz文件，然后挂载到系统中。接着创建自己的应用程序文件夹hello，将所要自动运行的应用程序hello复制到该文件夹。 <br/>
然后打开/usr/etc/rc.local文件，在最后一行加入：/Myapp/hello/hello <br/>
再按上面的顺序将ramdisk.image打包下载到目标板，启动运行，则可以看到用户编写的应用程序一启动就运行起来了。 <br/>
本文参考《基于ARM9的嵌入式Linux开发技术》，李新峰等编著。</p>
]]></content>
  </entry>
  
</feed>
