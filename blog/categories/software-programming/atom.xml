<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Software programming | Keen on Art of Tech]]></title>
  <link href="http://tinyxd.me/blog/categories/software-programming/atom.xml" rel="self"/>
  <link href="http://tinyxd.me/"/>
  <updated>2012-06-21T07:14:28+08:00</updated>
  <id>http://tinyxd.me/</id>
  <author>
    <name><![CDATA[Tiny]]></name>
    <email><![CDATA[admin@tinyxd.me]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[用new申请动态空间的问题]]></title>
    <link href="http://tinyxd.me/blog/2012/06/14/yong-newshen-qing-dong-tai-kong-jian-de-wen-ti/"/>
    <updated>2012-06-14T07:27:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/14/yong-newshen-qing-dong-tai-kong-jian-de-wen-ti</id>
    <content type="html"><![CDATA[<p>先分析一下new的分配：</p>

<p>1.T*   p   =   new   T;  ···   delete   p;
等价于
T*   p   =   new   T[1]; ··· delete[]   p;</p>

<p>2.int   (*p)[n]   =   new   int[m][n];这种方式是可行的</p>

<p>3.所以new一个3x3的数组，也就是T   =   int[3][3] ，  那么可以这样写：
int   (*p)[3][3]   =   new   int[1][3][3];     删除时请调用delete[]   p;</p>

<!--more-->


<p>4.int** a；很容易造成内存泄漏最好不要用。</p>

<p>下面是自己写的一个test：
``` c++</p>

<h1>include <iostream></h1>

<p>using namespace std;
int main()</p>

<p>{</p>

<pre><code>size_t m=10;
int (*p)[10]=new int[m][10]();
for(size_t i=0;i!=10;++i)
    for(size_t j=0;j!=10;++j)
    {
        cout&lt;&lt; p[i]+j &lt;&lt;endl;

    }
cout&lt;&lt;sizeof(p)&lt;&lt;endl;
delete  [] p;
return 0;
</code></pre>

<p>}
```</p>

<p>还有一个问题是 ，c++中new的空间地址是连续的么？？</p>

<p>由于学习过linux内核，经过分析，有些时候是虚拟地址是连续的，而物理地址是不连续的。由于在内核中需要申请连续的物理地址空间的时候，使用类似kmalloc（）的函数，这样的话，如果size比较小的话，申请成功的概率还算高（尤其是刚开机不久），而申请大内存的话就有可能申请失败。申请虚拟地址的时候用vmalloc（），这个只能确保在虚拟地址上是连续的，而不能保证在物理地址是连续的，但是这个可以申请比较大的空间。</p>

<p>而看到网上说不同的操作系统会有不同的内存管理机制，而至于windows是咋样的，还需要进一步查找资料。</p>

<p>下面是转载的如何申请连续的地址空间（c++）（http://blog.csdn.net/zhongshengjun/article/details/4632156）：</p>

<blockquote><p>   地址连续的二维数组在C语言数值计算中有重要意义，很多二维数组的算法是基于一维数组写的。另外，在序列化时或内存复制时，连续空间易于进行整块内存的操作。</p>

<p>   子程序说明：</p>

<p>   1- Array2D和FreeArray2D可实现地址连续的动态二维数组的地址分配和释放。</p>

<p>  2- 作为对照，下面给出了地址不连续的二维数组地址分配与释放的子程序。</p>

<p>``` c++</p>

<pre><code>// 创建 n X m 的动态数组，该数组的元素地址在内存中是连续的
// n - 输入参数，数组的行数
// m - 输入参数，数组的列数
// 返回，double **，指向指针的指针，用于以二维数组的方式访问一段内存。
double **Array2D(int n,int m)
{
 // 建立数组的存储区，即在内存中分配一片连续的空间，元素个数为 n*m，
 // 返回指向double的指针。
    double *Array1D=new double[n*m];
 // 建立数组的索引区，返回指向 double *的指针（指向指针的指针），长度为 n。
    double **Array2D=new double* [n];
 // 将索引区的每个元素指向数据存储区对应元素的地址，Array2D[0] 指向 Array1D[0]，
 // Array2D[1] 指向 Array1D[m]，其余类推。
    for(int i=0;i&lt;n;i++)
    {
     Array2D[i]=&amp;Array1D[i*m];
    }
    return Array2D;
}
</code></pre></blockquote>

<pre><code>// 释放数组的空间，首先释放一维数组占用的n*m个double空间
// 再释放索引数组（指针数组）占用的n个double*空间
 void FreeArray2D(double **Array2D)
{
  delete[] Array2D[0];
  delete[] Array2D;
}

// 二维数组空间分配，地址一般不连续，不是推荐的方法
 double **Array2D_A(int n,int m)
{
 // 建立数组的索引区，返回指向 double *的指针（指向指针的指针），长度为 n。
    double **Array2D=new double* [n];

 // 建立数组的存储区，对于Array2D的每一个指针元素，分配m个double空间
    for(int i=0;i&lt;n;i++)
     Array2D[i]=new double[m];

    return Array2D;
}

// 释放数组的空间，与Array2D_A配套使用

// 首先释放n个一维数组（每个占用m个double空间）
// 再释放索引数组（指针数组）占用的n个double*空间
 void FreeArray2D_A(double **Array2D,int n)
{
    for(int i=0;i&lt;n;i++)
    delete[] Array2D[i];
  delete[] Array2D;
}
</code></pre>

<p>```</p>

<blockquote></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[函数压栈的一些思考]]></title>
    <link href="http://tinyxd.me/blog/2012/06/13/han-shu-ya-zhan/"/>
    <updated>2012-06-13T07:22:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/13/han-shu-ya-zhan</id>
    <content type="html"><![CDATA[<p>今天，有个同学跑过来问我一个问题fun（i，i++，++i），我立马想到这个是跟函数压栈的顺序有关的，随后去网上查找资料，并开始写了一些测试实验。</p>

<p>先把cu上的一个解释先贴上来：</p>

<p>函数调用约定（Calling Convention）</p>

<!--more-->


<p>函数调用约定不仅决定了发生函数调用时函数参数的入栈顺序，还决定了是由调用者函数还是被调用函数负责清除栈中的参数，还原堆栈。函数调用约定有很多方 式，除了常见的__cdecl，__fastcall和__stdcall之外，C++的编译器还支持thiscall方式，不少C/C++编译器还支持 naked call方式。这么多函数调用约定常常令许多程序员很迷惑，到底它们是怎么回事，都是在什么情况下使用呢？下面就分别介绍这几种函数调用约定。</p>

<blockquote><p> <strong>1、__stdcall调用约定</strong> <br/>
  相当于16位动态库中经常使用的PASCAL调用约定。在32位的VC++5.0中PASCAL调用约定不再被支持（实际上它已被定义为__stdcall。除了__pascal外，__fortran和__syscall也不被支持），取而代之的是__stdcall调用约定。两者实质上是一致的，即函数的参数自右向左通过栈传递，被调用的函数在返回前清理传送参数的内存栈，但不同的是函数名的修饰部分（关于函数名的修饰部分在后面将详细说明）。 <em>stdcall是Pascal程序的缺省调用方式，通常用于Win32   Api中，函数采用从右到左的压栈方式，自己在退出时清空堆栈。VC将函数编译后会在函数名前面加上下划线前缀，在函数名后加上 "@ "和参数的字节数。 <br/>
 <strong>2、C调用约定</strong> <br/>
  （即用__cdecl关键字说明）按从右至左的顺序压参数入栈，由调用者把参数弹出栈。对于传送参数的内存栈是由调用者来维护的（正因为如此，实现可变参数的函数只能使用该调用约定）。另外，在函数名修饰约定方面也有所不同。
 </em>cdecl是C和C＋＋程序的缺省调用方式。每一个调用它的函数都包含清空堆栈的代码，所以产生的可执行文件大小会比调用<em>stdcall函数的大。函数采用从右到左的压栈方式。VC将函数编译后会在函数名前面加上下划线前缀。是MFC缺省调用约定。 <br/>
<strong>3、__fastcall调用约定</strong> <br/>
  是 "人 "如其名，它的主要特点就是快，因为它是通过寄存器来传送参数的（实际上，它用ECX和EDX传送前两个双字（DWORD）或更小的参数，剩下的参数仍旧自右向左压栈传送，被调用的函数在返回前清理传送参数的内存栈），在函数名修饰约定方面，它和前两者均不同。
 </em>fastcall方式的函数采用寄存器传递参数，VC将函数编译后会在函数名前面加上 "@ "前缀，在函数名后加上 "@ "和参数的字节数。 <br/>
<strong>4、thiscall</strong> <br/>
  仅仅应用于 "C++ "成员函数。this指针存放于CX寄存器，参数从右到左压。thiscall不是关键词，因此不能被程序员指定。 <br/>
 <strong>5、naked   call</strong> <br/>
  采用1-4的调用约定时，如果必要的话，进入函数时编译器会产生代码来保存ESI，EDI，EBX，EBP寄存器，退出函数时则产生代码恢复这些寄存器的内容。
naked   call不产生这样的代码。naked   call不是类型修饰符，故必须和_declspec共同使用。
关键字__stdcall __cdecl和 __fastcall可以直接加在要输出的函数前，也可以在编译环境的Setting...\C/C++   \Code   Generation项选择。当加在输出函数前的关键字与编译环境中的选择不同时，直接加在输出函数前的关键字有效。它们对应的命令行参数分别为/Gz、/Gd和/Gr。缺省状态为/Gd，即__cdecl。
要完全模仿PASCAL调用约定首先必须使用__stdcall调用约定，至于函数名修饰约定，可以通过其它方法模仿。还有一个值得一提的是WINAPI宏，Windows.h支持该宏，它可以将出函数翻译成适当的调用约定，在WIN32中，它被定义为__stdcall。使用WINAPI宏可以创建自己的APIs 。</p>

<p>VC的编译环境默认是使用__cdecl调用约定，也可以在编译环境的Project Setting...菜单－》C/C++ ＝》Code    Generation项选择设置函数调用约定。也可以直接在函数声明前添加关键字__stdcall、__cdecl或__fastcall等单独确定函 数的调用方式。在Windows系统上开发软件常用到WINAPI宏，它可以根据编译设置翻译成适当的函数调用约定，在WIN32中，它被定义为 __stdcall。</p></blockquote>

<p>下面是华为某年的一个考题，</p>

<p>设
``` c
int arr[]={6,7,8,9,10};</p>

<p>int *ptr=arr;</p>

<p>*(ptr++)+=123;</p>

<p>printf(＂%d,%d＂,<em>ptr,</em>(++ptr));</p>

<p><code>
答案为什么是：8，8
</code> c</p>

<p>int arr[]={6,7,8,9,10};</p>

<p>int *ptr=arr;//现在ptr指向6</p>

<p>*(ptr++)+=123;//现在ptr指向7,第一个元素变为129</p>

<p>printf(＂%d,%d＂,<em>ptr,</em>(++ptr)); //考虑从右往左计算，先是<em>(++ptr)，现在ptr指向8，然后</em>ptr也是8，输出8，8
```</p>

<p>嗯 虽然这样解释似乎有些道理，但是有人认为这是和编译器相关的，即，求值顺序是不定的。。也有可能出现7，8的结果。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读C++ Primer 之句柄类]]></title>
    <link href="http://tinyxd.me/blog/2012/06/08/c-plus-plus-ju-bing-lei/"/>
    <updated>2012-06-08T20:28:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/08/c-plus-plus-ju-bing-lei</id>
    <content type="html"><![CDATA[<p>转自Linux社区 作者：xizero00：http://www.linuxidc.com/Linux/2011-08/40175.htm</p>

<p>我们知道C++中最令人头疼的当属指针，如果您申请了对象却没有释放它，时间一长就会造成系统崩溃，大量的内存溢出使得您的程序的健壮性出现问题</p>

<p>而句柄类就是为了能够解决这一问题而出现的，句柄类有点类似于智能指针。</p>

<p>好了，废话不多说，我们来看代码</p>

<!--more-->


<p>首先我们来看 sample.h文件的代码：
``` c++
/<em>
* author:xizero00
* mail:xizero00@163.com
* date:2011-08-07 20:11:24
* Handle Class Sample  句柄类示例
</em>/</p>

<h1>ifndef SAMPLE_H</h1>

<h1>define SAMPLE_H</h1>

<h1>include <iostream></h1>

<h1>include <stdexcept></h1>

<p>using namespace std;</p>

<p>//基类
class Item_base
{
public:</p>

<pre><code>//基类的虚函数,用于智能地复制对象
virtual Item_base* clone() const
{
    return new Item_base( *this );
}
</code></pre>

<p>};</p>

<p>//子类
class Bulk_item: public Item_base
{</p>

<pre><code>//子类的虚函数的重载,用于智能地复制对象
virtual Bulk_item* clone() const
{
    return new Bulk_item( *this );
}
</code></pre>

<p>};</p>

<p>//子类的子类
class Sales_item: public Bulk_item
{
public:</p>

<pre><code>//默认构造函数,用来初始化一个引用计数器
Sales_item(): p( 0 ) , use( new size_t( 1 ) ) { cout &lt;&lt; "Sales_item的引用计数器初始化为1" &lt;&lt; endl; }  

//带有一个参数的,且该参数为基类引用的构造函数
Sales_item( const Item_base&amp; );  

//复制构造函数,需要注意的是，每复制一次就需要增加引用计数一次
Sales_item( const Sales_item &amp;i ): p( i.p ) , use( i.use ) { ++*use; cout &lt;&lt; "由于采用了复制构造函数,Sales_item类型的对象引用计数为:" &lt;&lt; *use &lt;&lt; endl;} //也可以这样写
//Sales_item( const Sales_item &amp;i ): p( i.clone() ) , use( new size_t( 1 ) ) { ++*use; }   

//析构函数,析构的时候会判断是否能够释放指针所指向的数据
~Sales_item() { cout &lt;&lt; "在析构函数中:"; decr_use(); }  

//赋值操作符重载
Sales_item&amp; operator= ( const Sales_item&amp; );  

//访问操作符重载
const Item_base* operator-&gt; () const
{
    if( p )
    {
        return p;
    }
    else
    {
        throw logic_error( "p指针错误" );
    }
}  

//解引用操作符重载
const Item_base&amp; operator* () const
{
    if( p )
    {
        return *p;
    }
    else
    {//重载虚函数,用于智能地复制对象
        throw logic_error( "p指针错误" );
    }
}  

//重载虚函数,用于智能地复制对象
/*
virtual Sales_item* clone() const
{
    return new Sales_item( *this );
}
*/  
</code></pre>

<p>private:</p>

<pre><code>//两个指针存储着引用计数器以及数据的指针
Item_base *p;
size_t *use;  

//减少引用
void decr_use()
{
    cout &lt;&lt; "在 dec_use函数中引用计数减少了,当前计数值为:" &lt;&lt; *use - 1 &lt;&lt; endl;
    if( --*use == 0 )
    {
        delete p;
        delete use;
        cout &lt;&lt; "在 dec_use函数中计数器减为0,释放对象" &lt;&lt; endl;
    }  

}
</code></pre>

<p>};</p>

<p>//赋值操作符重载,每次复制都会增加引用计数
Sales_item&amp; Sales_item::operator= ( const Sales_item &amp;si )
{</p>

<pre><code>cout &lt;&lt; "由于采用类赋值操作,";
cout &lt;&lt; "被赋值的对象的引用计数为:" &lt;&lt; *si.use ;
cout &lt;&lt; "即将被赋值的对象的引用计数为:" &lt;&lt; *use &lt;&lt; endl;
//这里需要特别注意的就是待复制的对象的计数器需要加1而被赋值的对象需要减1     

//增加被复制对象的引用计数
++*si.use;
cout &lt;&lt; "被赋值的对象的赋值之后的引用计数为:" &lt;&lt; *si.use &lt;&lt; endl;
//将即将被赋值的对象的引用计数减1
decr_use();
cout &lt;&lt; " 即将被赋值的对象赋值之后的引用计数为:" &lt;&lt; *use &lt;&lt; endl;  

//复制指针
p = si.p;
use = si.use;  

//返回
return *this;
</code></pre>

<p>}</p>

<h1>endif //SAMPLE_H</h1>

<p>接下来我们来看sample.cc的代码：</p>

<p>/<em>
* author:xizero00
* mail:xizero00@163.com
* date:2011-08-07 20:11:24
</em>/</p>

<h1>include "sample.h"</h1>

<p>int main( int argc , char **argv )
{</p>

<pre><code>//重点关注i1和i2的引用计数
Sales_item i1 , i2;//i1和i2的引用计数分别为1
Sales_item i3( i1 );//i1的引用计数变为2
Sales_item i4 = i1;//i1的引用计数变为3,因为这样还是调用的复制构造函数
i4 = i2; // i2的引用计数变为2   

return 0;
</code></pre>

<p>}
<code>
下面给出编译所需的Makefile
</code></p>

<h1>author:xizero00</h1>

<h1>mail:xizero00@163.com</h1>

<h1>date:2011-08-08 00:51:25</h1>

<p>install:</p>

<pre><code>g++ sample.cc -g -o sample
ls -al sample*
./sample
</code></pre>

<p>clean:</p>

<pre><code>rm -f sample
ls -al sample*
</code></pre>

<p>```
注意：代码是在linux下编译，您只需要将三个文件放在同一个目录，然后在当前目录打开终端，输入make，就可以查看到结果。</p>

<p>如果您想清理生成的文件 输入make clean即可</p>

<p>下面是我执行的结果：</p>

<pre><code>Sales_item的引用计数器初始化为1
Sales_item的引用计数器初始化为1
由于采用了复制构造函数,Sales_item类型的对象引用计数为:2
由于采用了复制构造函数,Sales_item类型的对象引用计数为:3
由于采用类赋值操作,被赋值的对象的引用计数为:1即将被赋值的对象的引用计数为:3
被赋值的对象的赋值之后的引用计数为:2
在 dec_use函数中引用计数减少了,当前计数值为:2
 即将被赋值的对象赋值之后的引用计数为:2
在析构函数中:在 dec_use函数中引用计数减少了,当前计数值为:1
在析构函数中:在 dec_use函数中引用计数减少了,当前计数值为:1
在析构函数中:在 dec_use函数中引用计数减少了,当前计数值为:0
在 dec_use函数中计数器减为0,释放对象
在析构函数中:在 dec_use函数中引用计数减少了,当前计数值为:0
在 dec_use函数中计数器减为0,释放对象
</code></pre>

<p>结论：我们可以看到，句柄类能够很方便并且能够很安全地释放内存，不会导致内存的泄露。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[堆和栈的区别]]></title>
    <link href="http://tinyxd.me/blog/2012/06/08/dui-he-zhan-de-qu-bie/"/>
    <updated>2012-06-08T06:59:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/08/dui-he-zhan-de-qu-bie</id>
    <content type="html"><![CDATA[<p>出自: http://www.cnitexam.com <br/>
一、预备知识—程序的内存分配</p>

<p>一个由c/C++编译的程序占用的内存分为以下几个部分</p>

<p>1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p>

<p>2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。</p>

<p>3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 – 程序结束后有系统释放</p>

<p>4、文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放</p>

<p>5、程序代码区—存放函数体的二进制代码。</p>

<!--more-->


<p>二、例子程序</p>

<p>这是一个前辈写的，非常详细</p>

<p>``` c
//main.cpp</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;string.h></h1>

<p>int a = 0;// 全局初始化区</p>

<p>char *p1;// 全局未初始化区</p>

<p>main()</p>

<p>{</p>

<p>int b;// 栈</p>

<p>char s[] = "abc"; //栈</p>

<p>char *p2;// 栈</p>

<p>char *p3 = "123456"; //123456\0在常量区，p3在栈上。</p>

<p>static int c =0；// 全局（静态）初始化区</p>

<p>p1 = (char *)malloc(10);</p>

<p>p2 = (char *)malloc(20);//分配得来得10和20字节的区域就在堆区。</p>

<p>strcpy(p1, "123456"); //123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。</p>

<p>}
```
二、堆和栈的理论知识</p>

<p>2.1申请方式</p>

<p>stack:</p>

<p>由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间</p>

<p>heap:</p>

<p>需要程序员自己申请，并指明大小，在c中malloc函数</p>

<p>如p1 = (char *)malloc(10);</p>

<p>在C++中用new运算符</p>

<p>如char *p2 =new char[10];</p>

<p>但是注意p1、p2本身是在栈中的。</p>

<p>2.2 申请后系统的响应</p>

<p>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p>

<p>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，</p>

<p>会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</p>

<p>2.3申请大小的限制</p>

<p>栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</p>

<p>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p>

<p>2.4申请效率的比较：</p>

<p>栈由系统自动分配，速度较快。但程序员是无法控制的。</p>

<p>堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.</p>

<p>另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活</p>

<p>2.5堆和栈中的存储内容</p>

<p>栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。</p>

<p>当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</p>

<p>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。</p>

<p>2.6存取效率的比较</p>

<p>char s1[] = “aaaaaaaaaaaaaaa”;</p>

<p>char *s2 = “bbbbbbbbbbbbbbbbb”;</p>

<p>aaaaaaaaaaa是在运行时刻赋值的；</p>

<p>而bbbbbbbbbbb是在编译时就确定的；</p>

<p>但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。</p>

<p>比如：
``` c</p>

<h1>include &lt;stdlib.h></h1>

<p>void main()</p>

<p>{</p>

<p>char a = 1;</p>

<p>char c[] = "1234567890";</p>

<p>char *p ="1234567890";</p>

<p>a = c[1];</p>

<p>a = p[1];</p>

<p>return;</p>

<p>}
```
对应的汇编代码</p>

<p>10: a = c[1];</p>

<p>004010678A4D F1 mov cl,byte ptr [ebp-0Fh]</p>

<p>0040106A88 4D FC mov byte ptr [ebp-4],cl</p>

<p>11: a = p[1];</p>

<p>0040106D 8B 55 EC mov edx,dword ptr [ebp-14h]</p>

<p>004010708A42 01 mov al,byte ptr [edx+1]</p>

<p>00401073 88 45 FC mov byte ptr [ebp-4],al</p>

<p>第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，在根据edx读取字符，显然慢了。</p>

<p>2.7小结：</p>

<p>堆和栈的区别可以用如下的比喻来看出：</p>

<p>使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。</p>

<p>使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。</p>

<p>堆和栈的区别主要分：</p>

<p>操作系统方面的堆和栈，如上面说的那些，不多说了。</p>

<p>还有就是数据结构方面的堆和栈，这些都是不同的概念。这里的堆实际上指的就是（满足堆性质的）优先队列的一种数据结构，第1个元素有最高的优先权；栈实际上就是满足先进后出的性质的数学或数据结构。</p>

<p>虽然堆栈，堆栈的说法是连起来叫，但是他们还是有很大区别的，连着叫只是由于历史的原因。</p>
]]></content>
  </entry>
  
</feed>
