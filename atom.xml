<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Keen on Art of Tech]]></title>
  <link href="http://tinyxd.me/atom.xml" rel="self"/>
  <link href="http://tinyxd.me/"/>
  <updated>2012-06-25T07:38:09+08:00</updated>
  <id>http://tinyxd.me/</id>
  <author>
    <name><![CDATA[Tiny]]></name>
    <email><![CDATA[admin@tinyxd.me]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[octopress博客添加标签云]]></title>
    <link href="http://tinyxd.me/blog/2012/06/25/octopress-add-tag-cloud/"/>
    <updated>2012-06-25T00:35:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/25/octopress-add-tag-cloud</id>
    <content type="html"><![CDATA[<p>折腾了好久，终于弄好了。我基本是follow这篇文章的：<a href="http://log4d.com/2012/05/tag-cloud/">给 Octopress 加上标签功能</a> <br/>
官方只提供了category的云显示，和列表显示，这是其<a href="https://github.com/tokkonopapa/octopress-tagcloud">github地址</a>，其实官方提供的这个第三方插件并没有给文章加入tag的概念。（category和tag分别代表日志分类和标签）</p>

<!--more-->


<p>
现在我还对ruby不是很熟悉，但是看到了<a href="http://log4d.com/2012/05/tag-cloud/">这篇文章</a>，找到了<a href="https://github.com/robbyedwards/octopress-tag-pages">robbyedwards / octopress-tag-pages</a>和<a href="https://github.com/robbyedwards/octopress-tag-cloud">robbyedwards / octopress-tag-cloud</a>。前者采集文章的tag，后者是标签云的显示。 <br/>
这两个使用方法相同，把文件放到相应的目录即可。而第二个插件<code>octopress-tag-cloud</code> 会和官方的有冲突，直接用<a href="https://github.com/alswl/octopress-category-list">这个</a>就好。 <br/>
还有最后一点非常重要，得修改两个地方： <br/>
一个是sass/custom/_styles.scss</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#content article .cloud li{
</span><span class='line'>  display: inline;
</span><span class='line'>  list-style: none outside none;
</span><span class='line'>  padding: 0 4px;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>然后把显示tagcloud的页面 class改为cloud(class=&#8221;cloud&#8221;)。 <br/>
大功告成，tag cloud页面请点击<a href="http://tinyxd.me/tags/index.html">这里</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给octopress添加关键字和网站描述]]></title>
    <link href="http://tinyxd.me/blog/2012/06/19/seo-meta-octopress/"/>
    <updated>2012-06-19T21:10:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/19/seo-meta-octopress</id>
    <content type="html"><![CDATA[<p>给octopress添加keywords和description。</p>

<p>1.修改source / _includes / head.html</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;meta name="author" content="Tiny"&gt;
</span><span class='line'>
</span><span class='line'>&lt;meta name="description" content="How to optimize Octopress for SEO"&gt;
</span><span class='line'>&lt;meta name="keywords" content="octopress, meta,seo"&gt;</span></code></pre></td></tr></table></div></figure>


<p>2.在_config.yml中添加如下内容</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>description: Keen on the software programming and Embedded development.（专注软件编程及嵌入式技术。）
</span><span class='line'>keywords: ruby , linux , archlinux , debian , software ,programming , embedded ,gem,web development ,ubuntu , java</span></code></pre></td></tr></table></div></figure>


<p>3.这样在主页代码中也会出现keywords和description信息。每个post也会出现。方便被搜索网站索引。这个涉及到了SEO优化。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[php初学]]></title>
    <link href="http://tinyxd.me/blog/2012/06/19/learn-php/"/>
    <updated>2012-06-19T20:28:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/19/learn-php</id>
    <content type="html"><![CDATA[<p>1.搭建学习环境 采用简单的打包好的：lamp. <br/>
<a href="https://help.ubuntu.com/community/ApacheMySQLPHP#Run.2C_Stop.2C_Test.2C_And_Restart_Apache">help web sites</a></p>

<p>2.PHP中文手册 <br/>
http://www.phpchina.com/resource/manual/phpnew/</p>

<!--more-->


<p>example： <br/>
第一个 PHP 脚本：hello.php</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="x">&lt;html&gt;</span>
</span><span class='line'><span class="x"> &lt;head&gt;</span>
</span><span class='line'><span class="x">  &lt;title&gt;PHP 测试&lt;/title&gt;</span>
</span><span class='line'><span class="x"> &lt;/head&gt;</span>
</span><span class='line'><span class="x"> &lt;body&gt;</span>
</span><span class='line'><span class="x"> </span><span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="s1">&#39;&lt;p&gt;Hello World</span>
</span><span class='line'><span class="s1">&#39;</span><span class="p">;</span> <span class="cp">?&gt;</span><span class="x"></span>
</span><span class='line'><span class="x"> &lt;/body&gt;</span>
</span><span class='line'><span class="x">&lt;/html&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>PHP基本语法：</p>

<p>四种标量类型：</p>

<ul>
<li> boolean （布尔型）</li>
<li> integer （整型）</li>
<li> float （浮点型, 也称作 double)</li>
<li> string （字符串）</li>
</ul>


<p>两种复合类型：</p>

<ul>
<li> array （数组）</li>
<li> object （对象）</li>
</ul>


<p>最后是两种特殊类型：</p>

<ul>
<li> resource　（资源）</li>
<li> NULL　（NULL）</li>
</ul>


<p>为了确保代码的易读性，本手册还介绍了一些伪类型：</p>

<ul>
<li> mixed</li>
<li> number</li>
<li> callback</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[debian安装nvidia显卡驱动]]></title>
    <link href="http://tinyxd.me/blog/2012/06/18/debianan-zhuang-nvidiaxian-qia-qu-dong/"/>
    <updated>2012-06-18T20:31:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/18/debianan-zhuang-nvidiaxian-qia-qu-dong</id>
    <content type="html"><![CDATA[<p>在自己的电脑上硬盘安装了Debian.下面介绍一下我是如何安装显卡驱动的.我的显卡是GForce 7100GS的.</p>

<p>1>下载显卡驱动.</p>

<p>这个可以到Nvidia的官网上去找,找到自己对应的版本就可以了。</p>

<p>2>安装gcc并设置版本.</p>

<p>#apt-get install gcc 这样安装的是gcc-4.4,如果在安装过程中提示您安装的gcc版本有问题,你可以再安装一下gcc-4.3并将gcc版本设置为4.3,具体做法:</p>

<p>#apt-get install gcc-4.3</p>

<p>#ln -sf /usr/bin/gcc-4.3 /usr/bin/gcc 这一句用来将gcc的版本设置为4.3</p>

<p>#ls -l /usr/bin/gcc* 这一句用来查看当前使用的gcc版本</p>

<!--more-->


<p>3>安装make</p>

<p>#apt-get install make</p>

<p>4>安装编译头文件</p>

<p>#apt-get install build-essential linux-headers-$(uname -r)</p>

<p>5>编辑 /boot/gurb/grub.cfg</p>

<p>在linux /vmlinuz -2.6.32-5&#8230;&#8230;&#8230;quite 后面加上 nomodeset  (作用是将原来普适的显卡驱动禁用)</p>

<p>6>进入字符界面 Ctrl+Alt+F1</p>

<p>7>停用X-Server:</p>

<p>#/etc/init.d/gdm3 stop</p>

<p>8>安装显卡驱动:</p>

<p> # sh &#8230;. (省略号部分为你下载的显卡驱动的名称) 你将会看到安装的进度条.</p>

<p>9>#startx</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用new申请动态空间的问题]]></title>
    <link href="http://tinyxd.me/blog/2012/06/14/yong-newshen-qing-dong-tai-kong-jian-de-wen-ti/"/>
    <updated>2012-06-14T07:27:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/14/yong-newshen-qing-dong-tai-kong-jian-de-wen-ti</id>
    <content type="html"><![CDATA[<p>先分析一下new的分配：</p>

<p>1.T*   p   =   new   T;  ···   delete   p;
等价于
T*   p   =   new   T[1]; ··· delete[]   p;</p>

<p>2.int   (*p)[n]   =   new   int[m][n];这种方式是可行的</p>

<p>3.所以new一个3x3的数组，也就是T   =   int[3][3] ，  那么可以这样写：
int   (*p)[3][3]   =   new   int[1][3][3];     删除时请调用delete[]   p;</p>

<!--more-->


<p>4.int** a；很容易造成内存泄漏最好不要用。</p>

<p>下面是自己写的一个test：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">size_t</span> <span class="n">m</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="mi">10</span><span class="p">]();</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="n">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">!=</span><span class="mi">10</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>      <span class="k">for</span><span class="p">(</span><span class="n">size_t</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">!=</span><span class="mi">10</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>          <span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">j</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="k">delete</span>  <span class="p">[]</span> <span class="n">p</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>还有一个问题是 ，c++中new的空间地址是连续的么？？</p>

<p>由于学习过linux内核，经过分析，有些时候是虚拟地址是连续的，而物理地址是不连续的。由于在内核中需要申请连续的物理地址空间的时候，使用类似kmalloc（）的函数，这样的话，如果size比较小的话，申请成功的概率还算高（尤其是刚开机不久），而申请大内存的话就有可能申请失败。申请虚拟地址的时候用vmalloc（），这个只能确保在虚拟地址上是连续的，而不能保证在物理地址是连续的，但是这个可以申请比较大的空间。</p>

<p>而看到网上说不同的操作系统会有不同的内存管理机制，而至于windows是咋样的，还需要进一步查找资料。</p>

<p>下面是转载的如何申请连续的地址空间（c++）（http://blog.csdn.net/zhongshengjun/article/details/4632156）：</p>

<blockquote><p>   地址连续的二维数组在C语言数值计算中有重要意义，很多二维数组的算法是基于一维数组写的。另外，在序列化时或内存复制时，连续空间易于进行整块内存的操作。</p>

<p>   子程序说明：</p>

<p>   1- Array2D和FreeArray2D可实现地址连续的动态二维数组的地址分配和释放。</p>

<p>  2- 作为对照，下面给出了地址不连续的二维数组地址分配与释放的子程序。</p></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="c1">// 创建 n X m 的动态数组，该数组的元素地址在内存中是连续的</span>
</span><span class='line'><span class="c1">// n - 输入参数，数组的行数</span>
</span><span class='line'><span class="c1">// m - 输入参数，数组的列数</span>
</span><span class='line'><span class="c1">// 返回，double **，指向指针的指针，用于以二维数组的方式访问一段内存。</span>
</span><span class='line'><span class="kt">double</span> <span class="o">**</span><span class="n">Array2D</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="kt">int</span> <span class="n">m</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'> <span class="c1">// 建立数组的存储区，即在内存中分配一片连续的空间，元素个数为 n*m，</span>
</span><span class='line'> <span class="c1">// 返回指向double的指针。</span>
</span><span class='line'>    <span class="kt">double</span> <span class="o">*</span><span class="n">Array1D</span><span class="o">=</span><span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">n</span><span class="o">*</span><span class="n">m</span><span class="p">];</span>
</span><span class='line'> <span class="c1">// 建立数组的索引区，返回指向 double *的指针（指向指针的指针），长度为 n。</span>
</span><span class='line'>    <span class="kt">double</span> <span class="o">**</span><span class="n">Array2D</span><span class="o">=</span><span class="k">new</span> <span class="kt">double</span><span class="o">*</span> <span class="p">[</span><span class="n">n</span><span class="p">];</span>
</span><span class='line'> <span class="c1">// 将索引区的每个元素指向数据存储区对应元素的地址，Array2D[0] 指向 Array1D[0]，</span>
</span><span class='line'> <span class="c1">// Array2D[1] 指向 Array1D[m]，其余类推。</span>
</span><span class='line'>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>     <span class="n">Array2D</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=&amp;</span><span class="n">Array1D</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">m</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">Array2D</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 释放数组的空间，首先释放一维数组占用的n*m个double空间</span>
</span><span class='line'><span class="c1">// 再释放索引数组（指针数组）占用的n个double*空间</span>
</span><span class='line'> <span class="kt">void</span> <span class="n">FreeArray2D</span><span class="p">(</span><span class="kt">double</span> <span class="o">**</span><span class="n">Array2D</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">delete</span><span class="p">[]</span> <span class="n">Array2D</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'>  <span class="k">delete</span><span class="p">[]</span> <span class="n">Array2D</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 二维数组空间分配，地址一般不连续，不是推荐的方法</span>
</span><span class='line'> <span class="kt">double</span> <span class="o">**</span><span class="n">Array2D_A</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="kt">int</span> <span class="n">m</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'> <span class="c1">// 建立数组的索引区，返回指向 double *的指针（指向指针的指针），长度为 n。</span>
</span><span class='line'>    <span class="kt">double</span> <span class="o">**</span><span class="n">Array2D</span><span class="o">=</span><span class="k">new</span> <span class="kt">double</span><span class="o">*</span> <span class="p">[</span><span class="n">n</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'> <span class="c1">// 建立数组的存储区，对于Array2D的每一个指针元素，分配m个double空间</span>
</span><span class='line'>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>     <span class="n">Array2D</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">Array2D</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 释放数组的空间，与Array2D_A配套使用</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 首先释放n个一维数组（每个占用m个double空间）</span>
</span><span class='line'><span class="c1">// 再释放索引数组（指针数组）占用的n个double*空间</span>
</span><span class='line'> <span class="kt">void</span> <span class="n">FreeArray2D_A</span><span class="p">(</span><span class="kt">double</span> <span class="o">**</span><span class="n">Array2D</span><span class="p">,</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="k">delete</span><span class="p">[]</span> <span class="n">Array2D</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>  <span class="k">delete</span><span class="p">[]</span> <span class="n">Array2D</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[函数压栈的一些思考]]></title>
    <link href="http://tinyxd.me/blog/2012/06/13/han-shu-ya-zhan/"/>
    <updated>2012-06-13T07:22:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/13/han-shu-ya-zhan</id>
    <content type="html"><![CDATA[<p>今天，有个同学跑过来问我一个问题fun（i，i++，++i），我立马想到这个是跟函数压栈的顺序有关的，随后去网上查找资料，并开始写了一些测试实验。</p>

<p>先把cu上的一个解释先贴上来：</p>

<p>函数调用约定（Calling Convention）</p>

<!--more-->


<p>函数调用约定不仅决定了发生函数调用时函数参数的入栈顺序，还决定了是由调用者函数还是被调用函数负责清除栈中的参数，还原堆栈。函数调用约定有很多方 式，除了常见的__cdecl，__fastcall和__stdcall之外，C++的编译器还支持thiscall方式，不少C/C++编译器还支持 naked call方式。这么多函数调用约定常常令许多程序员很迷惑，到底它们是怎么回事，都是在什么情况下使用呢？下面就分别介绍这几种函数调用约定。</p>

<blockquote><p> <strong>1、__stdcall调用约定</strong> <br/>
  相当于16位动态库中经常使用的PASCAL调用约定。在32位的VC++5.0中PASCAL调用约定不再被支持（实际上它已被定义为__stdcall。除了__pascal外，__fortran和__syscall也不被支持），取而代之的是__stdcall调用约定。两者实质上是一致的，即函数的参数自右向左通过栈传递，被调用的函数在返回前清理传送参数的内存栈，但不同的是函数名的修饰部分（关于函数名的修饰部分在后面将详细说明）。 <em>stdcall是Pascal程序的缺省调用方式，通常用于Win32   Api中，函数采用从右到左的压栈方式，自己在退出时清空堆栈。VC将函数编译后会在函数名前面加上下划线前缀，在函数名后加上 &#8220;@ &#8220;和参数的字节数。 <br/>
 <strong>2、C调用约定</strong> <br/>
  （即用__cdecl关键字说明）按从右至左的顺序压参数入栈，由调用者把参数弹出栈。对于传送参数的内存栈是由调用者来维护的（正因为如此，实现可变参数的函数只能使用该调用约定）。另外，在函数名修饰约定方面也有所不同。
 </em>cdecl是C和C＋＋程序的缺省调用方式。每一个调用它的函数都包含清空堆栈的代码，所以产生的可执行文件大小会比调用<em>stdcall函数的大。函数采用从右到左的压栈方式。VC将函数编译后会在函数名前面加上下划线前缀。是MFC缺省调用约定。 <br/>
<strong>3、__fastcall调用约定</strong> <br/>
  是 &#8220;人 &#8220;如其名，它的主要特点就是快，因为它是通过寄存器来传送参数的（实际上，它用ECX和EDX传送前两个双字（DWORD）或更小的参数，剩下的参数仍旧自右向左压栈传送，被调用的函数在返回前清理传送参数的内存栈），在函数名修饰约定方面，它和前两者均不同。
 </em>fastcall方式的函数采用寄存器传递参数，VC将函数编译后会在函数名前面加上 &#8220;@ &#8220;前缀，在函数名后加上 &#8220;@ &#8220;和参数的字节数。 <br/>
<strong>4、thiscall</strong> <br/>
  仅仅应用于 &#8220;C++ &#8220;成员函数。this指针存放于CX寄存器，参数从右到左压。thiscall不是关键词，因此不能被程序员指定。 <br/>
 <strong>5、naked   call</strong> <br/>
  采用1-4的调用约定时，如果必要的话，进入函数时编译器会产生代码来保存ESI，EDI，EBX，EBP寄存器，退出函数时则产生代码恢复这些寄存器的内容。
naked   call不产生这样的代码。naked   call不是类型修饰符，故必须和_declspec共同使用。
关键字__stdcall __cdecl和 __fastcall可以直接加在要输出的函数前，也可以在编译环境的Setting&#8230;\C/C++   \Code   Generation项选择。当加在输出函数前的关键字与编译环境中的选择不同时，直接加在输出函数前的关键字有效。它们对应的命令行参数分别为/Gz、/Gd和/Gr。缺省状态为/Gd，即__cdecl。
要完全模仿PASCAL调用约定首先必须使用__stdcall调用约定，至于函数名修饰约定，可以通过其它方法模仿。还有一个值得一提的是WINAPI宏，Windows.h支持该宏，它可以将出函数翻译成适当的调用约定，在WIN32中，它被定义为__stdcall。使用WINAPI宏可以创建自己的APIs 。</p>

<p>VC的编译环境默认是使用__cdecl调用约定，也可以在编译环境的Project Setting&#8230;菜单－》C/C++ ＝》Code    Generation项选择设置函数调用约定。也可以直接在函数声明前添加关键字__stdcall、__cdecl或__fastcall等单独确定函 数的调用方式。在Windows系统上开发软件常用到WINAPI宏，它可以根据编译设置翻译成适当的函数调用约定，在WIN32中，它被定义为 __stdcall。</p></blockquote>

<p>下面是华为某年的一个考题，</p>

<p>设</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="o">=</span><span class="n">arr</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span><span class="o">+=</span><span class="mi">123</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">printf</span><span class="p">(</span><span class="err">＂</span><span class="o">%</span><span class="n">d</span><span class="p">,</span><span class="o">%</span><span class="n">d</span><span class="err">＂</span><span class="p">,</span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="o">*</span><span class="p">(</span><span class="o">++</span><span class="n">ptr</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>答案为什么是：8，8</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="o">=</span><span class="n">arr</span><span class="p">;</span><span class="c1">//现在ptr指向6</span>
</span><span class='line'>
</span><span class='line'><span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span><span class="o">+=</span><span class="mi">123</span><span class="p">;</span><span class="c1">//现在ptr指向7,第一个元素变为129</span>
</span><span class='line'>
</span><span class='line'><span class="n">printf</span><span class="p">(</span><span class="err">＂</span><span class="o">%</span><span class="n">d</span><span class="p">,</span><span class="o">%</span><span class="n">d</span><span class="err">＂</span><span class="p">,</span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="o">*</span><span class="p">(</span><span class="o">++</span><span class="n">ptr</span><span class="p">));</span> <span class="c1">//考虑从右往左计算，先是*(++ptr)，现在ptr指向8，然后*ptr也是8，输出8，8</span>
</span></code></pre></td></tr></table></div></figure>


<p>嗯 虽然这样解释似乎有些道理，但是有人认为这是和编译器相关的，即，求值顺序是不定的。。也有可能出现7，8的结果。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[嵌入式linux应用程序自启动]]></title>
    <link href="http://tinyxd.me/blog/2012/06/10/qian-ru-shi-linuxying-yong-cheng-xu-zi-qi-dong/"/>
    <updated>2012-06-10T19:46:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/10/qian-ru-shi-linuxying-yong-cheng-xu-zi-qi-dong</id>
    <content type="html"><![CDATA[<p>在很多嵌入式系统中，由于可用资源较少，常常在系统启动后就直接让应用程序自动启动，以减少用户操作和节省资源。如何让自己的应用程序自动启动呢？    在Linux系统中，配置应用程序自动启动的方法有以下三种：</p>

<!--more-->


<h2>1.通过/Linuxrc脚本直接启动</h2>

<p>Linux内核一旦开始执行，它将通过驱动程序来初始化所有硬件设备，这个初始化过程可以在启动时的PC显示器上看到，每个驱动程序都打印一些相关信息。初始化完成后，通常调用的是init，通过loader调用init内的init=/app_program语句（通过loader向核心传入init=/program可以定制首先运行的程序）。 <br/>
比如在桌面Linux系统中，init进程会读取/etc/inittab文件，来决定执行级别和哪些脚本和命令。嵌入式应用开发中，可以根据实际情况决定是否使用标准的init执行方式，也许这个init是个静态程序，它能够完成我们的嵌入应用的特定任务，那完全不用考虑inittab了，在这里可以采用比较灵活的措施。</p>

<h2>2.在/etc/init.d下添加启动脚本</h2>

<p>一般情况下，大多数的Linux操作系统使用/etc/init.d/(或/etc/rc.d/init.d)下的脚本来配置应用程序的自动启动。 <br/>
例如，在某些Linux系统中，corn程序通过/etc/init.d/corn脚本启动，Apache通过/etc/init.d/httpd启动，syslogd通过/etc/init.d/syslogd启动，而sshd则通过/etc/init.d/sshd脚本启动。 <br/>
通常这些脚本通过来自特定rc.d目录的符号链接运行。为了配置从哪个rc.d目录运行脚本，Linux系统提供了许多不同的工具，同时也可以手工进行配置。Linux系统有一个包含所有实际启动脚本文件的目录。它可能是/etc/init.d，也可能是/etc/rc.d/rc.d。同时对应每个运行级别（runlevel）又有一个另外的目录，它们可能是/etc/rc2.d，也可能是/etc/rc.d/rc2.d。这些目录中的文件通常是指向实际脚本文件的符号链接。</p>

<h2>3.直接在/etc/rc.d/rc.local脚本中添加命令</h2>

<p>在Linux系统中，有一个类似Windows系统中autoexec.bat的文件，它就是/etc/rc.d/rc.local，系统开机后自动运行用户的应用程序或启动系统服务的命令保存在开发板根文件系统的这个文件中。因此可以编辑rc.local文件，将要执行的程序（命令）添加到该文件夹中。Linux系统在启动后还未登录前，将自动执行该程序（命令），达到开机自动运行用户的应用程序的目的。 <br/>
下面具体说明：  <br/>
首先解压ramdisk.image.gz文件，然后挂载到系统中。接着创建自己的应用程序文件夹hello，将所要自动运行的应用程序hello复制到该文件夹。 <br/>
然后打开/usr/etc/rc.local文件，在最后一行加入：/Myapp/hello/hello <br/>
再按上面的顺序将ramdisk.image打包下载到目标板，启动运行，则可以看到用户编写的应用程序一启动就运行起来了。 <br/>
本文参考《基于ARM9的嵌入式Linux开发技术》，李新峰等编著。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读C++ Primer 之句柄类]]></title>
    <link href="http://tinyxd.me/blog/2012/06/08/c-plus-plus-ju-bing-lei/"/>
    <updated>2012-06-08T20:28:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/08/c-plus-plus-ju-bing-lei</id>
    <content type="html"><![CDATA[<p>转自Linux社区 作者：xizero00：http://www.linuxidc.com/Linux/2011-08/40175.htm</p>

<p>我们知道C++中最令人头疼的当属指针，如果您申请了对象却没有释放它，时间一长就会造成系统崩溃，大量的内存溢出使得您的程序的健壮性出现问题</p>

<p>而句柄类就是为了能够解决这一问题而出现的，句柄类有点类似于智能指针。</p>

<p>好了，废话不多说，我们来看代码</p>

<!--more-->


<p>首先我们来看 sample.h文件的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm">* author:xizero00</span>
</span><span class='line'><span class="cm">* mail:xizero00@163.com</span>
</span><span class='line'><span class="cm">* date:2011-08-07 20:11:24</span>
</span><span class='line'><span class="cm">* Handle Class Sample  句柄类示例</span>
</span><span class='line'><span class="cm">*/</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#ifndef SAMPLE_H</span>
</span><span class='line'><span class="cp">#define SAMPLE_H   </span>
</span><span class='line'>
</span><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;stdexcept&gt;</span>
</span><span class='line'><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//基类</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Item_base</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">//基类的虚函数,用于智能地复制对象</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="n">Item_base</span><span class="o">*</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">new</span> <span class="n">Item_base</span><span class="p">(</span> <span class="o">*</span><span class="k">this</span> <span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//子类</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Bulk_item</span><span class="o">:</span> <span class="k">public</span> <span class="n">Item_base</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">//子类的虚函数的重载,用于智能地复制对象</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="n">Bulk_item</span><span class="o">*</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">new</span> <span class="n">Bulk_item</span><span class="p">(</span> <span class="o">*</span><span class="k">this</span> <span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//子类的子类</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Sales_item</span><span class="o">:</span> <span class="k">public</span> <span class="n">Bulk_item</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">//默认构造函数,用来初始化一个引用计数器</span>
</span><span class='line'>    <span class="n">Sales_item</span><span class="p">()</span><span class="o">:</span> <span class="n">p</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">,</span> <span class="n">use</span><span class="p">(</span> <span class="k">new</span> <span class="n">size_t</span><span class="p">(</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Sales_item的引用计数器初始化为1&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//带有一个参数的,且该参数为基类引用的构造函数</span>
</span><span class='line'>    <span class="n">Sales_item</span><span class="p">(</span> <span class="k">const</span> <span class="n">Item_base</span><span class="o">&amp;</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//复制构造函数,需要注意的是，每复制一次就需要增加引用计数一次</span>
</span><span class='line'>    <span class="n">Sales_item</span><span class="p">(</span> <span class="k">const</span> <span class="n">Sales_item</span> <span class="o">&amp;</span><span class="n">i</span> <span class="p">)</span><span class="o">:</span> <span class="n">p</span><span class="p">(</span> <span class="n">i</span><span class="p">.</span><span class="n">p</span> <span class="p">)</span> <span class="p">,</span> <span class="n">use</span><span class="p">(</span> <span class="n">i</span><span class="p">.</span><span class="n">use</span> <span class="p">)</span> <span class="p">{</span> <span class="o">++*</span><span class="n">use</span><span class="p">;</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;由于采用了复制构造函数,Sales_item类型的对象引用计数为:&quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">use</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;}</span> <span class="c1">//也可以这样写</span>
</span><span class='line'>    <span class="c1">//Sales_item( const Sales_item &amp;i ): p( i.clone() ) , use( new size_t( 1 ) ) { ++*use; }   </span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//析构函数,析构的时候会判断是否能够释放指针所指向的数据</span>
</span><span class='line'>    <span class="o">~</span><span class="n">Sales_item</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;在析构函数中:&quot;</span><span class="p">;</span> <span class="n">decr_use</span><span class="p">();</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//赋值操作符重载</span>
</span><span class='line'>    <span class="n">Sales_item</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span> <span class="p">(</span> <span class="k">const</span> <span class="n">Sales_item</span><span class="o">&amp;</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//访问操作符重载</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">Item_base</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span> <span class="p">()</span> <span class="k">const</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span> <span class="n">p</span> <span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="k">throw</span> <span class="n">logic_error</span><span class="p">(</span> <span class="s">&quot;p指针错误&quot;</span> <span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//解引用操作符重载</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">Item_base</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span> <span class="p">()</span> <span class="k">const</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span> <span class="n">p</span> <span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>        <span class="p">{</span><span class="c1">//重载虚函数,用于智能地复制对象</span>
</span><span class='line'>            <span class="k">throw</span> <span class="n">logic_error</span><span class="p">(</span> <span class="s">&quot;p指针错误&quot;</span> <span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//重载虚函数,用于智能地复制对象</span>
</span><span class='line'>    <span class="cm">/*</span>
</span><span class='line'><span class="cm">    virtual Sales_item* clone() const</span>
</span><span class='line'><span class="cm">    {</span>
</span><span class='line'><span class="cm">        return new Sales_item( *this );</span>
</span><span class='line'><span class="cm">    }</span>
</span><span class='line'><span class="cm">    */</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">//两个指针存储着引用计数器以及数据的指针</span>
</span><span class='line'>    <span class="n">Item_base</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span><span class='line'>    <span class="n">size_t</span> <span class="o">*</span><span class="n">use</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//减少引用</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">decr_use</span><span class="p">()</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;在 dec_use函数中引用计数减少了,当前计数值为:&quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">use</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span> <span class="o">--*</span><span class="n">use</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
</span><span class='line'>            <span class="k">delete</span> <span class="n">use</span><span class="p">;</span>
</span><span class='line'>            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;在 dec_use函数中计数器减为0,释放对象&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//赋值操作符重载,每次复制都会增加引用计数</span>
</span><span class='line'><span class="n">Sales_item</span><span class="o">&amp;</span> <span class="n">Sales_item</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span> <span class="p">(</span> <span class="k">const</span> <span class="n">Sales_item</span> <span class="o">&amp;</span><span class="n">si</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;由于采用类赋值操作,&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;被赋值的对象的引用计数为:&quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">si</span><span class="p">.</span><span class="n">use</span> <span class="p">;</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;即将被赋值的对象的引用计数为:&quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">use</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">//这里需要特别注意的就是待复制的对象的计数器需要加1而被赋值的对象需要减1     </span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//增加被复制对象的引用计数</span>
</span><span class='line'>    <span class="o">++*</span><span class="n">si</span><span class="p">.</span><span class="n">use</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;被赋值的对象的赋值之后的引用计数为:&quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">si</span><span class="p">.</span><span class="n">use</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">//将即将被赋值的对象的引用计数减1</span>
</span><span class='line'>    <span class="n">decr_use</span><span class="p">();</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; 即将被赋值的对象赋值之后的引用计数为:&quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">use</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//复制指针</span>
</span><span class='line'>    <span class="n">p</span> <span class="o">=</span> <span class="n">si</span><span class="p">.</span><span class="n">p</span><span class="p">;</span>
</span><span class='line'>    <span class="n">use</span> <span class="o">=</span> <span class="n">si</span><span class="p">.</span><span class="n">use</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//返回</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#endif </span><span class="c1">//SAMPLE_H</span>
</span><span class='line'>
</span><span class='line'><span class="err">接下来我们来看</span><span class="n">sample</span><span class="p">.</span><span class="n">cc</span><span class="err">的代码：</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm">* author:xizero00</span>
</span><span class='line'><span class="cm">* mail:xizero00@163.com</span>
</span><span class='line'><span class="cm">* date:2011-08-07 20:11:24</span>
</span><span class='line'><span class="cm">*/</span>
</span><span class='line'><span class="cp">#include &quot;sample.h&quot;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span> <span class="kt">int</span> <span class="n">argc</span> <span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">//重点关注i1和i2的引用计数</span>
</span><span class='line'>    <span class="n">Sales_item</span> <span class="n">i1</span> <span class="p">,</span> <span class="n">i2</span><span class="p">;</span><span class="c1">//i1和i2的引用计数分别为1</span>
</span><span class='line'>    <span class="n">Sales_item</span> <span class="n">i3</span><span class="p">(</span> <span class="n">i1</span> <span class="p">);</span><span class="c1">//i1的引用计数变为2</span>
</span><span class='line'>    <span class="n">Sales_item</span> <span class="n">i4</span> <span class="o">=</span> <span class="n">i1</span><span class="p">;</span><span class="c1">//i1的引用计数变为3,因为这样还是调用的复制构造函数</span>
</span><span class='line'>    <span class="n">i4</span> <span class="o">=</span> <span class="n">i2</span><span class="p">;</span> <span class="c1">// i2的引用计数变为2   </span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面给出编译所需的Makefile</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp"># author:xizero00</span>
</span><span class='line'><span class="cp"># mail:xizero00@163.com</span>
</span><span class='line'><span class="cp"># date:2011-08-08 00:51:25</span>
</span><span class='line'><span class="nl">install:</span>
</span><span class='line'>    <span class="n">g</span><span class="o">++</span> <span class="n">sample</span><span class="p">.</span><span class="n">cc</span> <span class="o">-</span><span class="n">g</span> <span class="o">-</span><span class="n">o</span> <span class="n">sample</span>
</span><span class='line'>    <span class="n">ls</span> <span class="o">-</span><span class="n">al</span> <span class="n">sample</span><span class="o">*</span>
</span><span class='line'>    <span class="p">.</span><span class="o">/</span><span class="n">sample</span>
</span><span class='line'><span class="nl">clean:</span>
</span><span class='line'>    <span class="n">rm</span> <span class="o">-</span><span class="n">f</span> <span class="n">sample</span>
</span><span class='line'>    <span class="n">ls</span> <span class="o">-</span><span class="n">al</span> <span class="n">sample</span><span class="o">*</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意：代码是在linux下编译，您只需要将三个文件放在同一个目录，然后在当前目录打开终端，输入make，就可以查看到结果。</p>

<p>如果您想清理生成的文件 输入make clean即可</p>

<p>下面是我执行的结果：</p>

<pre><code>Sales_item的引用计数器初始化为1
Sales_item的引用计数器初始化为1
由于采用了复制构造函数,Sales_item类型的对象引用计数为:2
由于采用了复制构造函数,Sales_item类型的对象引用计数为:3
由于采用类赋值操作,被赋值的对象的引用计数为:1即将被赋值的对象的引用计数为:3
被赋值的对象的赋值之后的引用计数为:2
在 dec_use函数中引用计数减少了,当前计数值为:2
 即将被赋值的对象赋值之后的引用计数为:2
在析构函数中:在 dec_use函数中引用计数减少了,当前计数值为:1
在析构函数中:在 dec_use函数中引用计数减少了,当前计数值为:1
在析构函数中:在 dec_use函数中引用计数减少了,当前计数值为:0
在 dec_use函数中计数器减为0,释放对象
在析构函数中:在 dec_use函数中引用计数减少了,当前计数值为:0
在 dec_use函数中计数器减为0,释放对象
</code></pre>

<p>结论：我们可以看到，句柄类能够很方便并且能够很安全地释放内存，不会导致内存的泄露。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[堆和栈的区别]]></title>
    <link href="http://tinyxd.me/blog/2012/06/08/dui-he-zhan-de-qu-bie/"/>
    <updated>2012-06-08T06:59:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/08/dui-he-zhan-de-qu-bie</id>
    <content type="html"><![CDATA[<p>出自: http://www.cnitexam.com <br/>
一、预备知识—程序的内存分配</p>

<p>一个由c/C++编译的程序占用的内存分为以下几个部分</p>

<p>1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p>

<p>2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。</p>

<p>3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 – 程序结束后有系统释放</p>

<p>4、文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放</p>

<p>5、程序代码区—存放函数体的二进制代码。</p>

<!--more-->


<p>二、例子程序</p>

<p>这是一个前辈写的，非常详细</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">//main.cpp</span>
</span><span class='line'><span class="cp">#include &lt;stdlib.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;string.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">// 全局初始化区</span>
</span><span class='line'>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="n">p1</span><span class="p">;</span><span class="c1">// 全局未初始化区</span>
</span><span class='line'>
</span><span class='line'><span class="n">main</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">b</span><span class="p">;</span><span class="c1">// 栈</span>
</span><span class='line'>
</span><span class='line'><span class="kt">char</span> <span class="n">s</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;abc&quot;</span><span class="p">;</span> <span class="c1">//栈</span>
</span><span class='line'>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="n">p2</span><span class="p">;</span><span class="c1">// 栈</span>
</span><span class='line'>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="n">p3</span> <span class="o">=</span> <span class="s">&quot;123456&quot;</span><span class="p">;</span> <span class="c1">//123456\0在常量区，p3在栈上。</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span><span class="mi">0</span><span class="err">；</span><span class="c1">// 全局（静态）初始化区</span>
</span><span class='line'>
</span><span class='line'><span class="n">p1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="c1">//分配得来得10和20字节的区域就在堆区。</span>
</span><span class='line'>
</span><span class='line'><span class="n">strcpy</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="s">&quot;123456&quot;</span><span class="p">);</span> <span class="c1">//123456\0放在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;优化成一个地方。</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>二、堆和栈的理论知识</p>

<p>2.1申请方式</p>

<p>stack:</p>

<p>由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间</p>

<p>heap:</p>

<p>需要程序员自己申请，并指明大小，在c中malloc函数</p>

<p>如p1 = (char *)malloc(10);</p>

<p>在C++中用new运算符</p>

<p>如char *p2 =new char[10];</p>

<p>但是注意p1、p2本身是在栈中的。</p>

<p>2.2 申请后系统的响应</p>

<p>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p>

<p>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，</p>

<p>会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</p>

<p>2.3申请大小的限制</p>

<p>栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</p>

<p>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p>

<p>2.4申请效率的比较：</p>

<p>栈由系统自动分配，速度较快。但程序员是无法控制的。</p>

<p>堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.</p>

<p>另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活</p>

<p>2.5堆和栈中的存储内容</p>

<p>栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。</p>

<p>当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</p>

<p>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。</p>

<p>2.6存取效率的比较</p>

<p>char s1[] = “aaaaaaaaaaaaaaa”;</p>

<p>char *s2 = “bbbbbbbbbbbbbbbbb”;</p>

<p>aaaaaaaaaaa是在运行时刻赋值的；</p>

<p>而bbbbbbbbbbb是在编译时就确定的；</p>

<p>但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。</p>

<p>比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdlib.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="kt">char</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">char</span> <span class="n">c</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;1234567890&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span><span class="s">&quot;1234567890&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>对应的汇编代码</p>

<p>10: a = c[1];</p>

<p>004010678A4D F1 mov cl,byte ptr [ebp-0Fh]</p>

<p>0040106A88 4D FC mov byte ptr [ebp-4],cl</p>

<p>11: a = p[1];</p>

<p>0040106D 8B 55 EC mov edx,dword ptr [ebp-14h]</p>

<p>004010708A42 01 mov al,byte ptr [edx+1]</p>

<p>00401073 88 45 FC mov byte ptr [ebp-4],al</p>

<p>第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，在根据edx读取字符，显然慢了。</p>

<p>2.7小结：</p>

<p>堆和栈的区别可以用如下的比喻来看出：</p>

<p>使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。</p>

<p>使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。</p>

<p>堆和栈的区别主要分：</p>

<p>操作系统方面的堆和栈，如上面说的那些，不多说了。</p>

<p>还有就是数据结构方面的堆和栈，这些都是不同的概念。这里的堆实际上指的就是（满足堆性质的）优先队列的一种数据结构，第1个元素有最高的优先权；栈实际上就是满足先进后出的性质的数学或数据结构。</p>

<p>虽然堆栈，堆栈的说法是连起来叫，但是他们还是有很大区别的，连着叫只是由于历史的原因。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解决pygments.rb (RubyPython) 找不到libpython的问题(archlinux下)]]></title>
    <link href="http://tinyxd.me/blog/2012/06/05/cannot-find-libpython/"/>
    <updated>2012-06-05T08:01:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/05/cannot-find-libpython</id>
    <content type="html"><![CDATA[<p>本文章转自：<a href="http://ruby-china.org/topics/289">Ruby China 论坛</a> <br/>
如果找不到python，或者系统默认得python是3.x (比如Arch Linux)，手动制定下路径</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>RubyPython.configure python_exe: '/usr/bin/python2.7'</span></code></pre></td></tr></table></div></figure>


<p>对于rails项目比如ruby-china，可以把这行代码丢到config/initializers下。</p>

<p>不过RubyPython仍然可能找不到libpython而提示lib.so not found。这是由于RubyPython确定正确libpython的规则和你的系统不兼容，可以通过手动加些symbol links来解决 (目前RubyPython的git最新代码相对当前稳定版本0.5.3改动非常大，希望新版本能解决这个问题，就先不去提交fixing了)。</p>

<p>可以参考 PythonExec initialize 方法中的规则来建symbol link.</p>

<!--more-->


<p>首先运行该python，得到版本号x.y，以python2.7为例</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ python2.7 -c "import sys;print '%d.%d' % sys.version_info[:2]"
</span><span class='line'>
</span><span class='line'>=&gt; 2.7</span></code></pre></td></tr></table></div></figure>


<p>找到该python对应得libpython，可以用工具ldd:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ldd /usr/lib/python2.7 | grep python
</span><span class='line'>
</span><span class='line'>=&gt; libpython2.7.so.1.0 =&gt; /usr/lib/libpython2.7.so.1.0</span></code></pre></td></tr></table></div></figure>


<p>为找到的这个文件创建链接。下面用#{exe_base}表示通过RubyPython.configure指定的python可执行程序的文件名部分，#{x}和#{y}是通过运行这个python找到得版本号，#{libpython}是该python对应得libpython库文件路径。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo ln -s #{libpython} /usr/lib/lib#{exe_base}#{x}#{y}.so
</span><span class='line'>sudo ln -s #{libpython} /usr/lib/lib#{exe_base}#{x}.#{y}.so</span></code></pre></td></tr></table></div></figure>


<p>以我的环境(Arch Linux)为例，exe_base是python2.7，版本号x.y是2.7，libpython是/usr/lib/libpython2.7.so.1.0，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo ln -s /usr/lib/libpython2.7.so.1.0 /usr/lib/libpython2.727.so
</span><span class='line'>sudo ln -s /usr/lib/libpython2.7.so.1.0 /usr/lib/libpython2.72.7.so</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux下使用lftp的小结]]></title>
    <link href="http://tinyxd.me/blog/2012/06/04/linuxxia-shi-yong-lftpde-xiao-jie/"/>
    <updated>2012-06-04T07:08:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/04/linuxxia-shi-yong-lftpde-xiao-jie</id>
    <content type="html"><![CDATA[<p>lftp的功能比较强大，相比原来用ftp，方便了很多。</p>

<p>1、登陆：</p>

<p>lftp ftp://yourname@site</p>

<p>pwd:*****</p>

<p>或 open ftp://yourname@site</p>

<!--more-->


<p>2、基本操作（转） <br/>
lftp使用介绍</p>

<p>lftp 是一个功能强大的下载工具，它支持访问文件的协议: ftp, ftps, http, https, hftp, fish.(其中ftps和https需要在编译的时候包含openssl库)。llftp的界面非常想一个shell: 有命令补全，历史记录，允许多个后台任务执行等功能，使用起来非常方便。它还有书签、排队、镜像、断点续传、多进程下载等功能。 <br/>
命令行语法
要看lftp的命令行语法，只要在shell中输入lftp &#8211;help <br/>
lftp [OPTS]
&#8216;lftp&#8217;是在 rc 文件执行后 lftp 执行的第一个命令 <br/>
-f 执行文件中的命令后退出 <br/>
-c 执行命令后退出 <br/>
&#8211;help 显示帮助信息后退出 <br/>
&#8211;version 显示 lftp 版本后退出 <br/>
其他的选项同 &#8216;open&#8217; 命令 <br/>
-e 在选择后执行命令 <br/>
-u [,] 使用指定的用户名/口令进行验证 <br/>
-p 连接指定的端口 <br/>
主机名, URL 或书签的名字 <br/>
如果在命令行中输入的站点名称，lftp将直接登录站点，比如 <br/>
ftp ftp://&#8230;&#8230;&#8230;&#8230;. <br/>
如果在命令行不输入站点名称，则必须在进入到lftp界面后用open命令打开 <br/>
[yhj@ccse-yhj yhj]$ lftp <br/>
lftp :~> open ftp://&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;. <br/>
常用命令 <br/>
* 下载单个文件和一组文件，断点续传用-c参数 <br/>
lftp &#8230;&#8230;&#8230;&#8230;&#8230;.:/> get -c ls-lR.txt <br/>
lftp &#8230;&#8230;&#8230;&#8230;&#8230;:/> mget *.txt <br/>
* 镜像(反镜像即上传)一个目录，可以用多个线程并行镜像一个目录(&#8211;parallel=N) <br/>
lftp &#8230;&#8230;&#8230;&#8230;&#8230;.:/> mirror incoming local_name <br/>
lftp &#8230;&#8230;&#8230;&#8230;&#8230;.:/> mirror -R local_name <br/>
lftp &#8230;&#8230;&#8230;&#8230;&#8230;.:/> mirror &#8211;parallel=3 incoming local_name <br/>
* 多线程下载，类似网络蚂蚁的功能;缺省是5个线程 <br/>
lftp &#8230;&#8230;&#8230;&#8230;&#8230;.:/> pget -n 4 ls-lR.txt <br/>
* 后台任务管理 <br/>
缺省情况下，按 Ctrl+z,正在执行的任务将转为后台执行，也可以在命令行末尾加&amp;符号使任务在后台执行。用jobs命令可以查看所有的后台进程。用queue命令可以排队新的任务。如果退出lftp是还有任务在后台执行，lftp将转为后台执行。 <br/>
* 其它用法 <br/>
lftp支持类似bash的管道操作，例如用下面的命令可以将ftp服务器上的特定目录下(也可以是整个站点)所有文件的大小存到本地的文件ls.txt中 <br/>
lftp &#8230;&#8230;&#8230;&#8230;&#8230;.:/> du incoming > ls.txt <br/>
相关文件
/etc/lftp.conf <br/>
全局配置文件，实际位置依赖系统配置文件目录，可能在/etc，也可能在/usr/local/etc <br/>
~/.lftp/rc, ~/.lftprc <br/>
用户配置文件，将在/etc/lftp.conf之后执行，所以这里面的设置会覆盖/etc/lftp.conf中的设置。 <br/>
lftp 缺省不会显示 ftp 服务器的欢迎信息和错误信息，这在很多时候不方便，因为你有可能想知道这个服务器到底是因为没开机连不上，还是连接数已满。如果是这样，你可以在 ~/.lftprc 里写入一行 <br/>
debug 3
就可以看到出错信息了。 <br/>
更多的配置选项请查man手册或在lftp界面内用命令 set -a 获得。 <br/>
~/.lftp/log <br/>
当lftp转为后台非挂起模式执行时，输出将重定向到这里 <br/>
~/.lftp/bookmarks <br/>
这是lftp存储书签的地方，可以lftp查看bookmark命令 <br/>
~/.lftp/cwd_history <br/>
这个文件用来存储访问过的站点的工作目录</p>

<p>~/.lftprc  <br/>
在用lftp访问国内一些ftp服务器时，往往看到的中文是乱码  <br/>
^_<sup>不用慌，这是由于服务器和本地编码不一致造成的。我们只要在主目录下新建一个文件~/.lftprc或者~/.lftp/rc</sup>  <br/>
并在其中加入以下内容：  <br/>
debug 3set ftp:charset GBKset file:charset UTF-8#set ftp:passtive-mode no#alias utf8 &#8221; set ftp:charset UTF-8&#8221;#alias gbk &#8221; set ftp:charset GBK&#8221;  <br/>
登录ftp服务器  <br/>
言归正传，我们先来看看怎么登录ftp服务器  <br/>
lftp ftp://user:password@site:port  <br/>
lftp user:password@site:port  <br/>
lftp site -p port -u user,password  <br/>
lftp site:port -u user,password  <br/>
上面的几种方式都能正常工作，不过密码都是明文，这样好像不太安全哦。没关系  <br/>
lftp user@site:port  <br/>
系统会提示输入password，密码就回显为******了  <br/>
不过每次都输入这么多，好麻烦哦。 如果有类似leapftp的站点管理器就好了，其实lftp早就给我们想好了： 这就是bookmark。后面我们将会看到。  <br/>
常用命令  <br/>
在终端运行  <br/>
man lftp  <br/>
或登录ftp后输入  <br/>
help  <br/>
就可以看到命令列表  <br/>
下面我们看一下lftp常用的命令：  <br/>
ls  <br/>
显示远端文件列表(!ls 显示本地文件列表)。  <br/>
cd  <br/>
切换远端目录(lcd 切换本地目录)。  <br/>
get  <br/>
下载远端文件。  <br/>
mget  <br/>
下载远端文件(可以用通配符也就是 *)。  <br/>
pget  <br/>
使用多个线程来下载远端文件, 预设为五个。  <br/>
mirror  <br/>
下载/上传(mirror -R)/同步 整个目录。  <br/>
put  <br/>
上传文件。  <br/>
mput  <br/>
上传多个文件(支持通配符)。  <br/>
mv  <br/>
移动远端文件(远端文件改名)。  <br/>
rm  <br/>
删除远端文件。  <br/>
mrm  <br/>
删除多个远端文件(支持通配符)。  <br/>
mkdir  <br/>
建立远端目录。  <br/>
rmdir  <br/>
删除远端目录。  <br/>
pwd  <br/>
显示目前远端所在目录(lpwd 显示本地目录)。  <br/>
du  <br/>
计算远端目录的大小  <br/>
!  <br/>
执行本地 shell的命令(由于lftp 没有 lls, 故可用 !ls 来替代)  <br/>
lcd  <br/>
切换本地目录  <br/>
lpwd  <br/>
显示本地目录  <br/>
alias  <br/>
定义别名  <br/>
bookmark  <br/>
设定书签。  <br/>
exit  <br/>
退出ftp  <br/>
快捷书签  <br/>
补充作者：aBiNg  <br/>
ftp中的bookmark命令，是将配置写到~/.lftp/bookmarks文件中；我们可以直接修改此文件，快速登陆ftp服务器。</p>

<p>3、mirror 同步镜像，备份服务器文件</p>

<p>今天主要的问题是解决如何备份服务器端文件的问题。了解了mirror指令的用法后，发现比较适合而且好用。</p>

<p>基本使用方法：</p>

<p>1）、下载服务器端文件：</p>

<p> mirror –vn RCD LCD   //RCD为远程路径，LCD为本地路径</p>

<p>2）、上传文件：</p>

<p> mirror –R LCD RCD</p>

<p>下附一个自动同步的脚本：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!bin/bash</span>
</span><span class='line'><span class="nb">echo</span> “script start at  <span class="sb">`</span>date ”+%Y-%m-%d %H:%M:%S”
</span><span class='line'><span class="nv">HOST</span><span class="o">=</span>”hostname”
</span><span class='line'><span class="nv">USER</span><span class="o">=</span>”yourname”
</span><span class='line'><span class="nv">PASS</span><span class="o">=</span>”password”
</span><span class='line'><span class="nv">LCD</span><span class="o">=</span>”LocalePath”
</span><span class='line'><span class="nv">RCD</span><span class="o">=</span>”RemotePath”
</span><span class='line'>/usr/sbin/lftp <span class="s">&lt;&lt; EOF</span>
</span><span class='line'><span class="s">open ftp://$USER:$PASS@$HOST</span>
</span><span class='line'><span class="s">mirror $RCD $LCD</span>
</span><span class='line'><span class="s">EOF</span>
</span><span class='line'><span class="nb">echo</span> “script end at “ <span class="sb">`</span>date ”+%Y-%m-%d %H:%M:%S”
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cache一致性问题总结]]></title>
    <link href="http://tinyxd.me/blog/2012/05/31/cache--zhi-xing-wen-ti-zong-jie/"/>
    <updated>2012-05-31T20:59:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/05/31/cache&#8211;zhi-xing-wen-ti-zong-jie</id>
    <content type="html"><![CDATA[<h2>1.现代并行机中，为了提高处理器的速度，处理器往往带有Cache。</h2>

<p>一个数据在整个系统内可能有多份拷贝，这就引发了Cache一致性问题。
例如下图中的2个处理器和共享内存构成的系统。初始时刻，处理机P1和P2都将变量X从共享内存装入了私有Cache。
这时，两个Cache中和共享内存中的变量X的值是一样的。在程序运行的某一时刻，处理机P1把X的值修改为X&#8217;，并更新了私有Cache中 的值。
此时无论P1采用写直达（write-through），还是写回（write-back）策略，都不会修改P2私有Cache中X的值。这时如果P2需要读取X，则它得到的是过时的值。 <br/>
<img src="http://tinyxd.me/images/cache.gif"></p>

<!--more-->


<p>　　Cache一致性问题是指在含有多个Cache的并行系统中，数据的多个副本（因为没有同步更新）而造成的不一致问题。以上的例子是由于多个处理器共享一个可写变量
造成的Cache不一致。还有其它原因也会造成Cache一致性问题，比如进程迁移和某些I/O操作等。</p>

<h2>2.c64x+与cache一致性问题（http://focus.ti.com.cn/cn/general/docs/gencontent.tsp?contentId=64183）</h2>

<p>在各种数字信号处理系统中，CACHE被广泛用于弥补Core与存储器之间的速度差异。在CACHE的使用过程中，存在不同类型存储器之间数据是否一致的问题。
本文着重分析TI高性能C64x+ DSP系列中各级CACHE之间数据一致性问题以及如何进行一致性维护。CACHE作为Core和低速存储器之间的桥梁，基于代码和
数据的时间和空间相关性，以块为单位由硬件控制器自动加载Core所需要的代码和数据。如果所有程序和数据的存取都由Core完成，基于CACHE的运行机制，
Core始终能够得到存储器中最新的数据。但是当有其它可以更改存储器内容的部件存在时，例如不需要Core干预的直接数据存取（DMA）引擎，就可能出现
由于CACHE的存在而导致Core或者DMA不能够得到最新数据的现象，也就是CACHE一致性的问题。 C64x+ 存储器组织结构：TI对高性能C64x核进行了改进，
使其性能大大提升，称之为C64x+DSP核。基于C64x+核开发的DSP芯片，所有部件都以交换网络（SCR）为核心连接起来。SCR上的部件分为两类：Master和Slave。
Master包括Core、EDMA以及串行高速IO（sRIO），EMAC等外设。Master可以直接通过SCR发起到Slave的数据传输。Slave包括每一个Core的内存，DDR2外存以及
其它不能直接发起数据传输的外设，Slave之间的数据传输，需要通过DMA协助完成。各款基于C64x+DSP的数据手册上详细描述了SCR的配置和Master、Slave的情况。</p>

<h2>3.DMA与cache一致性问题</h2>

<p>　Cache数据与主存数据不一致是指：在采用Cache的系统中，同样一个数据可能既存在于Cache中，也存在于主存中，两者数据相同则具有一致性，
数据不相同就叫做不一致性。如果不能保证数据的一致性，那么，后续程序的运行就要出现问题。假设DMA针对内存的目的地址与Cache缓存的对象
没有重叠区域，DMA和Cache之间将相安无事。但是如果DMA的目的地址与Cache所缓冲的内存地址访问有重叠，经过DMA操作Cache缓冲所对应的内存数据已经被修改，
而CPU本身并不知道，它仍然认为Cache中的数据就是内存中的数据，以后访问Cache映射的内存时，它仍然使用陈旧的Cache数据。这样就发生Cache与内存之间数据“
不一致性”的错误。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[arch linux下java SDK的安装与配置]]></title>
    <link href="http://tinyxd.me/blog/2012/05/27/arch-linuxxia-java-sdkde-an-zhuang-yu-pei-zhi/"/>
    <updated>2012-05-27T19:58:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/05/27/arch-linuxxia-java-sdkde-an-zhuang-yu-pei-zhi</id>
    <content type="html"><![CDATA[<p>为了节省以后查资料的时间，故而转到自己的blog做个备份。
转自：
<a href="http://www.cnblogs.com/heart-runner/archive/2011/11/30/2269640.html">Arch Linux中Java SDK的安装与配置</a></p>

<p>因为版权和公司对开源软件的态度，Oracle Java SDK已经不再包含于Arch Linux默认的Repository。</p>

<p>不过对于有开发需要，又不得不使用Oracle公司的产品的民工们，还好有AUR中提供的相应支持，让我们能方便地用安装脚本来处理Oracle Java SDK的安装和配置。</p>

<p>下面就简单地记录下的JDK的安装方法。</p>

<p>安装环境如下：</p>

<pre><code>archbang 3.3.6-1-ARCH
Oracle Java SDK 7 update 1
</code></pre>

<h2><strong>安装</strong></h2>

<ul>
<li>jre <br/>
这里先安装JDK，虽然据说openjdk的jre也能兼容Oracle Java SDK，但还是有点担心它们的兼容性。  <br/>
先在<a href="https://aur.archlinux.org/">Arch Linux AUR</a>中找到<a href="https://aur.archlinux.org/packages.php?ID=51908">JRE</a>。<br/>
<!--more-->
制作安装包</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ wget --no-check-certificate -c https://aur.archlinux.org/packages/jr/jre/jre.tar.gz   
</span><span class='line'>$ tar -zxvf jre.tar.gz   
</span><span class='line'>$ cd  jre   
</span><span class='line'>$ makepkg    
</span><span class='line'>   </span></code></pre></td></tr></table></div></figure>


<p>处理依赖条件，开始安装</p>

<pre><code>$ sudo pacman -S desktop-file-utils libxtst shared-mime-info xdg-utils
[zzz@archbang jre]$ sudo pacman -U ./jre-7.4-1-i686.pkg.tar.xz 
loading packages...
resolving dependencies...
looking for inter-conflicts...

Targets (1): jre-7.4-1

Total Installed Size:   92.30 MiB

Proceed with installation? [Y/n] 
(1/1) checking package integrity                   [----------------------] 100%
(1/1) loading package files                        [----------------------] 100%
(1/1) checking for file conflicts                  [----------------------] 100%
(1/1) checking available disk space                [----------------------] 100%
(1/1) installing jre                               [----------------------] 100%

The jre package is licensed software.
You MUST read and agree to the license stored in
/usr/share/licenses/jre/LICENSE before using it.
Please relogin to include jre in your PATH.

Optional dependencies for jre
    alsa-lib: sound support
    ttf-dejavu: fonts
</code></pre>

<p>Arch Linux中，Java SDK默认的安装位置是/opt/java</p>

<pre><code>$ pwd 
/opt/java
$ ls
jre
</code></pre>

<h2>至此，JRE成功安装。</h2>

<ul>
<li><p>JDK
JDK的安装过程与JRE类似。</p>

<p>  \$ wget -c &#8211;no-check-certificate https://aur.archlinux.org/packages/jd/jdk/jdk.tar.gz <br/>
  \$ tar -zxvf jdk.tar.gz <br/>
  \$ cd jdk <br/>
  \$ makepkg <br/>
  \$ sudo pacman -U ./jdk-7.4-1-i686.pkg.tar.xz <br/>
  loading packages&#8230; <br/>
  resolving dependencies&#8230; <br/>
  looking for inter-conflicts&#8230;</p>

<p>  Targets (1): jdk-7.4-1</p>

<p>  Total Installed Size:   86.05 MiB</p>

<p>  Proceed with installation? [Y/n]  <br/>
  (1/1) checking package integrity                   [&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-] 100% <br/>
  (1/1) loading package files                        [&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-] 100% <br/>
  (1/1) checking for file conflicts                  [&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-] 100% <br/>
  (1/1) checking available disk space                [&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-] 100% <br/>
  (1/1) installing jdk                               [&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-] 100%</p>

<p>  The jdk package is licensed software. <br/>
  You MUST read and agree to the license stored in <br/>
  /usr/share/licenses/jdk/LICENSE before using it. <br/>
  Please relogin to include jdk in your PATH.</p></li>
</ul>


<p>配置
安装之后打开/etc/environment文件编辑，添加如下内容：</p>

<pre><code>#Java SDK 
#
CLASSPATH=.:/opt/java/lib
JAVA_HOME=/opt/java
</code></pre>

<p>添加之后就可以使用java和javac命令了</p>

<pre><code>$ java -version
java version "1.7.0_01"
Java(TM) SE Runtime Environment (build 1.7.0_01-b08)
Java HotSpot(TM) Client VM (build 21.1-b02, mixed mode)
$ javac -version
javac 1.7.0_01   
</code></pre>

<p>更详细的内容可参考<a href="http://sillydong.com/myjava/arch-linux%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AEjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html">傻东の学习笔记</a>
3、解决中文乱码问题，还是用超级用户，进入/usr/share/fonts/wenquanyi，将wqy-zenhei文件夹复制到/opt/java/jre/lib/fonts下，改名为fallback，进入fallback文件夹，终端执行</p>

<pre><code># mkfontdir
和
# mkfontscale
</code></pre>

<p>4、安装eclipse，只需要打开终端执行pacman -S eclipse就可以安装eclipse最新的英文版</p>

<p>5、执行jar文件的办法。在Arch中，jar文件默认是使用归档文件管理器打开的，也就相当于解压缩，而我们需要的是执行这个jar程序，跟我做：在目标jar文件上右击，选择“属性”，找到“打开方式”的标签，选择“添加”，打开“使用自定义命令”，向其中加入下面的命令：</p>

<pre><code>java -jar
</code></pre>

<p>输完之后选择“添加”，这时候在打开方式标签下有两个选择，一种就是原来就有的“归档文件管理器”，还有就是“java”，勾选上“java”，然后关闭，这时候双击jar文件就是执行它了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[arch linux 下lxr的安装]]></title>
    <link href="http://tinyxd.me/blog/2012/05/26/arch-linux-xia-lxrde-an-zhuang/"/>
    <updated>2012-05-26T23:14:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/05/26/arch-linux-xia-lxrde-an-zhuang</id>
    <content type="html"><![CDATA[<p>经过自己两天的折腾，参考了好几个资料终于搞定。
参考资料见文章末尾。
LXR是使用WEB方式下的源代码整理浏览工具，最大的用途在于清理出了代码中函数、变量的定义、说明、应用的关系，并用链接的形式表现在网页上。LXR整理出代码的结构和调用关系，存在数据库中，并在显示时与源代码树结合，从功能上说，包括代码浏览、标识符搜索、文本搜索和文件搜索，其中的文本搜索和文件搜索利用的是第三方工具（即glimpse或swish-e）（我使用的glimpse）。它的主要组成部分包括三个：Perl编写的网页/CGI部分，基于MySQL的索引数据管理（新版本才有）和通用的文本搜索工具。目前的版本，采用Glimpse或者Swish-e中的一种作为通用文本搜索工具。在安装上，基本上也按照这三个部分来配置。</p>

<p>1.下载安装所需的工具。 <br/>
a。glimpse（http://webglimpse.net/download.php）</p>

<p>安装glimpse:（其中会用到flex 安装下就行了）</p>

<pre><code>$ ./configure

$ make

$ sudo make install
</code></pre>

<p>b。pacman -S apache php php-apache mysql</p>

<p>c。pacman -s ctags perl-dbi perl-dbd-mysql</p>

<p>d。安装完mysql 以root用户身份运行设置脚本</p>

<pre><code># rc.d start mysqld &amp;&amp; mysql_secure_installation
</code></pre>

<p>然后重启 Mysql</p>

<pre><code># rc.d restart mysqld
</code></pre>

<p>本文需要设置密码为空（后面有说明）</p>

<!--more-->


<p>用mysql -p -u root</p>

<p>登陆mysql,然后执行下面语句: set password for &#8216;root&#8217;@&#8217;localhost&#8217; =password(&#8221;);flush privileges;e.安装Perl的Magic模块</p>

<p>下载地址http://search.cpan.org/~knok/File-MMagic-1.27/MMagic.pm</p>

<pre><code>[root@localhost File-MMagic-1.27]# ls ChangeLog COPYING      MANIFEST MMagic.pm README.ja contrib    Makefile.PL META.yml README.en t [root@localhost File-MMagic-1.27]# perl Makefile.PL Checking if your kit is complete... Looks good Writing Makefile for File::MMagic [root@localhost File-MMagic-1.27]# ls
ChangeLog COPYING   Makefile.PL META.yml   README.en t
contrib    Makefile MANIFEST     MMagic.pm README.ja

[root@localhost File-MMagic-1.27]# make
cp MMagic.pm blib/lib/File/MMagic.pm
Manifying blib/man3/File::MMagic.3pm
[root@localhost File-MMagic-1.27]# make install
Installing /usr/lib/perl5/site_perl/5.8.8/File/MMagic.pm
Installing /usr/share/man/man3/File::MMagic.3pm Writing /usr/lib/perl5/site_perl/5.8.8/i386-linux-thread-multi/auto/File/MMagic/.packlist Appending installation info to /usr/lib/perl5/5.8.8/i386-linux-thread-multi/perllocal.pod
</code></pre>

<p>2.设置</p>

<p>尽管lxr源码里有一个INSTALL文件，但不详，这里写下来我自己配置的步骤。
1）位置规划
LXR除了数据库那一部分不需要考虑存放位置以外，还有CGI/HTML部分、索引生成工具部分和</p>

<p>所需要索引的源代码部分需要考虑，我的实践中使用的与INSTALL缺省的不同，最大的一点不同在于我</p>

<p>将WEB部分和工具部分分离开，只允许WEB部分暴露给浏览器——主要是基于也许会更安全一些的考虑。
另一个不同是用符号链接而不是真正的源代码目录作为源代码部分，因为LXR索引的Linux Kernel是最常用的，</p>

<p>而Kernel本身还被用来重编内核和升级，所以不适合完全拷贝过来。
本例中使用的是/usr/local/lxr目录作为LXR的根目录。</p>

<pre><code>#tar zxvf lxr-0.9.1.tar.gz -C /usr/local ；将lxr解压到/usr/local/lxr下 
#cd /usr/local/

#mv Local.pm diff ident search source templates  #将web相关部分移到templates下  

#mv templates http                            #http目录，用于存放WEB部分  

#ln -s /usr/local/lxr/http/Local.pm /usr/lib/perl5/site_perl/ 

#ln -s http/lxr.conf         #为web部分和工具部分都需要用的文件建符号连接 
#mv lib /usr/lib/perl5/site_perl/LXR  #将自定义的perl库文件拷贝
</code></pre>

<p>到perl/mod_perl使用的缺省库文件目录中</p>

<pre><code>#ln -s /usr/lib/perl5 /usr/local/lib  #否则在运行时会出现Can't locate LXR/Files.pm等错误 
</code></pre>

<p>建立源代码根目录,（当前在lxr目录）</p>

<pre><code>#mkdir src ；源代码部分的根 

并将 linux-2.6.39的源码链接到此目录下。

#cd src 

mkdir glimpse 

ln -s ../../../../src/linux-2.6.39 2.6.39

#vi versions ；编辑/usr/local/lxr/src/versions文件，内容为2.6.39，表示让lxr索引2.6.39

#cd ../../ ；回到/usr/local/lxr 
</code></pre>

<p>2）修改lxr.conf
准备好了目录结构，下一步就是改写lxr.conf文件。缺省的lxr.conf已经从templates拷贝到/usr/local/lxr/http/下了，</p>

<p>并在/usr/local/lxr/下有个连接。 注释掉所有与swish-e相关的变量定义,其余设置如下</p>

<pre><code>'glimpsebin' =&gt; '/usr/local/bin/glimpse', 

'glimpseindex' =&gt; '/usr/local/bin/glimpseindex', 

'ectagsbin' =&gt; '/usr/bin/ctags', 

'genericconf' =&gt; '/usr/lib/perl5/site_perl/LXR/Lang/generic.conf' 

'ectagsconf' =&gt; '/usr/lib/perl5/site_perl/LXR/Lang/ectags.conf' 

'baseurl' =&gt; 'http://192.168.1.102/lxr'                 #主机的IP地址 

'range' =&gt; [ readfile('/usr/local/lxr/src/versions') ]  

'default' =&gt; '2.6.39'                                  #缺省的代码树名 

# Templates used for headers and footers 下所有路径均设置为绝对路径,如 

'htmlhead' =&gt; '/usr/local/lxr/http/html-head.html' 



'sourceroot' =&gt; '/usr/local/lxr/src'       #源码根目录    (注意，最后无/) 

'sourcerootname' =&gt; 'Linux-$v'        #它将显示在缺省的最高级源码目录上 

'glimpsedir' =&gt; '/usr/local/lxr/src/glimpse'         #(注意，最后无/) 
</code></pre>

<p>3）apache的httpd.conf (/etc/httpd/conf/httpd.conf)
保证装了mod_perl的时候，在httpd.conf中添加以下几行：</p>

<pre><code>Alias /lxr/ /usr/local/lxr/http/ 

&lt;Directory /usr/local/lxr/http/&gt;

AllowOverride None

Options FollowSymLinks

&lt;Files ~  "(search|source|ident|diff|find)$"&gt;

SetHandler perl-script

PerlHandler ModPerl::Registry       #注意这里不是Apache::Registry

Options +ExecCGI

PerlOptions +ParseHeaders

&lt;/Files&gt;

&lt;/Directory&gt; 
</code></pre>

<p>表示访问/lxr就相当于访问/usr/local/lxr/http，且用perl解释search、source、ident、diff和find几个脚本，</p>

<p>而其他的仍然当成html来使用。
如果没有mod_perl，可以用SetHandler cgi-script代替perl-script，一样可以用，PerlHandler就不用了。
4.initialize
1）初始化MySQL数据库 (mysql) :</p>

<p>进入lxr目录/usr/local/lxr</p>

<p># mysql</p>

<p>(反斜杠). initdb-mysql</p>

<p>2).建glimpse索引  <br/>
在/usr/local/lxr/src/2.6.39/下运行&#8217;find . -name &#8220;*.[chS]&#8221; -follow | glimpseindex -H . -o -F&#8217;，索引所有.c、.h、.S（汇编）文件。这个过程比较耗时，但比起下一个过程来，就小巫见大巫了。
3.)建identity索引 这是LXR精髓所在
在/usr/local/lxr/下运行&#8217;./genxref &#8211;version=2.6.39&#8211;url=http://192.168.1.102/lxr&#8217;，这个过程时间比较长，其结果就是在MySQL中添东西。如果已经做过索引了，它就只关心那些修改过的或新的文件，速度就快多了。这个过程如果中断了，最好清空数据库重新来过，否则可能会有错误。  <br/>
4).修改权限  <br/>
最简单的办法就是把/usr/local/lxr/http下所有的文件都改成apache的属主。在/usr/local/lxr/下运行&#8217;chown -R apache.apache http &#8216;。   <br/>
5.startup   (rc.d restart httpd;rc.d restart mysqld) <br/>
重启mysql和httpd，然后访问http://192.168.1.102/lxr/source/就可以了。比较奇怪的是，因为这个cgi允许用类似目录一样的形式（source/）来访问，所以，如果服务器端有更新，浏览器端仍会使用老的页面，refresh也没用。这时只有清空本地cache了。 <br/>
 6.参考博客</p>

<p>[内核分析]LXR安装心得(0.9.3版)&#8212;RH8.0测试通过http://www.cnblogs.com/huqingyu/archive/2005/02/19/106080.html</p>

<p>利用LXR建立源代码交叉索引 【原】http://hi.baidu.com/kissdev/blog/item/6e493daf15cf33c77cd92af9.html</p>

<p>LXR安装过程简介(0.3版) http://blog.chinaunix.net/u1/46901/showart_397299.html</p>

<p>高亮LXR的代码 http://mjxian.cn/wordpress/archives/lxr-syntax-highlighting.html</p>

<p>mysql wiki：https://wiki.archlinux.org/index.php/MySQL_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87</p>

<p>附：部分软件版本</p>

<p>File-MMagic-1.27.tar.gz</p>

<p>perl-dbi-1.616-2-i686.pkg.tar.xz</p>

<p>perl-dbd-mysql-4.020-1-i686.pkg.tar.xz</p>

<p>lxr-0.9.10.tgz</p>

<p>glimpse-4.18.6</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[帮您快速入门TI的Codec Engine]]></title>
    <link href="http://tinyxd.me/blog/2012/05/26/bang-nin-kuai-su-ru-men-tide-codec-engine-zhuan-zai/"/>
    <updated>2012-05-26T06:18:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/05/26/bang-nin-kuai-su-ru-men-tide-codec-engine-zhuan-zai</id>
    <content type="html"><![CDATA[<p>转自TI官网：  <br/>
德州仪器半导体技术（上海）有限公司 通用DSP 技术应用工程师 崔晶</p>

<p>德州仪器（TI）的第一颗达芬奇（DaVinci）芯片（处理器）DM6446已经问世快三年了。继DM644x之后，TI又陆续推出了DM643x，DM35x，DM6467，OMAP353x等一系列ARM＋DSP或ARM＋视频协处理器的多媒体处理器平台。很多有很强DSP开发经验或ARM开发经验的工程师都转到达芬奇或通用OMAP（OMAP353x）平台上开发视频监控、视频会议及便携式多媒体终端等产品。大家都面临着同一个问题，那就是如何实现ARM和DSP或协处理器的通信和协同工作？TI的数字视频软件开发包（DVSDK）提供了Codec Engine这样一个软件模块来实现ARM和DSP或协处理器的协同工作。有很多工程师反馈这个软件模块非常好用，节省了很多开发时间，也有工程师认为TI提供的资料太多，不知如何快速上手。本文将从一个第一次接触Codec Engine的工程师角度出发，归纳TI提供的相关资源（文档，例程和网络资源）并介绍相关开发调试方法帮您快速入门Codec Engine。 <br/>
1．Codec Engine概述 <br/>
Codec Engine是连接ARM和DSP或协处理器的桥梁，是介于应用层（ARM侧的应用程序）和信号处理层（DSP侧的算法）之间的软件模块。ARM应用程序调用Codec Engine的VISA （Video, Image, Speech, Audio）API，如图1中VIDENC_process(a, b, c )。Codec Engine的stub （ARM侧）会把参数a, b, c以及要调用DSP侧process这个信息打包，通过消息队列（message queue）传递到DSP。Codec Engine的skeleton（DSP侧）会解开这个参数包，把参数a, b, c转换成DSP侧对应的参数x, y, z（比如ARM侧传递的是虚拟地址，而DSP只能认物理地址），DSP侧的server（优先级较低，负责和ARM通信的任务）会根据process这一信息创建一个DSP侧的process(x, y, x)任务最终实现VIDENC_process(a, b, c)的操作。 <br/>
2．Codec Engine入门第一步，从Codec Engine发布说明文档(release notes)开始 <br/>
3．Codec Engine入门第二步，了解Codec Engine的运行环境及依赖的软件模块和工具</p>

<p>点击Codec Engine的发布说明文档 的Validation Info，我们可以知道Codec Engine 1.20需要和以下软件模块和工具配合使用：</p>

<pre><code>Framework Components 1.20.02   
xDAIS 5.21   
XDC Tools 2.93.01   
DSP/BIOS Link 1.40.05, configured for the DM6446 EVM   
C6x Code Generation Tools version 6.0.8   
DSP/BIOS 5.31.05   
MontaVista Linux v4.0   
Red Hat Enterprise Linux 3 (SMP)    
</code></pre>

<p>因此，我们需要在该Codec Engine安装的DVSDK文件包下面检查上面提到的软件模块和工具是否安装，版本是否正确。否则，可能会编译不过 Codec Engine的例子。那么，什么是 Framework Components，什么是xDAIS，什么又是XDC Tools呢？你可以分别到它们的根目录下浏览它们各自的发布说明文档，做一个总体的了解。</p>

<!--more-->


<p>这里我们简单介绍一下，可以帮助大家尽快找到和自己相关的重点及资源。</p>

<p>1） Framework Components是TI提供的一个软件模块，负责DSP侧的memory 和DMA资源管理。因此，DSP算法工程师需要了解这个软件模块。 <br/>
http://tiexpressdsp.com/wiki/index.php?title=Framework_Components_FAQ <br/>
2） xDAIS 是一个标准，它定义了TI DSP算法接口的标准。这样大大提高了DSP算法软件的通用性。DSP算法工程师要写出能被ARM通过Codec Engine调用的算法，必须保证自己的算法接口符合这个标准。因此，DSP算法工程师也必须了解这个软件模块。</p>

<p>http://tiexpressdsp.com/wiki/index.php?title=Category:XDAIS</p>

<p>3） XDC Tools和gmake类似，是一个工具。XDC根据用户定义的一套build指令，通过调用用户指定的ARM 工具链（Tool Chain）和DSP编译器（C6x Code Generation Tools ）build出ARM侧和DSP侧的可执行文件。可以先不必细究这个工具，只需通过编Codec Engine的例子，知道如何设置build指令就可以了。</p>

<p>4） DSP/BIOS Link是实现ARM和DSP之间通信的底层软件，Codec Engine就是建立在这个底层软件之上。在修改系统内存分配（缺省是256MB的DDR2）时，DSP/BIOS Link 1.38版本的用户需要修改DSP/BIOS Link的配置文件，并重新build DSP/BIOS Link。而DSP/BIOS Link 1.40版本以后的用户就无需此操作。</p>

<p>http://tiexpressdsp.com/wiki/index.php?title=DSPLink_Overview <br/>
http://wiki.davincidsp.com/index.php?title=Changing_the_DVEVM_memory_map</p>

<p>5） C6x Code Generation Tools是Linux环境下C6000系列DSP的编译器。我们用CCS开发DSP时都是用的Windows环境下的DSP编译器。</p>

<p>6） DSP/BIOS是TI 免费提供的DSP实时操作系统。和上面C6x Code Generation Tools一样，这里的DSP/BIOS也是Linux环境下的版本。DSP系统工程师需要了解这个操作系统。</p>

<p>http://tiexpressdsp.com/wiki/index.php?title=Category:DSPBIOS</p>

<p>4．Codec Engine入门第三步，根据自己的角色参考相关的文档和例子进行开发</p>

<p>开发ARM＋DSP平台需要三类工程师：ARM应用程序工程师、DSP算法工程师和DSP系统工程师。而开发ARM＋协处理器平台只需要ARM应用程序工程师。下面就让我们针对这三类工程师做分别介绍。如果您使用的是TI或TI第三方的编解码算法，就不需要关注DSP算法工程师的部分。如果使用ARM＋协处理器平台，就只需关心ARM应用工程师的部分。</p>

<p>4．1 DSP算法工程师应该如何着手？ <br/>
这里我们不讨论如何开发DSP算法，只讨论DSP算法工程师怎样让自己的算法可以被ARM通过Codec Engine调用。（参考http://www.ti.com/litv/pdf/sprued6c，这个文档会讲到codec package及相关的.xs和.xdc文件，Codec Engine1.20及以上版本的用户可以先不细究这些内容，后面会介绍工具帮您自动生成这些文件。）</p>

<p>1） 熟悉xDAIS和xDM标准。 <br/>
xDM只是xDAIS的扩展，因此，需要先了解xDAIS。在xDAIS 软件包根目录下的发布说明文档里，可以很快找到关于xDAIS和xDM的文档链接。 <br/>
http://focus.ti.com/lit/ug/spruec8b/spruec8b.pdf <br/>
在xDAIS安装路径下的examples/ti/xdais/dm/examples/g711有一个g711_sun_internal.c，这个算法不符合xDAIS标准。在同一个路径下的g711dec_sun_ialg.c (decoder)和g711enc_sun_ialg.c (encoder)是封装成符合xDM标准之后的编解码算法。可以通过这个例子学习和了解如何把自己算法封装成符合xDM标准的算法。 <br/>
xDAIS 6.10及其以后的版本，包含了一个工具QualiTI，可以检查您的DSP算法是否满足xDAIS标准（但不会检查是否满足xDM）。具体请参考：
http://tiexpressdsp.com/wiki/index.php?title=QualiTI_XDAIS_Compliance_Tool</p>

<p>2） 熟悉Framework Components。 Framework Components主要包括两个模块DSKT2和DMAN3，它们分别负责DSP侧的memory 和EDMA资源管理。DSP算法使用的memory必须是先向DSKT2提出申请并由DSKT2分配得到的。同样DSP算法使用的EDMA通道也是向DMAN3申请并由DMAN3分配得到的。而关于QDMA的操作，是通过ACPY3这个模块实现的。这样的好处是很容易对DSP侧不同的算法做整合，不同的算法之间不用担心资源（Memory和EDMA）的冲突问题。 <br/>
在Framework Components 软件包根目录下的发布说明文档里，可以很快找到相关文档的链接。在Framework Components安装路径下packages\ti\sdo\fc\dman3\examples有一个Fast Copy的例子，可以帮您理解如何基于Framework Components的ACPY3模块实现QDMA的操作。
另外，有些用户DSP侧的算法比较简单，在确保不和ARM侧EDMA资源冲突的前提下在算法里直接操作EDMA不使用DMAN3也是可以的。这样做的弊端是和其它算法做整合时会遇到资源使用冲突的问题。</p>

<p>4．2 DSP系统工程师应该如何着手？ <br/>
通常DSP算法工程师都会把自己的符合xDM标准算法编成一个.lib文件（或 .a64P），供DSP系统工程师调用。DSP系统工程师最终build出一个DSP Server（也就是DSP的可执行程序.x64P，和CCS下编译生成的.out类似）。（参考http://focus.ti.com/lit/ug/sprued5b/sprued5b.pdf，这个文档会讲到.xdc和.bld等文件，Codec Engine1.20及以上版本的用户可以先不细究，后面介绍工具帮您自动生成这些文件。）</p>

<p>1） 如果现在有一个.lib文件（或 .a64P）（算法必须符合xDM标准），如何生成自己的DSP Server呢？下面URL有详细的关于RTSC Codec and Server Package Wizard工具介绍，教您如何把一个.lib文件封装成RTSC Codec 包和RTSC DSP Server包，并最终build出DSP的可执行程序.x64P。 <br/>
http://wiki.davincidsp.com/index.php?title=RTSC_Codec_And_Server_Package_Wizards
http://wiki.davincidsp.com/index.php?title=I_just_want_my_video_codec_to_work_with_the_DVSDK</p>

<p>2） 如果您使用的是Codec Engine 1.20以前的版本，请参考Codec Engine安装路径下examples/servers/video_copy这个例子。这时就需要搞清楚sprued6c.pdf和sprued5b.pdf中提到的.xdc和.xs等文件的功能，也可以在video_copy中的相关文件的基础上修改手动创建出自己的RTSC Codec包和RTSC DSP server包。</p>

<p>3） 创建好RTSC Codec 和RTSC DSP Server包之后，就是如何build出.x64P的问题了。点击图2所示的Examples，就可以找到build Codec Engine例子的说明文档的链接。按照这个文档做一遍后，就可以对如何build Codec Server有一个清楚的了解。其中关键是修改user.bld和xdcpaths.mak文件，设置Codec Engine依赖的其它软件模块和工具的正确路径。</p>

<p>4） 如果自己的硬件DDR2大小和例子中的256Mbytes不一致，需要修改DSP的.tcf文件和其他配置。还有些工程师不清楚如何分配memory及如何决定具体段，如：DDRALGHEAP和DDR的大小，以及如何配置./loadmodules里的参数都请参考： http://wiki.davincidsp.com/index.php?title=Changing_the_DVEVM_memory_map。</p>

<p>4．3 ARM应用程序工程师应该如何着手？ <br/>
ARM应用工程师需要调用Codec Engine的VISA API，最终编出ARM侧的可执行程序，因此，必须根据自己的应用学习相关的VISA API、如何创建应用侧Codec Engine的package及配置文件。（参考http://focus.ti.com/lit/ug/sprue67d/sprue67d.pdf，这个文档也涉及到如何调试Codec Engine的内容）。</p>

<p>1）了解ARM应用程序调用Codec Engine的流程、VISA API和其他Codec Engine API。可以参考Codec Engine安装路径下examples/apps/video_copy的例子（较简单）或者DVSDK安装路径下demos里的encode/decode/encodedecode例子（较复杂）。
http://wiki.davincidsp.com/index.php?title=Configuring_Codec_Engine_in_Arm_apps_with_createFromServer
2） 了解ceapp.cfg文件。sprue67d.pdf有相关介绍，可以先读懂 <br/>
examples/apps/video_copy/ceapp.cfg。</p>

<p>3） 用4.2 3)中提到的方法学习如何build ARM侧的可执行程序。</p>

<p>4） 如何在多线程中调用codec engine，参考： <br/>
http://wiki.davincidsp.com/index.php?title=Multiple_Threads_using_Codec_Engine_Handle</p>

<p>5）还可以参考以下三个文档了解更多TI demo的ARM应用程序的结构、线程调度等具体的问题。</p>

<p>EncodeDecode Demo for the DaVinci DVEVM/DVSDK 1.2 (Rev. A) (spraah0a.htm, 8 KB)<br/>
27 Jun 2007 Abstract</p>

<p>Encode Demo for the DaVinci DVEVM/DVSDK 1.2 (Rev. A) (spraa96a.htm, 8 KB)<br/>
27 Jun 2007 Abstract</p>

<p>Decode Demo for the DaVinci DVEVM/DVSDK 1.2 (Rev. A) (spraag9a.htm, 8 KB)<br/>
27 Jun 2007 Abstract</p>

<p>5．使用中常碰到的问题</p>

<p>1）如果遇到问题可以先访问 http://wiki.davincidsp.com/index.php?title=Codec_Engine_FAQ。<br/>
2）有些工程师没有DSP开发经验，或者暂时没有仿真器通过JTAG调试DSP。可以参考下面网页的内容，先做一个“Hello World”的例程对ARM和DSP如何协同工作有个感性认识。</p>

<p>http://wiki.davincidsp.com/index.php?title=How_to_build_an_ARM/DSP_Hello_World_program_on_the_DaVinci_EVM</p>

<p>3） 很多工程师都是参考video_copy的例子，在它的基础上把自己的算法加进去。因为有源代码，这样比较容易。但肯定要根据自己算法的需要修改ARM和DSP之间传递的buffer和参数，重要的是先保证ARM侧的应用程序可以把buffer和参数正确传递到DSP，DSP可以把处理之后的buffer正确的传到ARM侧的应用程序。把这个通路打通之后，就比较容易定位问题是出在ARM应用程序还是DSP侧的算法。另外，参考video_copy例子时注意代码的注释，以便清楚哪一句代码可以删掉哪一句必须要修改或保留。</p>

<p>如果要扩展xDM的数据结构请参考：</p>

<p>http://wiki.davincidsp.com/index.php?title=Extending_data_structures_in_xDM。</p>

<p>4） Codec Engine DSP侧会涉及到Cache一致性的问题。请参考： <br/>
http://wiki.davincidsp.com/index.php?title=Cache_Management</p>

<p>5） 关于Codec Engine系统调试，有以下几种方法：</p>

<pre><code>    A. 打开Codec Engine trace，通过打印信息看问题出在什么地方。比如engine_open失败，DSP侧不能创建codec 等等。   

        a) Codec Engine 2.0及以上版本，请参考： http://wiki.davincidsp.com/index.php?title=Easy_CE_Debugging_Feature_in_CE_2.0   

        b) Codec Engine 1.x版本，请参考： http://wiki.davincidsp.com/index.php?title=TraceUtil   

    B. ARM应用程序跑起来后，用仿真器连上CCS调试DSP侧程序，参考： http://wiki.davincidsp.com/index.php?title=Debugging_the_DSP_side_of_a_CE_application_on_DaVinci_using_CCS   

    C. 用Soc Analyzer可以做系统调试之外，还可以统计具体函数运行（ARM和DSP侧）时间（benchmark）。请参考： http://tiexpressdsp.com/wiki/index.php?title=SoC_Analyzer    
</code></pre>

<p>6） 因为Codec Engine是介于ARM 应用程序和编解码算法中间的软件模块，很多工程师非常想知道它的开销(overhead)，请参考： <br/>
http://wiki.davincidsp.com/index.php?title=Codec_Engine_Overhead</p>

<p>7）如何在Linux环境下编DSP的汇编或线性汇编程序？ <br/>
在Codec Engine安装路径下/packages/config.bld文件里 <br/>
var C64P = xdc.useModule(‘ti.targets.C64P’); <br/>
之后添加：</p>

<pre><code>C64P.extensions[“.sa”] = {
suf: “.sa”, typ: “asm:-fl”
}
</code></pre>

<p>或</p>

<pre><code>C64P.extensions[“.asm”] = {
suf: “.asm”, typ: “asm:-fa”
}
</code></pre>

<p>8）DSP侧如何统计具体函数运行时间？ <br/>
TI DSPC64x+内核有一个64位的硬件定时器（Time Stamp Counter），它的频率和CPU频率一致。 <br/>
最简单的办法是使用TSC的低32位TSCL。注意在DM644x中，TSCH用于ARM。</p>

<pre><code>#include void main (){
…
TSCL=0;
…
t1=TSCL;
my_code_to_benchmark();
t2=TSCL;
printf(“# cycles == %d\n”, (t2-t1));
}
</code></pre>

<p>6．结语</p>

<p>以上针对如何上手TI的Codec Engine做了简单的归纳，还有很多具体细节的问题没有涉及到。还请各位工程师从自己要用的软件模块发布说明文档开始找到相关的文档并研究。经常访问TI的网页，http://wiki.davincidsp.com和http://tiexpressdsp.com/wiki找到最新的信息和资料。也非常欢迎您在wiki上提问。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[archbang arch linux 安装inode ]]></title>
    <link href="http://tinyxd.me/blog/2012/05/25/archbang-arch-linux-an-zhuang-inode/"/>
    <updated>2012-05-25T14:34:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/05/25/archbang-arch-linux-an-zhuang-inode</id>
    <content type="html"><![CDATA[<p>第一步：cp iNodeClient.tar.gz 到 /home/***** 目录下。进入~目录下  <br/>
第二步：终端运行 tar -xvf iNodeClient.tar.gz。<br/>
第三步：修改/home//iNodeClient/下install.sh，把 OS_UBUNTU=`cat /etc/issue | grep &#8216;Ubuntu&#8217;`那一行及以下的脚本都删除，然后保存，执行sudo ./install.sh。<br/>
第四步：cp  home/*****/iNodeClient/ 目录下的iNodeAuthService到/etc/rc.d/目录下，并修改权限chmod 755 /etc/rc.d/iNodeAuthService。<br/>
第五步：打开/etc/rc.conf ，在DAEMONS处添加@iNodeAuthService。（让iNode认证服务开机自启动） <br/>
第六步：现在执行sudo /etc/rc.d/iNodeAuthService start，发现出错了。错误出现在enablecards.ps这个文件里，打开看，你会发现这个文件的作用只是用来up网卡。一般来说你的网卡都已经up了的啦。你可以把里面的内容改成： <br/>
#!/bin/sh<br/>
x=eth0（你所使用的网卡） <br/>
ifconfig $x up  <br/>
再运行一次sudo /etc/rc.d/iNodeAuthService start，你应该会发现服务启动成功了。  <br/>
第七步：命令行里面执行一下sudo ./iNodeClient 然后楼主发现出现了一些库的依赖问题。iNode需要一些比较旧的库，对于jpeg tiff等库 你可以用ln -s 来用新版本的库代替旧版本。而其中有一个是libpng12.so.0是必须需要旧版本的。见附件 或者可以去官网自己下载ftp://ftp.simplesystems.org/pub/libpng/png/src/  <br/>
需要下载的文件是libpng-1.2.49.tar.bz2 <br/>
安装方法如下： <br/>
1.解压，然后执行./configure &#8211;prefix=/usr/ <br/>
2.编译及安装 <br/>
#make  <br/>
#make install <br/>
安装之前可以make check 以下 看看有没有什么错误，如果没错误 make install 那么libpng就安装好了。</p>

<p>参考：http://ecnc.sysu.edu.cn/viewthread.php?tid=18558</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为已经存在的github Octopress配置本地环境]]></title>
    <link href="http://tinyxd.me/blog/2012/05/23/wei-yi-jing-cun-zai-de-github-octopresspei-zhi-ben-di-huan-jing/"/>
    <updated>2012-05-23T20:59:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/05/23/wei-yi-jing-cun-zai-de-github-octopresspei-zhi-ben-di-huan-jing</id>
    <content type="html"><![CDATA[<p><strong>转自：</strong><br/>
http://www.360doc.com/content/12/0520/19/3565338_212362686.shtml</p>

<p>本文介绍如何为已经存在于github上的octopress配置本地环境。<br/>
在本地安装RVM(Ruby Version Manager)和Ruby 1.9.2；</p>

<p>从你的github得到你的octopress内容：</p>

<pre><code>git clone -b source git@github.com:username/username.github.com.git octopress # get the source code from your "source" branch of your octopress on github
＃ learn from: http://stackoverflow.com/questions/1911109/git-clone-a-specific-branch
cd octopress
git clone git@github.com:username/username.github.com.git _deploy # get your static pages content from your "master"branch of your cotopress on github
</code></pre>

<!--more-->


<p>安装依赖gems:</p>

<pre><code>gem install bundler # Install dependencies   
bundle install   #如果出现bundle命令没找到，还需要修改～/.bashrc
vim ~/.bashrc
#for ruby gem
PATH=$PATH:~/.gem/ruby/1.9.1/bin
export PATH
rake install # Install the default Octopress theme  不需要 因为我已经有了自己的主题   
rake setup_github_pages #需要这个 要不然rake deploy会出错   
</code></pre>

<p>这就基本结束了。</p>

<p>编写文章，预览部署：</p>

<pre><code>cd octopress
rake new_post["Your Title of Your Article"]
rake generate # generate your blog static pages content according to your input. 
rake preview # start a web server on "http://localhost:4000", you can preview your blog content.
rake deploy # push your static pages content to your github pages repo ("master" branch)
</code></pre>

<p>提交你的文本修改到github:</p>

<pre><code>cd your_local_octopress_directory
git add .
git commit -m 'your message'
git push origin source
</code></pre>

<p>注意：如果要从github得到最新的source内容，请运行以下命令：</p>

<pre><code>cd your_local_octopress_directory
cd _deploy
git pull origin master
cd ..
git pull origin source
</code></pre>

<p>原则很简单，只要记住“your_local_octopress_directory”对应的的remote source branch，而”_deploy”对应的是remote master branch即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress:新手教程]]></title>
    <link href="http://tinyxd.me/blog/2012/05/23/octopress-xin-shou-jiao-cheng/"/>
    <updated>2012-05-23T20:55:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/05/23/octopress-xin-shou-jiao-cheng</id>
    <content type="html"><![CDATA[<p><em>转载自：</em><br/>
http://geekontheway.github.com/blog/2011/12/03/octopress-for-freshman/<br/>
Octopress基于jekyll，刚开始使用起来也比较复杂：</p>

<pre><code>Octopress会有两个分支：source（编写博客）和master（生成好的博客），就像这样：

git remote -v

octopress git://github.com/imathis/octopress.git (fetch)
octopress git://github.com/imathis/octopress.git (push)
origin    git@github.com:geekontheway/geekontheway.github.com.git (fetch)
origin    git@github.com:geekontheway/geekontheway.github.com.git (push)


git branch -a

* source
  remotes/octopress/HEAD -&gt; octopress/master
  remotes/octopress/compass
  remotes/octopress/configuration
  remotes/octopress/edge
  remotes/octopress/generate_environment
  remotes/octopress/gh-pages
  remotes/octopress/master
  remotes/octopress/move_rakefile_configs
  remotes/octopress/post_names
  remotes/octopress/rake_minify_js
  remotes/octopress/refactor_code_highlight
  remotes/octopress/refactor_deployment
  remotes/octopress/refactor_js
  remotes/octopress/site
  remotes/octopress/site-deploy-test
  remotes/octopress/subdir
remotes/octopress/thor
</code></pre>

<p>其中只有origin仓库和source分支是必须的，其余分支或仓库建议删掉。</p>

<!--more-->


<p>我们来看一下source分支都有什么：</p>

<pre><code>CHANGELOG.markdown  
config.ru   
 _deploy  部署文件夹，在.gitignore中被设置了
.DS_Store 文件夹显示属性，在.gitignore中被设置了
Gemfile.lock  
.gitignore  
plugins  
.pygments-cache   
.rbenv-version Ruby版本有特殊要求 这个文件在.gitignore中被设置了   
.rvmrc   Ruby版本有特殊要求
.sass-cache  
source
config.rb           
_config.yml  
Gemfile  
.git          
.idea   Rubymine设置文件，在.gitignore中被设置了    
public  在.gitignore中被设置了  
Rakefile         
README.markdown  
sass    
.slugignore  
.themes
</code></pre>

<p>其中_deploy,source,public这三个文件夹很有趣：</p>

<pre><code>如果你是和别人合作博客，或者自己同时在好几个电脑上写博客，每次开始之前，git pull origin source获得最新的文件,rake generate生成新的页面

我们在source分支做了博客的发布，或者改变了博客的设置之后，rake generate生成网站

rake watch+pow 或者rake review+http://localhost:4000就可以看到我们所做的变化

确认无误后，rake deploy文章就发布到了博客中

当然，不要忘了更新项目 git push origin source

特别的，如果你克隆了博客，记得在git checkout source，然后rake setup_github_pages执行初始化，当然，在那之前也需要bundle install，然后rake generate就生成页面了.

如果是新建的Repo ，记得


$ mkdir yourrepo
$ cd yourrepo
$ git init
# 其实这这时如果你多新建一个index.html文件的话，github会为你生成一个jekyll博客。
$ touch README
$ git add .
$ git commit -m 'first commit'
$ git remote add origin git@github.com:username/yourname.github.com.git
$ git push origin master
</code></pre>

<p>对于新手有几个提醒: <br/>
1.时常git status,git log避免误操作<br/>
2.不要在github上直接编辑文件<br/>
3.想清楚了再下手<br/>
4.github pages的 username 大小写敏感。如果用户名和username不一致的话,默认会生成这个Repo的project pages。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress添加图片]]></title>
    <link href="http://tinyxd.me/blog/2012/05/23/octopresstian-jia-tu-pian/"/>
    <updated>2012-05-23T20:49:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/05/23/octopresstian-jia-tu-pian</id>
    <content type="html"><![CDATA[<p>If you like Markdown’s syntax for images, you’ll love the simplicity of the Octopress image tag.</p>

<p>Syntax</p>

<blockquote><p>img [class names] /path/to/image [width] [height] [title text [alt text]]</p></blockquote>

<p>Don’t forget brace and percent couple.</p>

<!--more-->


<p>Examples</p>

<blockquote><p>img http://placekitten.com/890/280 <br/>
img left http://placekitten.com/320/250 Place Kitten #2 <br/>
img right http://placekitten.com/300/500 150 250 Place Kitten #3 <br/>
img right http://placekitten.com/300/500 150 250 ‘Place Kitten #4’ ‘An image of a very cute kitten’</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress安装笔记]]></title>
    <link href="http://tinyxd.me/blog/2012/05/23/octopressan-zhuang-bi-ji/"/>
    <updated>2012-05-23T07:16:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/05/23/octopressan-zhuang-bi-ji</id>
    <content type="html"><![CDATA[<p>在阅读此教程之前，先安装git和ruby环境。</p>

<p><strong>1.安装ruby环境</strong></p>

<p>如果已经安装了ruby,就不用安装rvm 了。
Archlinux用户建议用pacman 安装ruby,方便省事。</p>

<p>Archlinux安装RVM教程：
<a href="https://wiki.archlinux.org/index.php/RVM">archlinux安装RVM教程</a></p>

<pre><code>[tinyxd@archbang  ~]$ sudo bash &lt; &lt;(curl -s https://raw.github.com/wayneeseguin/rvm/master/binscripts/rvm-installer )
</code></pre>

<p>添加当前用户到rvm 组</p>

<pre><code>[tinyxd@archbang  ~]$ sudo usermod -a -G rvm admin
</code></pre>

<p>查看下添加成功了没：</p>

<pre><code>[tinyxd@archbang ~]$ grep rvm /etc/group
rvm:x:1004:admin
</code></pre>

<p>再注销，登录。</p>

<blockquote><p>To start using RVM you need to run <code>source /etc/profile.d/rvm.sh</code> in all your open shell windows, in rare cases you need to reopen all shell windows.</p></blockquote>

<p>已经安装了ruby的就可以从这里开始了。</p>

<!--more-->


<p><strong>2.安装依赖</strong></p>

<pre><code>[tinyxd@archbang ～]$ gem install bundler
WARNING:  You don't have /home/tinyxd/.gem/ruby/1.9.1/bin in your PATH,
      gem executables will not run.
vim ~/.bashrc
#for ruby gem
PATH=$PATH:~/.gem/ruby/1.9.1/bin
export PATH
</code></pre>

<p>注意路径后面不能带/，不然它还是会报错。</p>

<pre><code>[tinyxd@archbang ~]$ sudo gem install bundler
[tinyxd@archbang ~]$ cd ovtopress/
[tinyxd@archbang ~]$ bundle install
[tinyxd@archbang ~]$ rake install 
rake aborted!
You have already activated rake 0.9.2.2, but your Gemfile requires rake 0.9.2. Using bundle exec may solve this.

(See full trace by running task with --trace)
</code></pre>

<p>出现上述问题，按以下方法解决：</p>

<pre><code>bundle update
rake install
[tinyxd@archbang octopress]$ rake install
## Copying classic theme into ./source and ./sass
mkdir -p source
cp -r .themes/classic/source/. source
mkdir -p sass
cp -r .themes/classic/sass/. sass
mkdir -p source/_posts
mkdir -p public
</code></pre>

<p><strong>3.Deploying to Github Pages</strong></p>

<p>http://octopress.org/docs/deploying/github/</p>

<p>首次deploy 之前的准备活动
创建 username.github.com 仓库
执行rake setup_github_pages来设置。</p>

<pre><code>[tinyxd@archbang octopress]$ rake setup_github_pages
Enter the read/write url for your repository: git@github.com:akm/akm.github.com.git
Added remote git@github.com:akm/akm.github.com.git as origin
Set origin as default remote
Master branch renamed to 'source' for committing your blog source files
rm -rf _deploy
mkdir _deploy
cd _deploy
Initialized empty Git repository in /home/admin/public_html/octopress/_deploy/.git/
[master (root-commit) ff105cf] Octopress init
 1 file changed, 1 insertion(+)
 create mode 100644 index.html
cd -

---
## Now you can deploy to http://ihacklog.github.com with `rake deploy` ##
</code></pre>

<blockquote><p>This will:Ask you for your Github Pages repository url.Rename the remote pointing to imathis/octopress from ‘origin’ to ‘octopress’.Add your Github Pages repository as the default origin remote.Switch the active branch from master to source.Configure your blog’s url according to your repository.Setup a master branch in the _deploy directory for deployment.</p></blockquote>

<p>生成静态页面：</p>

<pre><code>[tinyxd@archbang octopress]$ rake generate
</code></pre>

<p>把源码push搭配github上</p>

<pre><code>git add .
git commit -m "commit the source for my Octopress blog"
git push origin source
</code></pre>

<p>Configuring Octopress配置略，见 http://octopress.org/docs/configuring/</p>

<p>写日志</p>

<pre><code>rake new_post["文章标题"] #新建页面
rake new_page[super-awesome]
</code></pre>

<p>详见 http://octopress.org/docs/blogging/
写完了之后</p>

<pre><code>rake generate
rake deploy
</code></pre>

<p>如果想本地预览一下效果，可以用</p>

<pre><code>rake preview
</code></pre>

<p>要注意的是，如果修改源码和配置，是在source 分支修改和提交。
而发布日志，也是在source分支，rake deploy会自动将生成的静态页面push到master分支。因此，master分支的内容不用你管。</p>

<blockquote><p>插一句：如果以后要从另一个电脑pull源码来新电脑，用如下命令：</p>

<pre><code>cd your_local_octopress_directory
cd _deploy
git pull origin master
cd ..
git pull origin source
</code></pre>

<p>只要记住“your_local_octopress_directory”对应的的remote source branch，而”_deploy”对应的是remote master branch即可。</p>

<p>   如果你是和别人合作博客，或者自己同时在好几个电脑上写博客，每次开始之前，git pull origin source获得最新的文件,rake generate生成新的页面</p></blockquote>

<pre><code>我们在source分支做了博客的发布，或者改变了博客的设置之后，rake generate生成网站

rake watch+pow 或者rake review+http://localhost:4000就可以看到我们所做的变化

确认无误后，rake deploy文章就发布到了博客中

当然，不要忘了更新项目 git push origin source

特别的，如果你克隆了博客，记得在git checkout source，然后rake setup_github_pages执行初始化，当然，在那之前也需要bundle install，然后rake generate就生成页面了.

如果是新建的Repo ，记得
$ mkdir yourrepo
$ cd yourrepo
$ git init
# 其实这这时如果你多新建一个index.html文件的话，github会为你生成一个jekyll博客。
$ touch README
$ git add .
$ git commit -m 'first commit'
$ git remote add origin git@github.com:username/yourname.github.com.git
$ git push origin master
</code></pre>

<blockquote><p>对于新手有几个提醒:</p></blockquote>

<pre><code>时常git status,git log避免误操作
不要在github上直接编辑文件
想清楚了再下手
</code></pre>

<blockquote><p>  github pages的 username 大小写敏感。如果用户名和username不一致的话,默认会生成这个Repo的project pages。</p></blockquote>

<p>rake watch 检测文件变化，实时生成新内容
rake preview 监听本机4000端口，可查看生成页面效果。</p>

<p>个性化
文档： http://octopress.org/docs/theme/template/
修改定制文件/source/_includes/custom/head.html 把google的自定义字体去掉或自行定义，如我的（自己下载了google font)：
1
2</p>

<p><link href="http://tinyxd.me/assets/font/PT_Serif.css" rel="stylesheet" type="text/css">
<link href="http://tinyxd.me/assets/font/PT_Sans.css" rel="stylesheet" type="text/css"></p>

<p>我把下载的google font放在 source/assets/font 目录下面。</p>

<p>图片发布
我把图片放在source/static 目录。
在文章中引用（注意URL前面的/)：</p>

<pre><code>![ Ultrablog.vim post title bug ](/static/2012/04/UltraBlog-post-title-bug.png)
</code></pre>

<p>个性域名
先去给域名建立一个CNAME记录，指向 username.github.com ,如 ihacklog.github.com
在source目录下建一个名为CNAME的文件，然后将自己的域名输入进去
如：</p>

<p>tinyxd.tk</p>

<p>文档： http://help.github.com/pages/</p>

<p>其它，如sidebar的修改等，可参考文档。http://octopress.org/docs/theme/template/
我这就不写了。 <br/>
主题的修改参考了这篇文章<a href="http://melandri.net/2012/02/14/octopress-theme-customization/">Octopress Theme Customization</a>，以后自己研究下css，做个自己的。</p>

<p>其它可参考的文章： http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/</p>

<p><strong>一些技术：</strong><br/>
https://github.com/mojombo/jekyll 静态页面发布技术，使用 Textile or Markdown and Liquid converters，是Github页面引擎背后的技术。<br/>
http://daringfireball.net/projects/markdown/ 简单的标记语言，现在很多编辑器支持，快速编写并可编译成HTML、LaTeX等格式。<br/>
http://gembundler.com/ 将一个应用需要的Ruby软件包写入一个Gemfile文件，当应用安装时可以用Bundle命令自动从服务器上下载需要的软件包。<br/>
http://rack.rubyforge.org/ 基于Ruby的web服务器界面。<br/>
http://pow.cx/ 配置好的Rack服务，即开即用。<br/>
http://rake.rubyforge.org/ 用Ruby写成的Make，批处理操作。<br/>
http://sass-lang.com/ CSS3扩展，方便编写CSS并提供更多功能。<br/>
http://ethanschoonover.com/solarized 一套便于阅读的代码配色方案。<br/>
https://github.com/ 代码平台，基于git。<br/>
http://www.heroku.com/ 云计算平台，发布非常方便。</p>
]]></content>
  </entry>
  
</feed>
