<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Keen on Art of Tech]]></title>
  <link href="http://tinyxd.me/atom.xml" rel="self"/>
  <link href="http://tinyxd.me/"/>
  <updated>2012-07-04T12:19:53+08:00</updated>
  <id>http://tinyxd.me/</id>
  <author>
    <name><![CDATA[Tiny]]></name>
    <email><![CDATA[admin@tinyxd.me]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[vc debug 变 release]]></title>
    <link href="http://tinyxd.me/blog/2012/07/03/vc-debug-release/"/>
    <updated>2012-07-03T12:23:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/03/vc-debug-release</id>
    <content type="html"><![CDATA[<p>今天遇到将debug改为release版本出现好多问题，最后一一解决，现将方法贴到下面 <br/>
生成release版的步骤： <br/>
1.首先修改<code>project-setting-general-using mfc in a static libraryproject-setting</code>右键点击菜单空白处——选择“组建”——选择“Win32 Release“——重新编译链接。 <br/>
2.然后<code>project-setting -c++ -precompiled Headers- not using</code> <br/>
最后出现这个错误</p>

<pre><code>nafxcwd.lib(afxmem.obj) : error LNK2005: "void __cdecl operator delete(void *)" (??3@YAXPAX@Z) already defined in LIBCMTD.lib(dbgdel.obj)   
</code></pre>

<p>关于静态库引发 nafxcw.lib LNK2005 错误的解决方法</p>

<!--more-->


<p>解决方法，进入vc6 选择菜单：</p>

<pre><code>project -&gt; settings -&gt; link -&gt; Category : input   -&gt; Object/library modeules ,
</code></pre>

<p>输入：nafxcw.lib 即可。 <br/>
原因：必须先编译这个库，才能避免函数名字重复引用。</p>

<br />


<p>Note：记住rebuiled</p>

<br />


<p>附：debug版本和release版本的区别： <br/>
Debug 通常称为调试版本，它包含调试信息，并且不作任何优化，便于程序员调试程序。Release 称为发布版本，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用。Debug 和 Release 的真正秘密，在于一组编译选项。下面列出了分别针对二者的选项</p>

<br />


<p>Debug 版本：</p>

<blockquote><p>/MDd /MLd 或 /MTd 使用 Debug runtime library(调试版本的运行时刻函数库)<br/>/Od 关闭优化开关<br/>/D &#8220;_DEBUG&#8221; 相当于 #define _DEBUG,打开编译调试代码开关(主要针对assert函数)<br/>/ZI 创建 Edit and continue(编辑继续)数据库，这样在调试过程中如果修改了源代码不需重新编译<br/>/GZ 可以帮助捕获内存错误<br/>/Gm 打开最小化重链接开关，减少链接时间</p></blockquote>


<br />


<p>Release 版本：</p>

<blockquote><p>/MD /ML 或 /MT 使用发布版本的运行时刻函数库<br/>/O1 或 /O2 优化开关，使程序最小或最快<br/>/D &#8220;NDEBUG&#8221; 关闭条件编译调试代码开关(即不编译assert函数)<br/>/GF 合并重复的字符串，并将字符串常量放到只读内存，防止 被修改</p></blockquote>


<p></p>

<br />


<p> 实际上，Debug 和 Release 并没有本质的界限，他们只是一组编译选项的集合，编译器只是按照预定的选项行动。事实上，我们甚至可以修改这些选项，从而得到优化过的调试版本或是带跟踪语句的发布版本。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress博客添加flickr侧边栏]]></title>
    <link href="http://tinyxd.me/blog/2012/07/02/add-flickr-aside-in-octopress/"/>
    <updated>2012-07-02T11:14:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/02/add-flickr-aside-in-octopress</id>
    <content type="html"><![CDATA[<p>octopress添加侧边栏： <br/>
1.新建 <code>source/_includes/custom/asides/flickr.html</code>，代码如下：</p>

<div><script src='https://gist.github.com/1421792.js?file=flickr.html'></script>
<noscript><pre><code>{% if site.flickr_user %}
&lt;section class=&quot;flickr&quot;&gt;
&lt;h1&gt;My Flickr&lt;/h1&gt;
&lt;!-- Start of Flickr Badge --&gt;
&lt;style type=&quot;text/css&quot;&gt;
/*
Images are wrapped in divs classed &quot;flickr_badge_image&quot; with ids &quot;flickr_badge_imageX&quot; where &quot;X&quot; is an integer specifying ordinal position. Below are some styles to get you started!
*/
#flickr_badge_wrapper {padding:10px 0 10px 0;}
.flickr_badge_image {margin: 0 9px 8px 0px;display: inline-block;}
&lt;/style&gt;
&lt;div id=&quot;flickr_badge_uber_wrapper&quot;&gt;&lt;div id=&quot;flickr_badge_wrapper&quot;&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.flickr.com/badge_code_v2.gne?count={{ site.flickr_count }}&amp;display=latest&amp;size=s&amp;layout=x&amp;source=user&amp;user={{ site.flickr_user }}&quot;&gt;&lt;/script&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;!-- End of Flickr Badge --&gt;
&lt;/section&gt;
{% endif %}</code></pre></noscript></div>




<!--more-->


<p>
2.在_config.yml添加</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># Flick Badges
</span><span class='line'># Find your user id here: http://idgettr.com/ It should be something like "81221217@N08".
</span><span class='line'>flickr_user: 81221217@N08
</span><span class='line'>flickr_count: 6</span></code></pre></td></tr></table></div></figure>


<p> <br/>
记住要把 flickr_user 换成你自己的 id。 <br/>
ID在这个<a href="http://idgettr.com/">网址</a>获取，只需把username换成自己的，然后点find。 <br/>
3.在<code>_config_yml</code>中<code>default_asides</code>添加<code>custom/asides/flickr.html</code>。 <br/>
4.大功告成。
本文参考了：<a href="http://lucifr.com/2011/12/02/add-flickr-aside-to-octopress/">Lucifr</a>和<a href="http://melandri.net/2012/01/10/octopress-flickr-aside/">melandri</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[排序算法总结（五）]]></title>
    <link href="http://tinyxd.me/blog/2012/07/01/merge-sort/"/>
    <updated>2012-07-01T23:45:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/01/merge-sort</id>
    <content type="html"><![CDATA[<p>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。 <br/>
归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 <br/>
将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 <br/>
与快速排序比较：归并排序是稳定的排序.即相等的元素的顺序不会改变。如输入记录 1(1) 3(2) 2(3) 2(4) 5(5) (括号中是记录的关键字)时输出的 1(1) 2(3) 2(4) 3(2) 5(5) 中的2 和 2 是按输入的顺序。这对要排序数据包含多个信息而要按其中的某一个信息排序，要求其它信息尽量按输入的顺序排列时很重要。这也是它比快速排序优势的地方.。</p>

<!--more-->


<p>用途： <br/>
1、排序 <br/>
速度仅次于快速排序，但较稳定。 <br/>
2、求逆序对数 <br/>
具体思路是，在归并的过程中计算每个小区间的逆序对数，进而计算出大区间的逆序对数（也可以用树状数组来求解）。 <br/>
c语言实现  <br/>
输入参数中，需要排序的数组为array[],起始索引为first，终止索引为last。调用完成后，array[]中从first到last处于升序排列。</p>

<figure class='code'><figcaption><span>归并算法（Merge sort）</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">MergeSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">array</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">first</span><span class="p">,</span> <span class="kt">int</span> <span class="n">last</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">first</span><span class="o">&lt;</span><span class="n">last</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">first</span><span class="o">+</span><span class="n">last</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'>      <span class="n">MergeSort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
</span><span class='line'>      <span class="n">MergeSort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">last</span><span class="p">);</span>
</span><span class='line'>      <span class="n">Merge</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="n">first</span><span class="p">,</span><span class="n">mid</span><span class="p">,</span><span class="n">last</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>本文是查阅书籍和网络资料整理而来，转载请注明出处。并以超链接的形式注明本文地址： <br/>
<code>http://tinyxd.me/blog/2012/07/01/merge-sort/</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[让Debian支持ntfs文件系统读写]]></title>
    <link href="http://tinyxd.me/blog/2012/06/30/debian-ntfs-filesysterm/"/>
    <updated>2012-06-30T15:45:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/30/debian-ntfs-filesysterm</id>
    <content type="html"><![CDATA[<p>刚装好debian发现在debian下往windows盘下拷贝不过去资料，上网查了些资料发现是因为不知道ntfs的读写。 <br/>
查看我的版本号6.0.5</p>

<pre><code>#more /etc/debian_version   
6.0.5   
</code></pre>

<p>我的Debian系统: 6.0.5 <br/>
要是用的软件使用软件:ntfs-3g <br/>
1.修改默认源 <br/>
因为我们学校有自己的源，故而修改成我们学校的源，而后进行更新</p>

<pre><code>apt-get update   
</code></pre>

<!--more-->


<p>2.执行安装 <br/>
执行命令:</p>

<pre><code>apt-get install ntfs-3g   
</code></pre>

<p>3.使用 <br/>
直接使用执行命令:</p>

<pre><code>mount -t ntfs-3g /dev/hdax /mnt/windows   
</code></pre>

<p>这里的/dev/hdax 请改为你自己的windows磁盘分区，可利用fdisk -l 查看。  <br/>
如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>debian:/mnt# fdisk -l
</span><span class='line'>Disk /dev/sda: 500.1 GB, 500107862016 bytes
</span><span class='line'>255 heads, 63 sectors/track, 60801 cylinders
</span><span class='line'>Units = cylinders of 16065 * 512 = 8225280 bytes
</span><span class='line'>Sector size (logical/physical): 512 bytes / 512 bytes
</span><span class='line'>I/O size (minimum/optimal): 512 bytes / 512 bytes
</span><span class='line'>Disk identifier: 0x559ed1e5
</span><span class='line'>
</span><span class='line'>  Device Boot      Start         End      Blocks   Id  System
</span><span class='line'>/dev/sda1               1        6528    52436128+   7  HPFS/NTFS
</span><span class='line'>/dev/sda2            6529       60802   435949345+   f  W95 Ext'd (LBA)
</span><span class='line'>/dev/sda5            6529       24543   144705456    7  HPFS/NTFS
</span><span class='line'>/dev/sda6           24544       42558   144705456    7  HPFS/NTFS
</span><span class='line'>/dev/sda7           42559       53060    84357283+   7  HPFS/NTFS
</span><span class='line'>/dev/sda8           53061       53321     2096451    b  W95 FAT32
</span><span class='line'>/dev/sda9   *       53322       53346      194560   83  Linux
</span><span class='line'>/dev/sda10          53346       53589     1951744   82  Linux swap / Solaris
</span><span class='line'>/dev/sda11          53589       55413    14647296   83  Linux
</span><span class='line'>/dev/sda12          55413       60802    43287552   83  Linux   </span></code></pre></td></tr></table></div></figure>


<p>如果是加入开机自动映射的话，编辑/etc/fstab,加入如下内容就可以了。</p>

<pre><code>/dev/hdax /mnt/windows ntfs-3g defaults 0 0   
</code></pre>

<p>下面是我的系统加载NTFS文件系统的相关命令：</p>

<pre><code>mount -t ntfs-3g /dev/sda6 /mnt/D
mount -t ntfs-3g /dev/sda7 /mnt/E   
</code></pre>

<p>以上文章是对网上搜集的资料的整理。如需转载请注明出处，本文地址： <br/>
<code>http://tinyxd.me/blog/2012/06/30/debian-ntfs-filesysterm/</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[排序算法总结（四）]]></title>
    <link href="http://tinyxd.me/blog/2012/06/29/radix-sort/"/>
    <updated>2012-06-29T23:28:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/29/radix-sort</id>
    <content type="html"><![CDATA[<p>“基数排序法”属于“分配式排序”（distribution sort），基数排序法又称“桶子法”（bucket sort）或bin sort ，它是通过键值的部分资讯，将要排序的元素分配至某些“桶”中，借以达到排序的作用。基数排序法是属于稳定性的排序，其时间复杂度为O（nlog(r)m），其中r为所采用的基数，而m为堆数。在某些时候，基数排序法的效率高于其他的比较性排序。 <br/>
什么是基数排序： 基数排序也称桶排序，是一种当关键字为整数类型时的一种非常高效的排序方法。基数排序算法进出桶中的数据元素序列满足先进先出的原则（桶实际就是队列）。</p>

<!--more-->


<h3>c语言实现基数排序</h3>

<figure class='code'><figcaption><span>c语言实现基数排序</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;stdlib.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">73</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">93</span><span class="p">,</span><span class="mi">43</span><span class="p">,</span><span class="mi">55</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">28</span><span class="p">,</span><span class="mi">65</span><span class="p">,</span><span class="mi">39</span><span class="p">,</span><span class="mi">81</span><span class="p">};</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">temp</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="mi">10</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">order</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">lsd</span><span class="p">;</span>
</span><span class='line'>  <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">排序前: &quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class='line'>  <span class="n">putchar</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">&lt;=</span><span class="mi">10</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>      <span class="n">lsd</span><span class="o">=</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">n</span><span class="p">)</span><span class="o">%</span><span class="mi">10</span><span class="p">);</span>
</span><span class='line'>      <span class="n">temp</span><span class="p">[</span><span class="n">lsd</span><span class="p">][</span><span class="n">order</span><span class="p">[</span><span class="n">lsd</span><span class="p">]]</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>      <span class="n">order</span><span class="p">[</span><span class="n">lsd</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">重新排列: &quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>          <span class="k">if</span><span class="p">(</span><span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'>          <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>              <span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span><span class='line'>              <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
</span><span class='line'>              <span class="n">k</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>          <span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="n">n</span><span class="o">*=</span><span class="mi">10</span><span class="p">;</span>
</span><span class='line'>      <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">putchar</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">排序后: &quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>c++实现基数排序</h3>

<figure class='code'><figcaption><span>c++实现基数排序</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">int</span> <span class="n">maxbit</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">[],</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="c1">//辅助函数，求数据的最大位数</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//保存最大的位数</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span><span class="mi">10</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="k">while</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">p</span><span class="p">)</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>      <span class="n">p</span> <span class="o">*=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>      <span class="o">++</span><span class="n">d</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">radixsort</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">[],</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="c1">//基数排序</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">maxbit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">int</span> <span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
</span><span class='line'>  <span class="kt">int</span> <span class="o">*</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">//计数器</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">radix</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span> <span class="n">d</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">//进行d次排序</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">j</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>      <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//每次分配前清空计数器</span>
</span><span class='line'>      <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>          <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">/</span><span class="n">radix</span><span class="p">)</span><span class="o">%</span><span class="mi">10</span><span class="p">;</span> <span class="c1">//统计每个桶中的记录数</span>
</span><span class='line'>          <span class="n">count</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="n">j</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>          <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">];</span> <span class="c1">//将tmp中的位置依次分配给每个桶</span>
</span><span class='line'>      <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="c1">//将所有桶中记录依次收集到tmp中</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>      <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">/</span><span class="n">radix</span><span class="p">)</span><span class="o">%</span><span class="mi">10</span><span class="p">;</span>
</span><span class='line'>      <span class="n">mp</span><span class="p">[</span><span class="n">count</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span><span class='line'>      <span class="n">tcount</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="c1">//将临时数组的内容复制到data中</span>
</span><span class='line'>          <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span><span class='line'>      <span class="n">radix</span> <span class="o">=</span> <span class="n">radix</span><span class="o">*</span><span class="mi">10</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">delete</span> <span class="p">[]</span> <span class="n">tmp</span><span class="p">;</span>
</span><span class='line'>  <span class="k">delete</span> <span class="p">[]</span> <span class="n">count</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>实现基数排序算法时，有基于顺序队列和基于链式队列两种不同的实现方法。基于链式队列的实现中可以把桶设计成一个队列数组QueueArray，数组的每个元素中有两个域，一个队首指针（front）和一个队尾指针（rear）。
本文是查阅书籍和网络资料整理而来，转载请注明出处。并以超链接的形式注明本文地址： <br/>
<code>http://tinyxd.me/blog/2012/06/29/radix-sort/</code> <br/>
下一节更新归并排序。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[排序算法总结（三）]]></title>
    <link href="http://tinyxd.me/blog/2012/06/28/select-sort/"/>
    <updated>2012-06-28T12:38:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/28/select-sort</id>
    <content type="html"><![CDATA[<p>选择排序是指在每次排序时，选择最大或者最小项，将其放入适当的位置上，反复操作，直到所有数据排序完成为止。选择排序是一类比较常见的排序，现实生活中也比较常见，比如一个班级的学生排队，先将最高的学生排到队首，然后在其他学生中再挑出最高的一个，排在第二的位置，以此类推，直到全部排完。</p>

<p>选择排序的交换操作介于 0 和 ( n - 1 ) 次之间。选择排序的比较操作为 n ( n - 1 ) / 2 次之间。选择排序的赋值操作介于 0 和 3 ( n - 1 ) 次之间。 比较次数O（  n<sup>2</sup> ）,比较次数与关键字的初始状态无关，总的比较次数N=(n-1)+(n-2)+&#8230;+1=n*(n-1)/2。 交换次数O(n),最好情况是，已经有序，交换0次；最坏情况是，逆序，交换n-1次。 交换次数比冒泡排序少多了，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。</p>

<h2>直接选择排序（不稳定）</h2>

<figure class='code'><figcaption><span>直接选择排序</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">void</span> <span class="n">SelectSort</span><span class="p">(</span><span class="n">elemtype</span> <span class="n">R</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
</span><span class='line'>  <span class="n">elemtype</span> <span class="n">t</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">m</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>      <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>          <span class="k">if</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">R</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
</span><span class='line'>          <span class="n">m</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="k">if</span><span class="p">(</span><span class="n">m</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>          <span class="n">t</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>          <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>
</span><span class='line'>          <span class="n">R</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<!--more-->


<h2>堆排序(Heapsort)</h2>

<h3>“堆”定义</h3>

<p>树中任一非叶结点的关键字均不大于（或不小于）其左右孩子（若存在）结点的关键字。</p>

<h3>堆的高度</h3>

<p>堆可以被看成是一棵树，结点在堆中的高度可以被定义为从本结点到叶子结点的最长简单下降路径上边的数目；定义堆的高度为树根的高度。我们将看到，堆结构上的一些基本操作的运行时间至多是与树的高度成正比，为O（lgn）。</p>

<h3>堆排序思想</h3>

<p>堆排序利用了大根堆（或小根堆）堆顶记录的关键字最大（或最小）这一特征，使得在当前无序区中选取最大（或最小）关键字的记录变得简单。 <br/>
（1）用大根堆排序的基本思想 <br/>
① 先将初始文件R[1..n]建成一个大根堆，此堆为初始的无序区    <br/>
② 再将关键字最大的记录R[1]（即堆顶）和无序区的最后一个记录R[n]交换，由此得到新的无序区R[1..n-1]和有序区R[n]，且满足R[1..n-1].keys≤R[n].key   <br/>
③由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。然后再次将R[1..n-1]中关键字最大的记录R[1]和该区间的最后一个记录R[n-1]交换，由此得到新的无序区R[1..n-2]和有序区R[n-1..n]，且仍满足关系R[1..n-2].keys≤R[n-1..n].keys，同样要将R[1..n-2]调整为堆。
&#8230;&#8230;</p>

<p>直到无序区只有一个元素为止。 <br/>
（2）大根堆排序算法的基本操作： <br/>
① 初始化操作：将R[1..n]构造为初始堆； <br/>
② 每一趟排序的基本操作：将当前无序区的堆顶记录R[1]和该区间的最后一个记录交换，然后将新的无序区调整为堆（亦称重建堆）。 <br/>
注意： <br/>
①只需做n-1趟排序，选出较大的n-1个关键字即可以使得文件递增有序。 ②用小根堆排序与利用大根堆类似，只不过其排序结果是递减有序的。堆排序和直接选择排序相反：在任何时刻堆排序中无序区总是在有序区之前，且有序区是在原向量的尾部由后往前逐步扩大至整个向量为止。</p>

<h3>特点</h3>

<p>堆排序（HeapSort）是一树形选择排序。堆排序的特点是：在排序过程中，将R[l..n]看成是一棵完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的内在关系（参见二叉树的顺序存储结构），在当前无序区中选择关键字最大（或最小）的记录</p>

<h3>堆排序与直接选择排序的区别</h3>

<p>直接选择排序中，为了从R[1..n]中选出关键字最小的记录，必须进行n-1次比较，然后在R[2..n]中选出关键字最小的记录，又需要做n-2次比较。事实上，后面的n-2次比较中，有许多比较可能在前面的n-1次比较中已经做过，但由于前一趟排序时未保留这些比较结果，所以后一趟排序时又重复执行了这些比较操作。 <br/>
堆排序可通过树形结构保存部分比较结果，可减少比较次数。</p>

<h3>算法分析</h3>

<p>堆排序的时间，主要由建立初始堆和反复重建堆这两部分的时间开销构成，它们均是通过调用Heapify实现的。堆排序的最坏时间复杂度为O(nlogn)。堆序的平均性能较接近于最坏性能。由于建初始堆所需的比较次数较多，所以堆排序不适宜于记录数较少的文件。堆排序是就地排序，辅助空间为O(1），它是<strong>不稳定</strong>的排序方法。</p>

<figure class='code'><figcaption><span>堆排序c语言实现</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">//C语言描述</span>
</span><span class='line'><span class="c1">// array是待调整的堆数组，i是待调整的数组元素的位置，nlength是数组的长度</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">HeapAdjust</span><span class="p">(</span><span class="kt">int</span> <span class="n">array</span><span class="p">[],</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="kt">int</span> <span class="n">nLength</span><span class="p">)</span><span class="c1">//本函数功能是：根据数组array构建大根堆</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">nChild</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">nTemp</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">nTemp</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">nLength</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">nChild</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="c1">// 子结点的位置=2*（父结点位置）+ 1</span>
</span><span class='line'>      <span class="n">nChild</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>      <span class="c1">// 得到子结点中较大的结点</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">nChild</span> <span class="o">&lt;</span> <span class="n">nLength</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">array</span><span class="p">[</span><span class="n">nChild</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">array</span><span class="p">[</span><span class="n">nChild</span><span class="p">])</span>
</span><span class='line'>      <span class="o">++</span><span class="n">nChild</span><span class="p">;</span>
</span><span class='line'>      <span class="c1">// 如果较大的子结点大于父结点那么把较大的子结点往上移动，替换它的父结点</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">nTemp</span> <span class="o">&lt;</span> <span class="n">array</span><span class="p">[</span><span class="n">nChild</span><span class="p">])</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>      <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">nChild</span><span class="p">];</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="k">else</span> <span class="c1">// 否则退出循环</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>      <span class="k">break</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="c1">// 最后把需要调整的元素值放到合适的位置</span>
</span><span class='line'>      <span class="n">array</span><span class="p">[</span><span class="n">nChild</span><span class="p">]</span><span class="o">=</span> <span class="n">nTemp</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>  <span class="c1">// 堆排序算法</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">HeapSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">array</span><span class="p">[],</span><span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="c1">// 调整序列的前半部分元素，调整完之后第一个元素是序列的最大的元素</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">length</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>  <span class="n">HeapAdjust</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">length</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// 从最后一个元素开始对序列进行调整，不断的缩小调整的范围直到第一个元素</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>  <span class="c1">// 把第一个元素和当前的最后一个元素交换，</span>
</span><span class='line'>  <span class="c1">// 保证当前的最后一个位置的元素都是在现在的这个序列之中最大的</span>
</span><span class='line'>  <span class="n">Swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class='line'>  <span class="c1">// 不断缩小调整heap的范围，每一次调整完毕保证第一个元素是当前序列的最大值</span>
</span><span class='line'>  <span class="n">HeapAdjust</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span>堆排序算法（c++描述）</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="c1">//堆排序算法（C++描述）</span>
</span><span class='line'><span class="cp">#define MAX 100</span><span class="c1">//数据元素的最大个数</span>
</span><span class='line'><span class="k">typedef</span> <span class="k">struct</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">r</span><span class="p">[</span><span class="n">MAX</span><span class="p">];</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="n">SqList</span><span class="p">;</span><span class="c1">//定义一个线性表用于存放数据元素</span>
</span><span class='line'><span class="kt">void</span> <span class="n">HeapAdjust</span><span class="p">(</span><span class="n">SqList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">s</span><span class="p">,</span><span class="kt">int</span> <span class="n">m</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="c1">//已知L.r[s...m]中记录除L.r[s]外均满足堆的定义，本函数用于使L.r[s...m]成为一个大顶堆</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">e</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="n">s</span><span class="p">];</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="n">j</span><span class="o">*=</span><span class="mi">2</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&amp;&amp;</span><span class="n">L</span><span class="p">.</span><span class="n">R</span><span class="p">[</span><span class="n">J</span><span class="p">]</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">R</span><span class="p">[</span><span class="n">J</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">++</span><span class="n">j</span><span class="p">;</span>
</span><span class='line'>      <span class="k">if</span><span class="p">(</span><span class="n">e</span><span class="o">&gt;=</span><span class="n">L</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">break</span><span class="p">;</span>
</span><span class='line'>      <span class="n">L</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span><span class='line'>      <span class="n">s</span><span class="o">=</span><span class="n">j</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">L</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">=</span><span class="n">e</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">void</span> <span class="n">HeapSort</span><span class="p">(</span><span class="n">SqList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="c1">//对顺序表L进行堆排序</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">)</span>
</span><span class='line'>  <span class="n">HeapAdjust</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="c1">//将大顶堆的顶记录和最后一个记录相互交换</span>
</span><span class='line'>      <span class="n">e</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'>      <span class="n">L</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>      <span class="n">L</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">e</span><span class="p">;</span>
</span><span class='line'>      <span class="n">HeapAdjust</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>本文是查阅书籍和网络资料整理而来，转载请注明出处。并以超链接的形式注明本文地址： <br/>
<code>http://tinyxd.me/blog/2012/06/28/select-sort/</code> <br/>
下一节更新基数排序。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[排序算法总结（二）]]></title>
    <link href="http://tinyxd.me/blog/2012/06/27/swap-sort/"/>
    <updated>2012-06-27T20:50:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/27/swap-sort</id>
    <content type="html"><![CDATA[<p>昨天总结了插入排序，今天总结交换排序。 <br/>
交换排序是一种主要以交换的方式对序列进行排序的方法。排序的基本方法或手段主要就是比较和交换，像选择法等都借助了交换的手段，但都不是主要以交换为手段，如在直接选择排序的时候，一轮比较就能确定最大元素的位置，最后再进行交换。交换排序被公认为“稳定”的排序方法。</p>

<h2>冒泡排序</h2>

<p>冒泡排序，是指计算机的一种排序方法，它的时间复杂度为O（ n<sup>2</sup> ），虽然不及堆排序、快速排序的O（nlog n，底数为2），但是有两个优点：</p>

<!--more-->


<p>
1. “编程复杂度”很低，很容易写出代码； <br/>
2. 具有稳定性，这里的稳定性是指原序列中相同元素的相对顺序仍然保持到排序后的序列，而堆排序、快速排序均不具有稳定性。不过，一路、二路归并排序、不平衡二叉树排序的速度均比冒泡排序快，且具有稳定性，但速度不及堆排序、快速排序。 <br/>
冒泡排序（BubbleSort）的基本概念是：依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。至此第一趟结束，将最大的数放到了最后。在第二趟：仍从第一对数开始比较（因为可能由于第2个数和第3个数的交换，使得第1个数不再小于第2个数），将小数放前，大数放后，一直比较到倒数第二个数（倒数第一的位置上已经是
最大的），第二趟结束，在倒数第二的位置上得到一个新的最大数（其实在整个数列中是第二大的数）。如此下去，重复以上过程，直至最终完成排序。 <br/>
由于在排序过程中总是小数往前放，大数往后放，相当于气泡往上升，所以称作冒泡排序。 <br/>
若记录序列的初始状态为&#8221;正序&#8221;，则冒泡排序过程只需进行一趟排序，在排序过程中只需进行n-1次比较，且不移动记录；反之，若记录序列的初始状态为&#8221;逆序&#8221;，则需进行n(n-1）/2次比较和记录移动。因此冒泡排序总的时间复杂度为O(n*n)。</p>

<h2>快速排序（不稳定）</h2>

<p>快速排序（Quicksort）是对冒泡排序的一种改进。由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>

<figure class='code'><figcaption><span>C++，快速排续</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="c1">//C++，快速排序</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">sort</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">left</span><span class="p">,</span><span class="kt">int</span> <span class="n">right</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">left</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="n">right</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">left</span><span class="o">&gt;=</span><span class="n">right</span><span class="p">)</span> <span class="k">return</span> <span class="p">;</span>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">!=</span><span class="n">j</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">j</span><span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">k</span><span class="p">)</span> <span class="n">j</span><span class="o">--</span><span class="p">;</span>
</span><span class='line'>      <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span><span class='line'>      <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">j</span><span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">k</span><span class="p">)</span> <span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>      <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">k</span><span class="p">;</span>
</span><span class='line'>  <span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">left</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">right</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>本文是查阅书籍和网络资料整理而来，转载请注明出处。并以超链接的形式注明本文地址： <br/>
<code>http://tinyxd.me/blog/2012/06/27/swap-sort/</code> <br/>
下一节更新选择排序。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[排序算法总结（一）]]></title>
    <link href="http://tinyxd.me/blog/2012/06/27/straight-insertion-sort/"/>
    <updated>2012-06-27T08:00:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/27/straight-insertion-sort</id>
    <content type="html"><![CDATA[<p>排序算法是在学习数据结构的过程中，必须熟练掌握的。而由于其算法种类比较多，所以总结一下还是有必要的。今天先把插入排序总结下。 <br/>
插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n<sup>2)。是稳定的排序方法。</sup></p>

<h2>直接插入排序(straight insertion sort)</h2>

<p>每次从无序表中取出第一个元素，把它插入到有序表的合适位置，使有序表仍然有序。 <br/>
C/C++代码实现直接插入排序：</p>

<figure class='code'><figcaption><span>插入排序代码(straight insertion sort)</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">void</span> <span class="n">insert_sort</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">temp</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>      <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">temp</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>          <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<!--more-->


<h2>希尔排序 (shell sort)</h2>

<p>概念：先取一个小于n（待排序的数据个数）的整数d1作为第一个增量，把文件的全部记录分成d1个组。把所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序，然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量dt=1（dt&lt;dt-1&lt;…&lt;d2&lt;d1），即所有记录放在同一组中进行直接插入排序为止。该方法实质上是一种分组直接插入方法。</p>

<figure class='code'><figcaption><span>希尔排序(shell sort)</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="c1">//希尔排序</span>
</span><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="cp">#define LEN 8</span>
</span><span class='line'><span class="kt">void</span> <span class="n">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">d</span><span class="o">=</span><span class="n">LEN</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">R</span><span class="p">[</span><span class="n">LEN</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">76</span><span class="p">,</span><span class="mi">81</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">98</span><span class="p">,</span><span class="mi">33</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">79</span><span class="p">};</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">temp</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="n">d</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>  <span class="n">d</span><span class="o">/=</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">d</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">y</span><span class="o">&lt;</span><span class="n">d</span> <span class="p">;</span><span class="n">y</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="n">y</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;</span><span class="n">LEN</span><span class="p">;</span><span class="n">i</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">d</span><span class="p">))</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>          <span class="k">if</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">d</span><span class="p">])</span>
</span><span class='line'>          <span class="p">{</span>
</span><span class='line'>              <span class="n">temp</span><span class="o">=</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>              <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="n">d</span><span class="p">;</span>
</span><span class='line'>              <span class="k">do</span><span class="p">{</span>
</span><span class='line'>                  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d -&gt; %d,&quot;</span><span class="p">,</span><span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">d</span><span class="p">]);</span>
</span><span class='line'>                  <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">d</span><span class="p">]</span><span class="o">=</span><span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span><span class='line'>                  <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="o">-</span><span class="n">d</span><span class="p">;</span>
</span><span class='line'>              <span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="n">j</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">temp</span> <span class="o">&lt;</span><span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span><span class='line'>              <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d -&gt; %d&quot;</span><span class="p">,</span><span class="n">temp</span><span class="p">,</span><span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">d</span><span class="p">]);</span>
</span><span class='line'>              <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>          <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>          <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">a</span><span class="o">&lt;</span><span class="n">LEN</span><span class="p">;</span><span class="n">a</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>          <span class="p">{</span>
</span><span class='line'>              <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="n">R</span><span class="p">[</span><span class="n">a</span><span class="p">]);</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>          <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>          <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>本文是查阅书籍和网络资料整理而来，转载请注明出处。并以超链接的形式注明本文地址：<code>http://tinyxd.me/blog/2012/06/27/straight-insertion-sort/</code><br/>
下一节更新交换排序。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress博客添加标签云]]></title>
    <link href="http://tinyxd.me/blog/2012/06/25/octopress-add-tag-cloud/"/>
    <updated>2012-06-25T00:35:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/25/octopress-add-tag-cloud</id>
    <content type="html"><![CDATA[<p>折腾了好久，终于弄好了。我基本是follow这篇文章的：<a href="http://log4d.com/2012/05/tag-cloud/">给 Octopress 加上标签功能</a> <br/>
官方只提供了category的云显示，和列表显示，这是其<a href="https://github.com/tokkonopapa/octopress-tagcloud">github地址</a>，其实官方提供的这个第三方插件并没有给文章加入tag的概念。（category和tag分别代表日志分类和标签）</p>

<!--more-->


<p>
现在我还对ruby不是很熟悉，但是看到了<a href="http://log4d.com/2012/05/tag-cloud/">这篇文章</a>，找到了<a href="https://github.com/robbyedwards/octopress-tag-pages">robbyedwards / octopress-tag-pages</a>和<a href="https://github.com/robbyedwards/octopress-tag-cloud">robbyedwards / octopress-tag-cloud</a>。前者采集文章的tag，后者是标签云的显示。 <br/>
这两个使用方法相同，把文件放到相应的目录即可。而第二个插件<code>octopress-tag-cloud</code> 会和官方的有冲突，直接用<a href="https://github.com/alswl/octopress-category-list">这个</a>就好。 <br/>
还有最后一点非常重要，得修改两个地方： <br/>
一个是sass/custom/_styles.scss</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#content article .cloud li{
</span><span class='line'>  display: inline;
</span><span class='line'>  list-style: none outside none;
</span><span class='line'>  padding: 0 4px;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>然后把显示tagcloud的页面 class改为cloud(class=&#8221;cloud&#8221;)。 <br/>
大功告成，tag cloud页面请点击<a href="http://tinyxd.me/tags/index.html">这里</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给octopress添加关键字和网站描述]]></title>
    <link href="http://tinyxd.me/blog/2012/06/19/seo-meta-octopress/"/>
    <updated>2012-06-19T21:10:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/19/seo-meta-octopress</id>
    <content type="html"><![CDATA[<p>给octopress添加keywords和description。</p>

<p>1.修改source/_includes/head.html</p>

<div><script src='https://gist.github.com/2460469.js?file=head.html'></script>
<noscript><pre><code>&lt;meta name=&quot;author&quot; content=&quot;{{ site.author }}&quot;&gt;
{% capture description %}{% if page.description %}{{ page.description }}{% elsif site.description %}{{ site.description }}{%else%}{{ content | raw_content }}{% endif %}{% endcapture %}
&lt;meta name=&quot;description&quot; content=&quot;{{ description | strip_html | condense_spaces | truncate:150 }}&quot;&gt;
{% if page.keywords %}&lt;meta name=&quot;keywords&quot; content=&quot;{{ page.keywords }}&quot;&gt;{%else%}&lt;meta name=&quot;keywords&quot; content=&quot;{{ site.keywords }}&quot;&gt;{% endif %}
</code></pre></noscript></div>


<p>2.在_config.yml中添加如下内容</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>description: Keen on the software programming and Embedded development.（专注软件编程及嵌入式技术。）
</span><span class='line'>keywords: ruby , linux , archlinux , debian , software ,programming , embedded ,gem,web development ,ubuntu , java</span></code></pre></td></tr></table></div></figure>


<p>3.这样在主页代码中也会出现keywords和description信息。每个post也会出现。方便被搜索网站索引。这个涉及到了SEO。
以上文章参考自<a href="http://www.yatishmehta.in/seo-for-octopress">这里</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[php初学]]></title>
    <link href="http://tinyxd.me/blog/2012/06/19/learn-php/"/>
    <updated>2012-06-19T20:28:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/19/learn-php</id>
    <content type="html"><![CDATA[<p>1.搭建学习环境 采用简单的打包好的：lamp. <br/>
<a href="https://help.ubuntu.com/community/ApacheMySQLPHP#Run.2C_Stop.2C_Test.2C_And_Restart_Apache">help web sites</a></p>

<p>2.PHP中文手册 <br/>
http://www.phpchina.com/resource/manual/phpnew/</p>

<!--more-->


<p>example： <br/>
第一个 PHP 脚本：hello.php</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="x">&lt;html&gt;</span>
</span><span class='line'><span class="x"> &lt;head&gt;</span>
</span><span class='line'><span class="x">  &lt;title&gt;PHP 测试&lt;/title&gt;</span>
</span><span class='line'><span class="x"> &lt;/head&gt;</span>
</span><span class='line'><span class="x"> &lt;body&gt;</span>
</span><span class='line'><span class="x"> </span><span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="s1">&#39;&lt;p&gt;Hello World</span>
</span><span class='line'><span class="s1">&#39;</span><span class="p">;</span> <span class="cp">?&gt;</span><span class="x"></span>
</span><span class='line'><span class="x"> &lt;/body&gt;</span>
</span><span class='line'><span class="x">&lt;/html&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>PHP基本语法：</p>

<p>四种标量类型：</p>

<ul>
<li> boolean （布尔型）</li>
<li> integer （整型）</li>
<li> float （浮点型, 也称作 double)</li>
<li> string （字符串）</li>
</ul>


<p>两种复合类型：</p>

<ul>
<li> array （数组）</li>
<li> object （对象）</li>
</ul>


<p>最后是两种特殊类型：</p>

<ul>
<li> resource　（资源）</li>
<li> NULL　（NULL）</li>
</ul>


<p>为了确保代码的易读性，本手册还介绍了一些伪类型：</p>

<ul>
<li> mixed</li>
<li> number</li>
<li> callback</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[debian安装nvidia显卡驱动]]></title>
    <link href="http://tinyxd.me/blog/2012/06/18/debianan-zhuang-nvidiaxian-qia-qu-dong/"/>
    <updated>2012-06-18T20:31:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/18/debianan-zhuang-nvidiaxian-qia-qu-dong</id>
    <content type="html"><![CDATA[<p>在自己的电脑上硬盘安装了Debian.下面介绍一下我是如何安装显卡驱动的.我的显卡是GForce 7100GS的.</p>

<p>1>下载显卡驱动.</p>

<p>这个可以到Nvidia的官网上去找,找到自己对应的版本就可以了。</p>

<p>2>安装gcc并设置版本.</p>

<p>#apt-get install gcc 这样安装的是gcc-4.4,如果在安装过程中提示您安装的gcc版本有问题,你可以再安装一下gcc-4.3并将gcc版本设置为4.3,具体做法:</p>

<p>#apt-get install gcc-4.3</p>

<p>#ln -sf /usr/bin/gcc-4.3 /usr/bin/gcc 这一句用来将gcc的版本设置为4.3</p>

<p>#ls -l /usr/bin/gcc* 这一句用来查看当前使用的gcc版本</p>

<!--more-->


<p>3>安装make</p>

<p>#apt-get install make</p>

<p>4>安装编译头文件</p>

<p>#apt-get install build-essential linux-headers-$(uname -r)</p>

<p>5>编辑 /boot/gurb/grub.cfg</p>

<p>在linux /vmlinuz -2.6.32-5&#8230;&#8230;&#8230;quite 后面加上 nomodeset  (作用是将原来普适的显卡驱动禁用)</p>

<p>6>进入字符界面 Ctrl+Alt+F1</p>

<p>7>停用X-Server:</p>

<p>#/etc/init.d/gdm3 stop</p>

<p>8>安装显卡驱动:</p>

<p> # sh &#8230;. (省略号部分为你下载的显卡驱动的名称) 你将会看到安装的进度条.</p>

<p>9>#startx</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用new申请动态空间的问题]]></title>
    <link href="http://tinyxd.me/blog/2012/06/14/yong-newshen-qing-dong-tai-kong-jian-de-wen-ti/"/>
    <updated>2012-06-14T07:27:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/14/yong-newshen-qing-dong-tai-kong-jian-de-wen-ti</id>
    <content type="html"><![CDATA[<p>先分析一下new的分配：</p>

<p>1.T*   p   =   new   T;  ···   delete   p;
等价于
T*   p   =   new   T[1]; ··· delete[]   p;</p>

<p>2.int   (*p)[n]   =   new   int[m][n];这种方式是可行的</p>

<p>3.所以new一个3x3的数组，也就是T   =   int[3][3] ，  那么可以这样写：
int   (*p)[3][3]   =   new   int[1][3][3];     删除时请调用delete[]   p;</p>

<!--more-->


<p>4.int** a；很容易造成内存泄漏最好不要用。</p>

<p>下面是自己写的一个test：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">size_t</span> <span class="n">m</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="mi">10</span><span class="p">]();</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="n">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">!=</span><span class="mi">10</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>      <span class="k">for</span><span class="p">(</span><span class="n">size_t</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">!=</span><span class="mi">10</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>          <span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">j</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="k">delete</span>  <span class="p">[]</span> <span class="n">p</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>还有一个问题是 ，c++中new的空间地址是连续的么？？</p>

<p>由于学习过linux内核，经过分析，有些时候是虚拟地址是连续的，而物理地址是不连续的。由于在内核中需要申请连续的物理地址空间的时候，使用类似kmalloc（）的函数，这样的话，如果size比较小的话，申请成功的概率还算高（尤其是刚开机不久），而申请大内存的话就有可能申请失败。申请虚拟地址的时候用vmalloc（），这个只能确保在虚拟地址上是连续的，而不能保证在物理地址是连续的，但是这个可以申请比较大的空间。</p>

<p>而看到网上说不同的操作系统会有不同的内存管理机制，而至于windows是咋样的，还需要进一步查找资料。</p>

<p>下面是转载的如何申请连续的地址空间（c++）（http://blog.csdn.net/zhongshengjun/article/details/4632156）：</p>

<blockquote><p>   地址连续的二维数组在C语言数值计算中有重要意义，很多二维数组的算法是基于一维数组写的。另外，在序列化时或内存复制时，连续空间易于进行整块内存的操作。</p>

<p>   子程序说明：</p>

<p>   1- Array2D和FreeArray2D可实现地址连续的动态二维数组的地址分配和释放。</p>

<p>  2- 作为对照，下面给出了地址不连续的二维数组地址分配与释放的子程序。</p></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="c1">// 创建 n X m 的动态数组，该数组的元素地址在内存中是连续的</span>
</span><span class='line'><span class="c1">// n - 输入参数，数组的行数</span>
</span><span class='line'><span class="c1">// m - 输入参数，数组的列数</span>
</span><span class='line'><span class="c1">// 返回，double **，指向指针的指针，用于以二维数组的方式访问一段内存。</span>
</span><span class='line'><span class="kt">double</span> <span class="o">**</span><span class="n">Array2D</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="kt">int</span> <span class="n">m</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'> <span class="c1">// 建立数组的存储区，即在内存中分配一片连续的空间，元素个数为 n*m，</span>
</span><span class='line'> <span class="c1">// 返回指向double的指针。</span>
</span><span class='line'>    <span class="kt">double</span> <span class="o">*</span><span class="n">Array1D</span><span class="o">=</span><span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">n</span><span class="o">*</span><span class="n">m</span><span class="p">];</span>
</span><span class='line'> <span class="c1">// 建立数组的索引区，返回指向 double *的指针（指向指针的指针），长度为 n。</span>
</span><span class='line'>    <span class="kt">double</span> <span class="o">**</span><span class="n">Array2D</span><span class="o">=</span><span class="k">new</span> <span class="kt">double</span><span class="o">*</span> <span class="p">[</span><span class="n">n</span><span class="p">];</span>
</span><span class='line'> <span class="c1">// 将索引区的每个元素指向数据存储区对应元素的地址，Array2D[0] 指向 Array1D[0]，</span>
</span><span class='line'> <span class="c1">// Array2D[1] 指向 Array1D[m]，其余类推。</span>
</span><span class='line'>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>     <span class="n">Array2D</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=&amp;</span><span class="n">Array1D</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">m</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">Array2D</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 释放数组的空间，首先释放一维数组占用的n*m个double空间</span>
</span><span class='line'><span class="c1">// 再释放索引数组（指针数组）占用的n个double*空间</span>
</span><span class='line'> <span class="kt">void</span> <span class="n">FreeArray2D</span><span class="p">(</span><span class="kt">double</span> <span class="o">**</span><span class="n">Array2D</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">delete</span><span class="p">[]</span> <span class="n">Array2D</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'>  <span class="k">delete</span><span class="p">[]</span> <span class="n">Array2D</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 二维数组空间分配，地址一般不连续，不是推荐的方法</span>
</span><span class='line'> <span class="kt">double</span> <span class="o">**</span><span class="n">Array2D_A</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="kt">int</span> <span class="n">m</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'> <span class="c1">// 建立数组的索引区，返回指向 double *的指针（指向指针的指针），长度为 n。</span>
</span><span class='line'>    <span class="kt">double</span> <span class="o">**</span><span class="n">Array2D</span><span class="o">=</span><span class="k">new</span> <span class="kt">double</span><span class="o">*</span> <span class="p">[</span><span class="n">n</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'> <span class="c1">// 建立数组的存储区，对于Array2D的每一个指针元素，分配m个double空间</span>
</span><span class='line'>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>     <span class="n">Array2D</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">Array2D</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 释放数组的空间，与Array2D_A配套使用</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 首先释放n个一维数组（每个占用m个double空间）</span>
</span><span class='line'><span class="c1">// 再释放索引数组（指针数组）占用的n个double*空间</span>
</span><span class='line'> <span class="kt">void</span> <span class="n">FreeArray2D_A</span><span class="p">(</span><span class="kt">double</span> <span class="o">**</span><span class="n">Array2D</span><span class="p">,</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="k">delete</span><span class="p">[]</span> <span class="n">Array2D</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>  <span class="k">delete</span><span class="p">[]</span> <span class="n">Array2D</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[函数压栈的一些思考]]></title>
    <link href="http://tinyxd.me/blog/2012/06/13/han-shu-ya-zhan/"/>
    <updated>2012-06-13T07:22:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/13/han-shu-ya-zhan</id>
    <content type="html"><![CDATA[<p>今天，有个同学跑过来问我一个问题fun（i，i++，++i），我立马想到这个是跟函数压栈的顺序有关的，随后去网上查找资料，并开始写了一些测试实验。</p>

<p>先把cu上的一个解释先贴上来：</p>

<p>函数调用约定（Calling Convention）</p>

<!--more-->


<p>函数调用约定不仅决定了发生函数调用时函数参数的入栈顺序，还决定了是由调用者函数还是被调用函数负责清除栈中的参数，还原堆栈。函数调用约定有很多方 式，除了常见的__cdecl，__fastcall和__stdcall之外，C++的编译器还支持thiscall方式，不少C/C++编译器还支持 naked call方式。这么多函数调用约定常常令许多程序员很迷惑，到底它们是怎么回事，都是在什么情况下使用呢？下面就分别介绍这几种函数调用约定。</p>

<blockquote><p> <strong>1、__stdcall调用约定</strong> <br/>
  相当于16位动态库中经常使用的PASCAL调用约定。在32位的VC++5.0中PASCAL调用约定不再被支持（实际上它已被定义为__stdcall。除了__pascal外，__fortran和__syscall也不被支持），取而代之的是__stdcall调用约定。两者实质上是一致的，即函数的参数自右向左通过栈传递，被调用的函数在返回前清理传送参数的内存栈，但不同的是函数名的修饰部分（关于函数名的修饰部分在后面将详细说明）。 <em>stdcall是Pascal程序的缺省调用方式，通常用于Win32   Api中，函数采用从右到左的压栈方式，自己在退出时清空堆栈。VC将函数编译后会在函数名前面加上下划线前缀，在函数名后加上 &#8220;@ &#8220;和参数的字节数。 <br/>
 <strong>2、C调用约定</strong> <br/>
  （即用__cdecl关键字说明）按从右至左的顺序压参数入栈，由调用者把参数弹出栈。对于传送参数的内存栈是由调用者来维护的（正因为如此，实现可变参数的函数只能使用该调用约定）。另外，在函数名修饰约定方面也有所不同。
 </em>cdecl是C和C＋＋程序的缺省调用方式。每一个调用它的函数都包含清空堆栈的代码，所以产生的可执行文件大小会比调用<em>stdcall函数的大。函数采用从右到左的压栈方式。VC将函数编译后会在函数名前面加上下划线前缀。是MFC缺省调用约定。 <br/>
<strong>3、__fastcall调用约定</strong> <br/>
  是 &#8220;人 &#8220;如其名，它的主要特点就是快，因为它是通过寄存器来传送参数的（实际上，它用ECX和EDX传送前两个双字（DWORD）或更小的参数，剩下的参数仍旧自右向左压栈传送，被调用的函数在返回前清理传送参数的内存栈），在函数名修饰约定方面，它和前两者均不同。
 </em>fastcall方式的函数采用寄存器传递参数，VC将函数编译后会在函数名前面加上 &#8220;@ &#8220;前缀，在函数名后加上 &#8220;@ &#8220;和参数的字节数。 <br/>
<strong>4、thiscall</strong> <br/>
  仅仅应用于 &#8220;C++ &#8220;成员函数。this指针存放于CX寄存器，参数从右到左压。thiscall不是关键词，因此不能被程序员指定。 <br/>
 <strong>5、naked   call</strong> <br/>
  采用1-4的调用约定时，如果必要的话，进入函数时编译器会产生代码来保存ESI，EDI，EBX，EBP寄存器，退出函数时则产生代码恢复这些寄存器的内容。
naked   call不产生这样的代码。naked   call不是类型修饰符，故必须和_declspec共同使用。
关键字__stdcall __cdecl和 __fastcall可以直接加在要输出的函数前，也可以在编译环境的Setting&#8230;\C/C++   \Code   Generation项选择。当加在输出函数前的关键字与编译环境中的选择不同时，直接加在输出函数前的关键字有效。它们对应的命令行参数分别为/Gz、/Gd和/Gr。缺省状态为/Gd，即__cdecl。
要完全模仿PASCAL调用约定首先必须使用__stdcall调用约定，至于函数名修饰约定，可以通过其它方法模仿。还有一个值得一提的是WINAPI宏，Windows.h支持该宏，它可以将出函数翻译成适当的调用约定，在WIN32中，它被定义为__stdcall。使用WINAPI宏可以创建自己的APIs 。</p>

<p>VC的编译环境默认是使用__cdecl调用约定，也可以在编译环境的Project Setting&#8230;菜单－》C/C++ ＝》Code    Generation项选择设置函数调用约定。也可以直接在函数声明前添加关键字__stdcall、__cdecl或__fastcall等单独确定函 数的调用方式。在Windows系统上开发软件常用到WINAPI宏，它可以根据编译设置翻译成适当的函数调用约定，在WIN32中，它被定义为 __stdcall。</p></blockquote>

<p>下面是华为某年的一个考题，</p>

<p>设</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="o">=</span><span class="n">arr</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span><span class="o">+=</span><span class="mi">123</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">printf</span><span class="p">(</span><span class="err">＂</span><span class="o">%</span><span class="n">d</span><span class="p">,</span><span class="o">%</span><span class="n">d</span><span class="err">＂</span><span class="p">,</span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="o">*</span><span class="p">(</span><span class="o">++</span><span class="n">ptr</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>答案为什么是：8，8</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="o">=</span><span class="n">arr</span><span class="p">;</span><span class="c1">//现在ptr指向6</span>
</span><span class='line'>
</span><span class='line'><span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span><span class="o">+=</span><span class="mi">123</span><span class="p">;</span><span class="c1">//现在ptr指向7,第一个元素变为129</span>
</span><span class='line'>
</span><span class='line'><span class="n">printf</span><span class="p">(</span><span class="err">＂</span><span class="o">%</span><span class="n">d</span><span class="p">,</span><span class="o">%</span><span class="n">d</span><span class="err">＂</span><span class="p">,</span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="o">*</span><span class="p">(</span><span class="o">++</span><span class="n">ptr</span><span class="p">));</span> <span class="c1">//考虑从右往左计算，先是*(++ptr)，现在ptr指向8，然后*ptr也是8，输出8，8</span>
</span></code></pre></td></tr></table></div></figure>


<p>嗯 虽然这样解释似乎有些道理，但是有人认为这是和编译器相关的，即，求值顺序是不定的。。也有可能出现7，8的结果。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[嵌入式linux应用程序自启动]]></title>
    <link href="http://tinyxd.me/blog/2012/06/10/qian-ru-shi-linuxying-yong-cheng-xu-zi-qi-dong/"/>
    <updated>2012-06-10T19:46:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/10/qian-ru-shi-linuxying-yong-cheng-xu-zi-qi-dong</id>
    <content type="html"><![CDATA[<p>在很多嵌入式系统中，由于可用资源较少，常常在系统启动后就直接让应用程序自动启动，以减少用户操作和节省资源。如何让自己的应用程序自动启动呢？    在Linux系统中，配置应用程序自动启动的方法有以下三种：</p>

<!--more-->


<h2>1.通过/Linuxrc脚本直接启动</h2>

<p>Linux内核一旦开始执行，它将通过驱动程序来初始化所有硬件设备，这个初始化过程可以在启动时的PC显示器上看到，每个驱动程序都打印一些相关信息。初始化完成后，通常调用的是init，通过loader调用init内的init=/app_program语句（通过loader向核心传入init=/program可以定制首先运行的程序）。 <br/>
比如在桌面Linux系统中，init进程会读取/etc/inittab文件，来决定执行级别和哪些脚本和命令。嵌入式应用开发中，可以根据实际情况决定是否使用标准的init执行方式，也许这个init是个静态程序，它能够完成我们的嵌入应用的特定任务，那完全不用考虑inittab了，在这里可以采用比较灵活的措施。</p>

<h2>2.在/etc/init.d下添加启动脚本</h2>

<p>一般情况下，大多数的Linux操作系统使用/etc/init.d/(或/etc/rc.d/init.d)下的脚本来配置应用程序的自动启动。 <br/>
例如，在某些Linux系统中，corn程序通过/etc/init.d/corn脚本启动，Apache通过/etc/init.d/httpd启动，syslogd通过/etc/init.d/syslogd启动，而sshd则通过/etc/init.d/sshd脚本启动。 <br/>
通常这些脚本通过来自特定rc.d目录的符号链接运行。为了配置从哪个rc.d目录运行脚本，Linux系统提供了许多不同的工具，同时也可以手工进行配置。Linux系统有一个包含所有实际启动脚本文件的目录。它可能是/etc/init.d，也可能是/etc/rc.d/rc.d。同时对应每个运行级别（runlevel）又有一个另外的目录，它们可能是/etc/rc2.d，也可能是/etc/rc.d/rc2.d。这些目录中的文件通常是指向实际脚本文件的符号链接。</p>

<h2>3.直接在/etc/rc.d/rc.local脚本中添加命令</h2>

<p>在Linux系统中，有一个类似Windows系统中autoexec.bat的文件，它就是/etc/rc.d/rc.local，系统开机后自动运行用户的应用程序或启动系统服务的命令保存在开发板根文件系统的这个文件中。因此可以编辑rc.local文件，将要执行的程序（命令）添加到该文件夹中。Linux系统在启动后还未登录前，将自动执行该程序（命令），达到开机自动运行用户的应用程序的目的。 <br/>
下面具体说明：  <br/>
首先解压ramdisk.image.gz文件，然后挂载到系统中。接着创建自己的应用程序文件夹hello，将所要自动运行的应用程序hello复制到该文件夹。 <br/>
然后打开/usr/etc/rc.local文件，在最后一行加入：/Myapp/hello/hello <br/>
再按上面的顺序将ramdisk.image打包下载到目标板，启动运行，则可以看到用户编写的应用程序一启动就运行起来了。 <br/>
本文参考《基于ARM9的嵌入式Linux开发技术》，李新峰等编著。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读C++ Primer 之句柄类]]></title>
    <link href="http://tinyxd.me/blog/2012/06/08/c-plus-plus-ju-bing-lei/"/>
    <updated>2012-06-08T20:28:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/08/c-plus-plus-ju-bing-lei</id>
    <content type="html"><![CDATA[<p>转自Linux社区 作者：xizero00：http://www.linuxidc.com/Linux/2011-08/40175.htm</p>

<p>我们知道C++中最令人头疼的当属指针，如果您申请了对象却没有释放它，时间一长就会造成系统崩溃，大量的内存溢出使得您的程序的健壮性出现问题</p>

<p>而句柄类就是为了能够解决这一问题而出现的，句柄类有点类似于智能指针。</p>

<p>好了，废话不多说，我们来看代码</p>

<!--more-->


<p>首先我们来看 sample.h文件的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm">* author:xizero00</span>
</span><span class='line'><span class="cm">* mail:xizero00@163.com</span>
</span><span class='line'><span class="cm">* date:2011-08-07 20:11:24</span>
</span><span class='line'><span class="cm">* Handle Class Sample  句柄类示例</span>
</span><span class='line'><span class="cm">*/</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#ifndef SAMPLE_H</span>
</span><span class='line'><span class="cp">#define SAMPLE_H   </span>
</span><span class='line'>
</span><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;stdexcept&gt;</span>
</span><span class='line'><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//基类</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Item_base</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">//基类的虚函数,用于智能地复制对象</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="n">Item_base</span><span class="o">*</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">new</span> <span class="n">Item_base</span><span class="p">(</span> <span class="o">*</span><span class="k">this</span> <span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//子类</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Bulk_item</span><span class="o">:</span> <span class="k">public</span> <span class="n">Item_base</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">//子类的虚函数的重载,用于智能地复制对象</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="n">Bulk_item</span><span class="o">*</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">new</span> <span class="n">Bulk_item</span><span class="p">(</span> <span class="o">*</span><span class="k">this</span> <span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//子类的子类</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Sales_item</span><span class="o">:</span> <span class="k">public</span> <span class="n">Bulk_item</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">//默认构造函数,用来初始化一个引用计数器</span>
</span><span class='line'>    <span class="n">Sales_item</span><span class="p">()</span><span class="o">:</span> <span class="n">p</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">,</span> <span class="n">use</span><span class="p">(</span> <span class="k">new</span> <span class="n">size_t</span><span class="p">(</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Sales_item的引用计数器初始化为1&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//带有一个参数的,且该参数为基类引用的构造函数</span>
</span><span class='line'>    <span class="n">Sales_item</span><span class="p">(</span> <span class="k">const</span> <span class="n">Item_base</span><span class="o">&amp;</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//复制构造函数,需要注意的是，每复制一次就需要增加引用计数一次</span>
</span><span class='line'>    <span class="n">Sales_item</span><span class="p">(</span> <span class="k">const</span> <span class="n">Sales_item</span> <span class="o">&amp;</span><span class="n">i</span> <span class="p">)</span><span class="o">:</span> <span class="n">p</span><span class="p">(</span> <span class="n">i</span><span class="p">.</span><span class="n">p</span> <span class="p">)</span> <span class="p">,</span> <span class="n">use</span><span class="p">(</span> <span class="n">i</span><span class="p">.</span><span class="n">use</span> <span class="p">)</span> <span class="p">{</span> <span class="o">++*</span><span class="n">use</span><span class="p">;</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;由于采用了复制构造函数,Sales_item类型的对象引用计数为:&quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">use</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;}</span> <span class="c1">//也可以这样写</span>
</span><span class='line'>    <span class="c1">//Sales_item( const Sales_item &amp;i ): p( i.clone() ) , use( new size_t( 1 ) ) { ++*use; }   </span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//析构函数,析构的时候会判断是否能够释放指针所指向的数据</span>
</span><span class='line'>    <span class="o">~</span><span class="n">Sales_item</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;在析构函数中:&quot;</span><span class="p">;</span> <span class="n">decr_use</span><span class="p">();</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//赋值操作符重载</span>
</span><span class='line'>    <span class="n">Sales_item</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span> <span class="p">(</span> <span class="k">const</span> <span class="n">Sales_item</span><span class="o">&amp;</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//访问操作符重载</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">Item_base</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span> <span class="p">()</span> <span class="k">const</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span> <span class="n">p</span> <span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="k">throw</span> <span class="n">logic_error</span><span class="p">(</span> <span class="s">&quot;p指针错误&quot;</span> <span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//解引用操作符重载</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">Item_base</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span> <span class="p">()</span> <span class="k">const</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span> <span class="n">p</span> <span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>        <span class="p">{</span><span class="c1">//重载虚函数,用于智能地复制对象</span>
</span><span class='line'>            <span class="k">throw</span> <span class="n">logic_error</span><span class="p">(</span> <span class="s">&quot;p指针错误&quot;</span> <span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//重载虚函数,用于智能地复制对象</span>
</span><span class='line'>    <span class="cm">/*</span>
</span><span class='line'><span class="cm">    virtual Sales_item* clone() const</span>
</span><span class='line'><span class="cm">    {</span>
</span><span class='line'><span class="cm">        return new Sales_item( *this );</span>
</span><span class='line'><span class="cm">    }</span>
</span><span class='line'><span class="cm">    */</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">//两个指针存储着引用计数器以及数据的指针</span>
</span><span class='line'>    <span class="n">Item_base</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span><span class='line'>    <span class="n">size_t</span> <span class="o">*</span><span class="n">use</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//减少引用</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">decr_use</span><span class="p">()</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;在 dec_use函数中引用计数减少了,当前计数值为:&quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">use</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span> <span class="o">--*</span><span class="n">use</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
</span><span class='line'>            <span class="k">delete</span> <span class="n">use</span><span class="p">;</span>
</span><span class='line'>            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;在 dec_use函数中计数器减为0,释放对象&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//赋值操作符重载,每次复制都会增加引用计数</span>
</span><span class='line'><span class="n">Sales_item</span><span class="o">&amp;</span> <span class="n">Sales_item</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span> <span class="p">(</span> <span class="k">const</span> <span class="n">Sales_item</span> <span class="o">&amp;</span><span class="n">si</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;由于采用类赋值操作,&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;被赋值的对象的引用计数为:&quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">si</span><span class="p">.</span><span class="n">use</span> <span class="p">;</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;即将被赋值的对象的引用计数为:&quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">use</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">//这里需要特别注意的就是待复制的对象的计数器需要加1而被赋值的对象需要减1     </span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//增加被复制对象的引用计数</span>
</span><span class='line'>    <span class="o">++*</span><span class="n">si</span><span class="p">.</span><span class="n">use</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;被赋值的对象的赋值之后的引用计数为:&quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">si</span><span class="p">.</span><span class="n">use</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">//将即将被赋值的对象的引用计数减1</span>
</span><span class='line'>    <span class="n">decr_use</span><span class="p">();</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; 即将被赋值的对象赋值之后的引用计数为:&quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">use</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//复制指针</span>
</span><span class='line'>    <span class="n">p</span> <span class="o">=</span> <span class="n">si</span><span class="p">.</span><span class="n">p</span><span class="p">;</span>
</span><span class='line'>    <span class="n">use</span> <span class="o">=</span> <span class="n">si</span><span class="p">.</span><span class="n">use</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//返回</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#endif </span><span class="c1">//SAMPLE_H</span>
</span><span class='line'>
</span><span class='line'><span class="err">接下来我们来看</span><span class="n">sample</span><span class="p">.</span><span class="n">cc</span><span class="err">的代码：</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm">* author:xizero00</span>
</span><span class='line'><span class="cm">* mail:xizero00@163.com</span>
</span><span class='line'><span class="cm">* date:2011-08-07 20:11:24</span>
</span><span class='line'><span class="cm">*/</span>
</span><span class='line'><span class="cp">#include &quot;sample.h&quot;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span> <span class="kt">int</span> <span class="n">argc</span> <span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">//重点关注i1和i2的引用计数</span>
</span><span class='line'>    <span class="n">Sales_item</span> <span class="n">i1</span> <span class="p">,</span> <span class="n">i2</span><span class="p">;</span><span class="c1">//i1和i2的引用计数分别为1</span>
</span><span class='line'>    <span class="n">Sales_item</span> <span class="n">i3</span><span class="p">(</span> <span class="n">i1</span> <span class="p">);</span><span class="c1">//i1的引用计数变为2</span>
</span><span class='line'>    <span class="n">Sales_item</span> <span class="n">i4</span> <span class="o">=</span> <span class="n">i1</span><span class="p">;</span><span class="c1">//i1的引用计数变为3,因为这样还是调用的复制构造函数</span>
</span><span class='line'>    <span class="n">i4</span> <span class="o">=</span> <span class="n">i2</span><span class="p">;</span> <span class="c1">// i2的引用计数变为2   </span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面给出编译所需的Makefile</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp"># author:xizero00</span>
</span><span class='line'><span class="cp"># mail:xizero00@163.com</span>
</span><span class='line'><span class="cp"># date:2011-08-08 00:51:25</span>
</span><span class='line'><span class="nl">install:</span>
</span><span class='line'>    <span class="n">g</span><span class="o">++</span> <span class="n">sample</span><span class="p">.</span><span class="n">cc</span> <span class="o">-</span><span class="n">g</span> <span class="o">-</span><span class="n">o</span> <span class="n">sample</span>
</span><span class='line'>    <span class="n">ls</span> <span class="o">-</span><span class="n">al</span> <span class="n">sample</span><span class="o">*</span>
</span><span class='line'>    <span class="p">.</span><span class="o">/</span><span class="n">sample</span>
</span><span class='line'><span class="nl">clean:</span>
</span><span class='line'>    <span class="n">rm</span> <span class="o">-</span><span class="n">f</span> <span class="n">sample</span>
</span><span class='line'>    <span class="n">ls</span> <span class="o">-</span><span class="n">al</span> <span class="n">sample</span><span class="o">*</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意：代码是在linux下编译，您只需要将三个文件放在同一个目录，然后在当前目录打开终端，输入make，就可以查看到结果。</p>

<p>如果您想清理生成的文件 输入make clean即可</p>

<p>下面是我执行的结果：</p>

<pre><code>Sales_item的引用计数器初始化为1
Sales_item的引用计数器初始化为1
由于采用了复制构造函数,Sales_item类型的对象引用计数为:2
由于采用了复制构造函数,Sales_item类型的对象引用计数为:3
由于采用类赋值操作,被赋值的对象的引用计数为:1即将被赋值的对象的引用计数为:3
被赋值的对象的赋值之后的引用计数为:2
在 dec_use函数中引用计数减少了,当前计数值为:2
 即将被赋值的对象赋值之后的引用计数为:2
在析构函数中:在 dec_use函数中引用计数减少了,当前计数值为:1
在析构函数中:在 dec_use函数中引用计数减少了,当前计数值为:1
在析构函数中:在 dec_use函数中引用计数减少了,当前计数值为:0
在 dec_use函数中计数器减为0,释放对象
在析构函数中:在 dec_use函数中引用计数减少了,当前计数值为:0
在 dec_use函数中计数器减为0,释放对象
</code></pre>

<p>结论：我们可以看到，句柄类能够很方便并且能够很安全地释放内存，不会导致内存的泄露。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[堆和栈的区别]]></title>
    <link href="http://tinyxd.me/blog/2012/06/08/dui-he-zhan-de-qu-bie/"/>
    <updated>2012-06-08T06:59:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/08/dui-he-zhan-de-qu-bie</id>
    <content type="html"><![CDATA[<p>出自: http://www.cnitexam.com <br/>
一、预备知识—程序的内存分配</p>

<p>一个由c/C++编译的程序占用的内存分为以下几个部分</p>

<p>1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p>

<p>2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。</p>

<p>3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 – 程序结束后有系统释放</p>

<p>4、文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放</p>

<p>5、程序代码区—存放函数体的二进制代码。</p>

<!--more-->


<p>二、例子程序</p>

<p>这是一个前辈写的，非常详细</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">//main.cpp</span>
</span><span class='line'><span class="cp">#include &lt;stdlib.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;string.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">// 全局初始化区</span>
</span><span class='line'>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="n">p1</span><span class="p">;</span><span class="c1">// 全局未初始化区</span>
</span><span class='line'>
</span><span class='line'><span class="n">main</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">b</span><span class="p">;</span><span class="c1">// 栈</span>
</span><span class='line'>
</span><span class='line'><span class="kt">char</span> <span class="n">s</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;abc&quot;</span><span class="p">;</span> <span class="c1">//栈</span>
</span><span class='line'>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="n">p2</span><span class="p">;</span><span class="c1">// 栈</span>
</span><span class='line'>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="n">p3</span> <span class="o">=</span> <span class="s">&quot;123456&quot;</span><span class="p">;</span> <span class="c1">//123456\0在常量区，p3在栈上。</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span><span class="mi">0</span><span class="err">；</span><span class="c1">// 全局（静态）初始化区</span>
</span><span class='line'>
</span><span class='line'><span class="n">p1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="c1">//分配得来得10和20字节的区域就在堆区。</span>
</span><span class='line'>
</span><span class='line'><span class="n">strcpy</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="s">&quot;123456&quot;</span><span class="p">);</span> <span class="c1">//123456\0放在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;优化成一个地方。</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>二、堆和栈的理论知识</p>

<p>2.1申请方式</p>

<p>stack:</p>

<p>由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间</p>

<p>heap:</p>

<p>需要程序员自己申请，并指明大小，在c中malloc函数</p>

<p>如p1 = (char *)malloc(10);</p>

<p>在C++中用new运算符</p>

<p>如char *p2 =new char[10];</p>

<p>但是注意p1、p2本身是在栈中的。</p>

<p>2.2 申请后系统的响应</p>

<p>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p>

<p>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，</p>

<p>会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</p>

<p>2.3申请大小的限制</p>

<p>栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</p>

<p>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p>

<p>2.4申请效率的比较：</p>

<p>栈由系统自动分配，速度较快。但程序员是无法控制的。</p>

<p>堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.</p>

<p>另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活</p>

<p>2.5堆和栈中的存储内容</p>

<p>栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。</p>

<p>当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</p>

<p>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。</p>

<p>2.6存取效率的比较</p>

<p>char s1[] = “aaaaaaaaaaaaaaa”;</p>

<p>char *s2 = “bbbbbbbbbbbbbbbbb”;</p>

<p>aaaaaaaaaaa是在运行时刻赋值的；</p>

<p>而bbbbbbbbbbb是在编译时就确定的；</p>

<p>但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。</p>

<p>比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdlib.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="kt">char</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">char</span> <span class="n">c</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;1234567890&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span><span class="s">&quot;1234567890&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>对应的汇编代码</p>

<p>10: a = c[1];</p>

<p>004010678A4D F1 mov cl,byte ptr [ebp-0Fh]</p>

<p>0040106A88 4D FC mov byte ptr [ebp-4],cl</p>

<p>11: a = p[1];</p>

<p>0040106D 8B 55 EC mov edx,dword ptr [ebp-14h]</p>

<p>004010708A42 01 mov al,byte ptr [edx+1]</p>

<p>00401073 88 45 FC mov byte ptr [ebp-4],al</p>

<p>第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，在根据edx读取字符，显然慢了。</p>

<p>2.7小结：</p>

<p>堆和栈的区别可以用如下的比喻来看出：</p>

<p>使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。</p>

<p>使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。</p>

<p>堆和栈的区别主要分：</p>

<p>操作系统方面的堆和栈，如上面说的那些，不多说了。</p>

<p>还有就是数据结构方面的堆和栈，这些都是不同的概念。这里的堆实际上指的就是（满足堆性质的）优先队列的一种数据结构，第1个元素有最高的优先权；栈实际上就是满足先进后出的性质的数学或数据结构。</p>

<p>虽然堆栈，堆栈的说法是连起来叫，但是他们还是有很大区别的，连着叫只是由于历史的原因。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解决pygments.rb (RubyPython) 找不到libpython的问题(archlinux下)]]></title>
    <link href="http://tinyxd.me/blog/2012/06/05/cannot-find-libpython/"/>
    <updated>2012-06-05T08:01:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/05/cannot-find-libpython</id>
    <content type="html"><![CDATA[<p>本文章转自：<a href="http://ruby-china.org/topics/289">Ruby China 论坛</a> <br/>
如果找不到python，或者系统默认得python是3.x (比如Arch Linux)，手动制定下路径</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>RubyPython.configure python_exe: '/usr/bin/python2.7'</span></code></pre></td></tr></table></div></figure>


<p>对于rails项目比如ruby-china，可以把这行代码丢到config/initializers下。</p>

<p>不过RubyPython仍然可能找不到libpython而提示lib.so not found。这是由于RubyPython确定正确libpython的规则和你的系统不兼容，可以通过手动加些symbol links来解决 (目前RubyPython的git最新代码相对当前稳定版本0.5.3改动非常大，希望新版本能解决这个问题，就先不去提交fixing了)。</p>

<p>可以参考 PythonExec initialize 方法中的规则来建symbol link.</p>

<!--more-->


<p>首先运行该python，得到版本号x.y，以python2.7为例</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ python2.7 -c "import sys;print '%d.%d' % sys.version_info[:2]"
</span><span class='line'>
</span><span class='line'>=&gt; 2.7</span></code></pre></td></tr></table></div></figure>


<p>找到该python对应得libpython，可以用工具ldd:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ldd /usr/lib/python2.7 | grep python
</span><span class='line'>
</span><span class='line'>=&gt; libpython2.7.so.1.0 =&gt; /usr/lib/libpython2.7.so.1.0</span></code></pre></td></tr></table></div></figure>


<p>为找到的这个文件创建链接。下面用#{exe_base}表示通过RubyPython.configure指定的python可执行程序的文件名部分，#{x}和#{y}是通过运行这个python找到得版本号，#{libpython}是该python对应得libpython库文件路径。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo ln -s #{libpython} /usr/lib/lib#{exe_base}#{x}#{y}.so
</span><span class='line'>sudo ln -s #{libpython} /usr/lib/lib#{exe_base}#{x}.#{y}.so</span></code></pre></td></tr></table></div></figure>


<p>以我的环境(Arch Linux)为例，exe_base是python2.7，版本号x.y是2.7，libpython是/usr/lib/libpython2.7.so.1.0，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo ln -s /usr/lib/libpython2.7.so.1.0 /usr/lib/libpython2.727.so
</span><span class='line'>sudo ln -s /usr/lib/libpython2.7.so.1.0 /usr/lib/libpython2.72.7.so</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux下使用lftp的小结]]></title>
    <link href="http://tinyxd.me/blog/2012/06/04/linuxxia-shi-yong-lftpde-xiao-jie/"/>
    <updated>2012-06-04T07:08:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/06/04/linuxxia-shi-yong-lftpde-xiao-jie</id>
    <content type="html"><![CDATA[<p>lftp的功能比较强大，相比原来用ftp，方便了很多。</p>

<p>1、登陆：</p>

<p>lftp ftp://yourname@site</p>

<p>pwd:*****</p>

<p>或 open ftp://yourname@site</p>

<!--more-->


<p>2、基本操作（转） <br/>
lftp使用介绍</p>

<p>lftp 是一个功能强大的下载工具，它支持访问文件的协议: ftp, ftps, http, https, hftp, fish.(其中ftps和https需要在编译的时候包含openssl库)。llftp的界面非常想一个shell: 有命令补全，历史记录，允许多个后台任务执行等功能，使用起来非常方便。它还有书签、排队、镜像、断点续传、多进程下载等功能。 <br/>
命令行语法
要看lftp的命令行语法，只要在shell中输入lftp &#8211;help <br/>
lftp [OPTS]
&#8216;lftp&#8217;是在 rc 文件执行后 lftp 执行的第一个命令 <br/>
-f 执行文件中的命令后退出 <br/>
-c 执行命令后退出 <br/>
&#8211;help 显示帮助信息后退出 <br/>
&#8211;version 显示 lftp 版本后退出 <br/>
其他的选项同 &#8216;open&#8217; 命令 <br/>
-e 在选择后执行命令 <br/>
-u [,] 使用指定的用户名/口令进行验证 <br/>
-p 连接指定的端口 <br/>
主机名, URL 或书签的名字 <br/>
如果在命令行中输入的站点名称，lftp将直接登录站点，比如 <br/>
ftp ftp://&#8230;&#8230;&#8230;&#8230;. <br/>
如果在命令行不输入站点名称，则必须在进入到lftp界面后用open命令打开 <br/>
[yhj@ccse-yhj yhj]$ lftp <br/>
lftp :~> open ftp://&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;. <br/>
常用命令 <br/>
* 下载单个文件和一组文件，断点续传用-c参数 <br/>
lftp &#8230;&#8230;&#8230;&#8230;&#8230;.:/> get -c ls-lR.txt <br/>
lftp &#8230;&#8230;&#8230;&#8230;&#8230;:/> mget *.txt <br/>
* 镜像(反镜像即上传)一个目录，可以用多个线程并行镜像一个目录(&#8211;parallel=N) <br/>
lftp &#8230;&#8230;&#8230;&#8230;&#8230;.:/> mirror incoming local_name <br/>
lftp &#8230;&#8230;&#8230;&#8230;&#8230;.:/> mirror -R local_name <br/>
lftp &#8230;&#8230;&#8230;&#8230;&#8230;.:/> mirror &#8211;parallel=3 incoming local_name <br/>
* 多线程下载，类似网络蚂蚁的功能;缺省是5个线程 <br/>
lftp &#8230;&#8230;&#8230;&#8230;&#8230;.:/> pget -n 4 ls-lR.txt <br/>
* 后台任务管理 <br/>
缺省情况下，按 Ctrl+z,正在执行的任务将转为后台执行，也可以在命令行末尾加&amp;符号使任务在后台执行。用jobs命令可以查看所有的后台进程。用queue命令可以排队新的任务。如果退出lftp是还有任务在后台执行，lftp将转为后台执行。 <br/>
* 其它用法 <br/>
lftp支持类似bash的管道操作，例如用下面的命令可以将ftp服务器上的特定目录下(也可以是整个站点)所有文件的大小存到本地的文件ls.txt中 <br/>
lftp &#8230;&#8230;&#8230;&#8230;&#8230;.:/> du incoming > ls.txt <br/>
相关文件
/etc/lftp.conf <br/>
全局配置文件，实际位置依赖系统配置文件目录，可能在/etc，也可能在/usr/local/etc <br/>
~/.lftp/rc, ~/.lftprc <br/>
用户配置文件，将在/etc/lftp.conf之后执行，所以这里面的设置会覆盖/etc/lftp.conf中的设置。 <br/>
lftp 缺省不会显示 ftp 服务器的欢迎信息和错误信息，这在很多时候不方便，因为你有可能想知道这个服务器到底是因为没开机连不上，还是连接数已满。如果是这样，你可以在 ~/.lftprc 里写入一行 <br/>
debug 3
就可以看到出错信息了。 <br/>
更多的配置选项请查man手册或在lftp界面内用命令 set -a 获得。 <br/>
~/.lftp/log <br/>
当lftp转为后台非挂起模式执行时，输出将重定向到这里 <br/>
~/.lftp/bookmarks <br/>
这是lftp存储书签的地方，可以lftp查看bookmark命令 <br/>
~/.lftp/cwd_history <br/>
这个文件用来存储访问过的站点的工作目录</p>

<p>~/.lftprc  <br/>
在用lftp访问国内一些ftp服务器时，往往看到的中文是乱码  <br/>
^_<sup>不用慌，这是由于服务器和本地编码不一致造成的。我们只要在主目录下新建一个文件~/.lftprc或者~/.lftp/rc</sup>  <br/>
并在其中加入以下内容：  <br/>
debug 3set ftp:charset GBKset file:charset UTF-8#set ftp:passtive-mode no#alias utf8 &#8221; set ftp:charset UTF-8&#8221;#alias gbk &#8221; set ftp:charset GBK&#8221;  <br/>
登录ftp服务器  <br/>
言归正传，我们先来看看怎么登录ftp服务器  <br/>
lftp ftp://user:password@site:port  <br/>
lftp user:password@site:port  <br/>
lftp site -p port -u user,password  <br/>
lftp site:port -u user,password  <br/>
上面的几种方式都能正常工作，不过密码都是明文，这样好像不太安全哦。没关系  <br/>
lftp user@site:port  <br/>
系统会提示输入password，密码就回显为******了  <br/>
不过每次都输入这么多，好麻烦哦。 如果有类似leapftp的站点管理器就好了，其实lftp早就给我们想好了： 这就是bookmark。后面我们将会看到。  <br/>
常用命令  <br/>
在终端运行  <br/>
man lftp  <br/>
或登录ftp后输入  <br/>
help  <br/>
就可以看到命令列表  <br/>
下面我们看一下lftp常用的命令：  <br/>
ls  <br/>
显示远端文件列表(!ls 显示本地文件列表)。  <br/>
cd  <br/>
切换远端目录(lcd 切换本地目录)。  <br/>
get  <br/>
下载远端文件。  <br/>
mget  <br/>
下载远端文件(可以用通配符也就是 *)。  <br/>
pget  <br/>
使用多个线程来下载远端文件, 预设为五个。  <br/>
mirror  <br/>
下载/上传(mirror -R)/同步 整个目录。  <br/>
put  <br/>
上传文件。  <br/>
mput  <br/>
上传多个文件(支持通配符)。  <br/>
mv  <br/>
移动远端文件(远端文件改名)。  <br/>
rm  <br/>
删除远端文件。  <br/>
mrm  <br/>
删除多个远端文件(支持通配符)。  <br/>
mkdir  <br/>
建立远端目录。  <br/>
rmdir  <br/>
删除远端目录。  <br/>
pwd  <br/>
显示目前远端所在目录(lpwd 显示本地目录)。  <br/>
du  <br/>
计算远端目录的大小  <br/>
!  <br/>
执行本地 shell的命令(由于lftp 没有 lls, 故可用 !ls 来替代)  <br/>
lcd  <br/>
切换本地目录  <br/>
lpwd  <br/>
显示本地目录  <br/>
alias  <br/>
定义别名  <br/>
bookmark  <br/>
设定书签。  <br/>
exit  <br/>
退出ftp  <br/>
快捷书签  <br/>
补充作者：aBiNg  <br/>
ftp中的bookmark命令，是将配置写到~/.lftp/bookmarks文件中；我们可以直接修改此文件，快速登陆ftp服务器。</p>

<p>3、mirror 同步镜像，备份服务器文件</p>

<p>今天主要的问题是解决如何备份服务器端文件的问题。了解了mirror指令的用法后，发现比较适合而且好用。</p>

<p>基本使用方法：</p>

<p>1）、下载服务器端文件：</p>

<p> mirror –vn RCD LCD   //RCD为远程路径，LCD为本地路径</p>

<p>2）、上传文件：</p>

<p> mirror –R LCD RCD</p>

<p>下附一个自动同步的脚本：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!bin/bash</span>
</span><span class='line'><span class="nb">echo</span> “script start at  <span class="sb">`</span>date ”+%Y-%m-%d %H:%M:%S”
</span><span class='line'><span class="nv">HOST</span><span class="o">=</span>”hostname”
</span><span class='line'><span class="nv">USER</span><span class="o">=</span>”yourname”
</span><span class='line'><span class="nv">PASS</span><span class="o">=</span>”password”
</span><span class='line'><span class="nv">LCD</span><span class="o">=</span>”LocalePath”
</span><span class='line'><span class="nv">RCD</span><span class="o">=</span>”RemotePath”
</span><span class='line'>/usr/sbin/lftp <span class="s">&lt;&lt; EOF</span>
</span><span class='line'><span class="s">open ftp://$USER:$PASS@$HOST</span>
</span><span class='line'><span class="s">mirror $RCD $LCD</span>
</span><span class='line'><span class="s">EOF</span>
</span><span class='line'><span class="nb">echo</span> “script end at “ <span class="sb">`</span>date ”+%Y-%m-%d %H:%M:%S”
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cache一致性问题总结]]></title>
    <link href="http://tinyxd.me/blog/2012/05/31/cache--zhi-xing-wen-ti-zong-jie/"/>
    <updated>2012-05-31T20:59:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/05/31/cache&#8211;zhi-xing-wen-ti-zong-jie</id>
    <content type="html"><![CDATA[<h2>1.现代并行机中，为了提高处理器的速度，处理器往往带有Cache。</h2>

<p>一个数据在整个系统内可能有多份拷贝，这就引发了Cache一致性问题。
例如下图中的2个处理器和共享内存构成的系统。初始时刻，处理机P1和P2都将变量X从共享内存装入了私有Cache。
这时，两个Cache中和共享内存中的变量X的值是一样的。在程序运行的某一时刻，处理机P1把X的值修改为X&#8217;，并更新了私有Cache中 的值。
此时无论P1采用写直达（write-through），还是写回（write-back）策略，都不会修改P2私有Cache中X的值。这时如果P2需要读取X，则它得到的是过时的值。 <br/>
<img src="http://tinyxd.me/images/cache.gif"></p>

<!--more-->


<p>　　Cache一致性问题是指在含有多个Cache的并行系统中，数据的多个副本（因为没有同步更新）而造成的不一致问题。以上的例子是由于多个处理器共享一个可写变量
造成的Cache不一致。还有其它原因也会造成Cache一致性问题，比如进程迁移和某些I/O操作等。</p>

<h2>2.c64x+与cache一致性问题（http://focus.ti.com.cn/cn/general/docs/gencontent.tsp?contentId=64183）</h2>

<p>在各种数字信号处理系统中，CACHE被广泛用于弥补Core与存储器之间的速度差异。在CACHE的使用过程中，存在不同类型存储器之间数据是否一致的问题。
本文着重分析TI高性能C64x+ DSP系列中各级CACHE之间数据一致性问题以及如何进行一致性维护。CACHE作为Core和低速存储器之间的桥梁，基于代码和
数据的时间和空间相关性，以块为单位由硬件控制器自动加载Core所需要的代码和数据。如果所有程序和数据的存取都由Core完成，基于CACHE的运行机制，
Core始终能够得到存储器中最新的数据。但是当有其它可以更改存储器内容的部件存在时，例如不需要Core干预的直接数据存取（DMA）引擎，就可能出现
由于CACHE的存在而导致Core或者DMA不能够得到最新数据的现象，也就是CACHE一致性的问题。 C64x+ 存储器组织结构：TI对高性能C64x核进行了改进，
使其性能大大提升，称之为C64x+DSP核。基于C64x+核开发的DSP芯片，所有部件都以交换网络（SCR）为核心连接起来。SCR上的部件分为两类：Master和Slave。
Master包括Core、EDMA以及串行高速IO（sRIO），EMAC等外设。Master可以直接通过SCR发起到Slave的数据传输。Slave包括每一个Core的内存，DDR2外存以及
其它不能直接发起数据传输的外设，Slave之间的数据传输，需要通过DMA协助完成。各款基于C64x+DSP的数据手册上详细描述了SCR的配置和Master、Slave的情况。</p>

<h2>3.DMA与cache一致性问题</h2>

<p>　Cache数据与主存数据不一致是指：在采用Cache的系统中，同样一个数据可能既存在于Cache中，也存在于主存中，两者数据相同则具有一致性，
数据不相同就叫做不一致性。如果不能保证数据的一致性，那么，后续程序的运行就要出现问题。假设DMA针对内存的目的地址与Cache缓存的对象
没有重叠区域，DMA和Cache之间将相安无事。但是如果DMA的目的地址与Cache所缓冲的内存地址访问有重叠，经过DMA操作Cache缓冲所对应的内存数据已经被修改，
而CPU本身并不知道，它仍然认为Cache中的数据就是内存中的数据，以后访问Cache映射的内存时，它仍然使用陈旧的Cache数据。这样就发生Cache与内存之间数据“
不一致性”的错误。</p>
]]></content>
  </entry>
  
</feed>
