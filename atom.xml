<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Keen on Art of Tech]]></title>
  <link href="http://tinyxd.me/atom.xml" rel="self"/>
  <link href="http://tinyxd.me/"/>
  <updated>2012-07-16T12:20:34+08:00</updated>
  <id>http://tinyxd.me/</id>
  <author>
    <name><![CDATA[Tiny]]></name>
    <email><![CDATA[admin@tinyxd.me]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[archlinux 无线网络连接]]></title>
    <link href="http://tinyxd.me/blog/2012/07/16/archlinux-wireless-network-connection/"/>
    <updated>2012-07-16T11:24:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/16/archlinux-wireless-network-connection</id>
    <content type="html"><![CDATA[<p>今天，回家了。由于家里用的无线路由器，我的本是archlinux系统，所以这就涉及到archlinux的无线网络配置。 <br/>
本文参考了<a href="https://wiki.archlinux.org/index.php/Wireless_Setup">archlinux官方wiki</a>。 <br/>
配置无线网络一般分两步： <br/>
第一步是识别硬件、安装正确的驱动程序并进行配置； <br/>
第二步是选择一种管理无线连接的方式。 <br/>
关于第一步，wiki中有详细的介绍，我就不多叙述。 <br/>
第二步，有几个命令和无线网络的加密方法，需要说说。 <br/>
大概有两种方法：一个是手动，一个是自动。</p>

<!--more-->


<h2>方法一：手动</h2>

<p>不加密/WEP ：ifconfig + iwconfig + dhcpcd/ifconfig  <br/>
WPA/WPA2 PSK：ifconfig + iwconfig + wpa_supplicant + dhcpcd/ifconfig  <br/>
1.激活内核接口:</p>

<pre><code># ifconfig wlan0 up    
</code></pre>

<p>2.查看可以的无线接入点信息：</p>

<pre><code># iwlist wlan0 scan
</code></pre>

<p>3.根据加密方式不同，需要使用密码将无线设备关联到接入点。
假设要使用的接入点 ESSID 为 MyEssid:  <br/>
a.无加密</p>

<pre><code># iwconfig wlan0 essid "MyEssid"   
</code></pre>

<p>b.WEP  <br/>
使用十六进制密码：</p>

<pre><code># iwconfig wlan0 essid "MyEssid" key 1234567890   
</code></pre>

<p>使用 ascii 密码：</p>

<pre><code># iwconfig wlan0 essid "MyEssid" key s:asciikey   
</code></pre>

<p>c.WPA/WPA2   <br/>
需要安装 WPA_Supplicant 编辑 /etc/wpa_supplicant.conf 文件。 <br/>
a.先备份下 /etc/wpa_supplicant.conf：</p>

<pre><code>mv /etc/wpa_supplicant.conf /etc/wpa_supplicant.conf.original   
</code></pre>

<p>b.修改此文件，适合你的无线网络环境。当然可以阅读系统自带的/etc/wpa_supplicant.conf ，然后根据自己的无线环境来手动编辑。也可以使用下面的命令。</p>

<pre><code>wpa_passphrase linksys "my_secret_passkey" &gt; /etc/wpa_supplicant.conf   
</code></pre>

<p>这里，linksys代表的是要连接的无线网络的essid,而my_secret_passkey则是无线网络的密码。然后运行：</p>

<pre><code># wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf
</code></pre>

<p>假设设备使用 wext 驱动。如果无法工作，可能需要调整选项，参见 <a href="https://wiki.archlinux.org/index.php/WPA_Supplicant">WPA_Supplicant</a>。 <br/>
4.获取IP地址。
静态IP：</p>

<pre><code># ifconfig wlan0 192.168.0.2
# route add default gw 192.168.0.1
</code></pre>

<p>动态IP获取使用 DHCP：</p>

<pre><code># dhcpcd wlan0
</code></pre>

<p>如果因为“waiting for carrier”出现超时错误，可以设置通道模式为 auto</p>

<pre><code># iwconfig wlan0 channel auto 
</code></pre>

<p>注意: 尽管手动配置可以帮助解决无线问题，每次重启都需要执行这些步骤。</p>

<h2>方法二：使用管理工具来管理</h2>

<p>netcfg, newlan (AUR), wicd, NetworkManager, 等。
我使用的是NetworkManager，地址在<a href="https://wiki.archlinux.org/index.php/NetworkManager">这里</a>。</p>

<br />   


<p>本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<a href="http://tinyxd.me/blog/2012/07/16/archlinux-wireless-network-connection/">http://tinyxd.me/blog/2012/07/16/archlinux-wireless-network-connection/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[archlinux下的时间时区设置]]></title>
    <link href="http://tinyxd.me/blog/2012/07/14/archlinux-time-config/"/>
    <updated>2012-07-14T23:56:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/14/archlinux-time-config</id>
    <content type="html"><![CDATA[<p>本文方法适合于archlinux，archbang等衍生版本。archbang亲测。 <br/>
1.打开<code>/etc/rc.conf</code>，将<code>TIMEZONE</code>改为<code>"Asia/Shanghai"</code>。 <br/>
2.打开<code>/etc/rc.conf</code>，将<code>HARDWARECLOCK</code>改为<code>"localtime"</code>。 <br/>
下面是改完的rc.conf：</p>

<!--more-->


<p></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#
</span><span class='line'># /etc/rc.conf - Main Configuration for Arch Linux
</span><span class='line'>
</span><span class='line'>LOCALE="en_US.UTF-8"
</span><span class='line'>DAEMON_LOCALE="no"
</span><span class='line'>HARDWARECLOCK="localtime"
</span><span class='line'>TIMEZONE="Asia/Shanghai"
</span><span class='line'>KEYMAP="us"
</span><span class='line'>CONSOLEFONT=
</span><span class='line'>CONSOLEMAP=
</span><span class='line'>USECOLOR="yes"
</span><span class='line'>
</span><span class='line'>MODULES=()
</span><span class='line'>
</span><span class='line'>UDEV_TIMEOUT=30
</span><span class='line'>USEDMRAID="no"
</span><span class='line'>USEBTRFS="no"
</span><span class='line'>USELVM="no"
</span><span class='line'>
</span><span class='line'>HOSTNAME="archbang"
</span><span class='line'>
</span><span class='line'>interface=eth0
</span><span class='line'>address=
</span><span class='line'>netmask=
</span><span class='line'>broadcast=
</span><span class='line'>gateway=
</span><span class='line'>
</span><span class='line'>DAEMONS=(dbus networkmanager !network !dhcdbd syslog-ng @alsa @iNodeAuthService @openntpd)</span></code></pre></td></tr></table></div></figure>


<p>3.在<code>/etc/localtime</code>做个软链接给具体的<code>zoneinfo</code>：</p>

<pre><code>sudo ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime     
</code></pre>

<p>4.这个时候时区应该算是正确设置好了，把硬件时钟再同步回系统来。</p>

<pre><code>$ sudo hwclock --hctosys   
</code></pre>

<p>5.现在看时间正确了没，如果还有问题，参照archlinux的官方wiki（题外话：wiki是个好东西，可以找到你需要的）安装openNTPD，自动同步时间。</p>

<pre><code>$ sudo pacman -S openntpd   
</code></pre>

<p>配置文件看了下，基本都不用修改，直接起服务：</p>

<pre><code>$ sudo /etc/rc.d/openntpd start   
</code></pre>

<p>确保网络通畅，等一会，系统时间应该就会更新了，确实蛮方便 <br/>
最后在<code>rc.conf</code>的DAEMONS里面加上<code>@openntpd</code>，确保开机后台运行。</p>

<br />   


<p>本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<a href="http://tinyxd.me/blog/2012/07/14/archlinux-time-config/">http://tinyxd.me/blog/2012/07/14/archlinux-time-config/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[debian硬盘安装笔记]]></title>
    <link href="http://tinyxd.me/blog/2012/07/13/debian-setup/"/>
    <updated>2012-07-13T11:29:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/13/debian-setup</id>
    <content type="html"><![CDATA[<p>以前安装的时候都有光盘，这次换的机器，光驱坏了，那么有没有可能硬盘安装debian么？答案当然是可以的。 <br/>
1.下载debian最新ISO映像。 <br/>
2.下载安装所需要的vmlinuz  initrd.gz  boot.img.gz的这三个文件. <br/>
   下载地址：<a href="http://debian.osuosl.org/debian/dists/Debian6.0.5/main/installer-i386/current/images/hd-media/">http://debian.osuosl.org/debian/dists/Debian6.0.5/main/installer-i386/current/images/hd-media/</a> <br/>
3.下载grub4 for DOS    <br/>
下载地址：<a href="http://download.gna.org/grub4dos/grub4dos-0.4.4-2009-06-20.zip">http://download.gna.org/grub4dos/grub4dos-0.4.4-2009-06-20.zip</a></p>

<h2>安装过程：</h2>

<p>1、先把WINXP安装到C盘，这里唯一要说的是如果在安装WINXP时，选择了把C盘格式化为NTFS格式，那么之后安装用的DEBIAN的ISO文件就不能放在C盘了，必须放在FAT32格式的分区的根目录下。切记哦！否则硬盘安装DEBIAN时后找不到ISO文件哦。</p>

<p>WINXP安装好以后，把下载的GRUB4 for DOS包解压缩到C盘根目录，并将目录名改为grub，（个人认为不改也应该可以，不过没试，你可以试下呵），并进入GRUB目录将grldr文件复制到C盘根目录下；把vmlinuz、initrd.gz、boot.img.gz三个文件也复制到C盘根目录下：（基本上这个时候C盘是NTFS格式还是FAT32格式都没有关系的）</p>

<!--more-->


<p>2、打开C盘根目录下的boot.ini文件，打开boot.ini后在文件的最后一行加上    C:\grldr=”GRUB FOR DOS”</p>

<p>之后保存并关闭boot.ini文件。</p>

<p>3、把前面下载的DEBIAN安装CD的ISO文件复制到C盘根目录下，（要保证C盘是FAT32格式的），否则就复制到其它FAT32分区的根目录下。</p>

<p>4、以上检查没有问题后重新启动电脑，这时应该会出现如下启动菜单：</p>

<p>5、选第二项“GRUB FOR DOS”后，等屏幕出现如下画面时，按键盘上的“C”进入命令行状态。</p>

<p>6、按“C”键后屏幕显示如下：</p>

<p>7、这个时候输入如下三行命令：</p>

<pre><code>kernel (hd0,0)/vmlinuz

initrd (hd0,0)/initrd.gz

boot
</code></pre>

<p>这里的（hd0,0）指的是C盘，hd是指硬盘啦，第一个0是指电脑里的第一块硬盘，第二个0是指该硬盘上的第一个主分区，如果是第二个主分区就是（hd0,1）啦，如果你有兴趣上网查一下相关的知识了，这里不说了。</p>

<p>8、接下来就是安装debian，先会自动寻找ISO映像，找到后就开始安装，不再赘述。</p>

<p>9、如果你的C盘是FAT32格式的，ISO文件也复制到C盘根目录，那么就不用担心了，安装程序会自动找到的。（ISO文件在其它FAT32分区根目录下也一样，我已试过呵）</p>

<p>10、我的分区是这样的：/boot 200M  、2G swap、15G / 、其余大概40G的/home</p>

<p>11、等系统装好后，需要设置中文字体，还需要安装一些必要软件等等。见我以前的文章，下面是链接：<a href="http://blog.chinaunix.net/uid-26053577-id-3011222.html">http://blog.chinaunix.net/uid-26053577-id-3011222.html</a></p>

<p>本文章来自本人<strong><a href="http://blog.chinaunix.net/uid/26053577.html">ChinaUnix</a></strong>博客。  <br/>
本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<a href="http://tinyxd.me/blog/2012/07/13/debian-setup/">http://tinyxd.me/blog/2012/07/13/debian-setup/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[本地备份octopress]]></title>
    <link href="http://tinyxd.me/blog/2012/07/12/python-backup-octopress/"/>
    <updated>2012-07-12T22:42:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/12/python-backup-octopress</id>
    <content type="html"><![CDATA[<p>用python脚本备份octopress，当然也可以备份其他的目录。只要修改对应路径就可以了。</p>

<figure class='code'><figcaption><span>octopress_backup.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c">#!/usr/bin/python2</span>
</span><span class='line'><span class="c"># Filename: octopress_backup.py</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">os</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">time</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 1. 需要备份的目录(也可以将其他的文件夹一起打包)</span>
</span><span class='line'><span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;/home/tiny/octopress&#39;</span><span class="p">,</span> <span class="s">&#39;/home/tiny/mytest&#39;</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 2. 备份的目标位置</span>
</span><span class='line'><span class="n">target_dir</span> <span class="o">=</span> <span class="s">&#39;/home/tiny/backup/&#39;</span> <span class="c"># Remember to change this to what you will be using</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 3. 本脚本备份成tar，当然也可以压缩gzip。</span>
</span><span class='line'><span class="c"># 4. 日期是目录名</span>
</span><span class='line'><span class="n">today</span> <span class="o">=</span> <span class="n">target_dir</span> <span class="o">+</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s">&#39;%Y%m</span><span class="si">%d</span><span class="s">&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c"># 当前时间是备份文件的名称</span>
</span><span class='line'><span class="n">now</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s">&#39;%H%M%S&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 可以对备份的文件进行一些说明</span>
</span><span class='line'><span class="n">comment</span> <span class="o">=</span> <span class="nb">raw_input</span><span class="p">(</span><span class="s">&#39;Enter a comment --&gt; &#39;</span><span class="p">)</span>
</span><span class='line'><span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c"># check if a comment was entered</span>
</span><span class='line'>    <span class="n">target</span> <span class="o">=</span> <span class="n">today</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">sep</span> <span class="o">+</span> <span class="n">now</span> <span class="o">+</span> <span class="s">&#39;.tar&#39;</span>
</span><span class='line'><span class="k">else</span><span class="p">:</span>
</span><span class='line'>    <span class="n">target</span> <span class="o">=</span> <span class="n">today</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">sep</span> <span class="o">+</span> <span class="n">now</span> <span class="o">+</span> <span class="s">&#39;_&#39;</span> <span class="o">+</span>\
</span><span class='line'>        <span class="n">comment</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">,</span> <span class="s">&#39;_&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;.tar&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 创建子文件夹</span>
</span><span class='line'><span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">today</span><span class="p">):</span>
</span><span class='line'>    <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">today</span><span class="p">)</span> <span class="c"># make directory</span>
</span><span class='line'>    <span class="k">print</span> <span class="s">&#39;Successfully created directory&#39;</span><span class="p">,</span> <span class="n">today</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 5. tar压缩命令（unix/linux）</span>
</span><span class='line'><span class="n">tar_command</span> <span class="o">=</span> <span class="s">&quot;tar -cvf &#39;</span><span class="si">%s</span><span class="s">&#39; </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">source</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 运行备份命令</span>
</span><span class='line'><span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">tar_command</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span><span class='line'>    <span class="k">print</span> <span class="s">&#39;Successful backup to&#39;</span><span class="p">,</span> <span class="n">target</span>
</span><span class='line'><span class="k">else</span><span class="p">:</span>
</span><span class='line'>    <span class="k">print</span> <span class="s">&#39;Backup FAILED&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<br />


<p>本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<a href="http://tinyxd.me/blog/2012/07/12/python-backup-octopress/">http://tinyxd.me/blog/2012/07/12/python-backup-octopress/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux工作队列]]></title>
    <link href="http://tinyxd.me/blog/2012/07/11/linux-workqueue/"/>
    <updated>2012-07-11T23:08:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/11/linux-workqueue</id>
    <content type="html"><![CDATA[<h2>工作队列(workqueue)</h2>

<p>Linux中的Workqueue机制就是为了简化内核线程的创建。通过调用workqueue的接口就能创建内核线程。并且可以根据当前系统CPU的个数创建线程的数量，使得线程处理的事务能够并行化。</p>

<p>workqueue是内核中实现简单而有效的机制，他显然简化了内核daemon的创建，方便了用户的编程，</p>

<p>尽管可延迟函数和工作队列非常相似，但是它们的区别还是很大的。主要区别在于：可延迟函数运行在中断上下文中，而工作队列中的函数运行在进程上下文中。执行可阻塞函数（例如：需要访问磁盘数据块的函数）的唯一方式是在进程上下文中运行。因为在中断上下文中不可能发生进程切换。可延迟函数和工作队列中的函数都不能访问进程的用户态地址空间。事实上，可延迟函数被执行时不可能有任何正在运行的进程。另一方面，工作队列中的函数是由内核线程来执行的，因此，根本不存在它要访问的用户态地址空间。</p>

<h2>工作队列的数据结构</h2>

<p style="text-indent:2em">与工作队列相关的主要数据结构有两个：cpu_workqueue_struct和work_struct。名为workqueue_struct的描述符，包括一个有NR_CPUS个元素的数组，NR_CPUS是系统中CPU的最大数量（双核是有两个工作队列）。每个元素都是cpu_workqueue_struct类型的描述符。 

</p>


<p></p>

<!--more-->


<p>work_struct结构是对任务的抽象。在该结构中需要维护具体的任务方法，需要处理的数据，以及任务处理的时间。该结构定义如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">work_struct</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pending</span><span class="p">;</span>                <span class="cm">/*如果函数已经在工作队列链表中，该字段值设为1，否则设为0*/</span>
</span><span class='line'>        <span class="k">struct</span> <span class="n">list_head</span> <span class="n">entry</span><span class="p">;</span>                  <span class="cm">/* 将任务挂载到queue的挂载点 */</span>
</span><span class='line'>        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>                   <span class="cm">/* 任务方法 */</span>
</span><span class='line'>        <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>                                  <span class="cm">/* 任务处理的数据*/</span>
</span><span class='line'>       <span class="kt">void</span> <span class="o">*</span><span class="n">wq_data</span><span class="p">;</span>                           <span class="cm">/* work的属主（通常是指向cpu_workqueue_struct描述符的父结点的指针） */</span>
</span><span class='line'>       <span class="n">strut</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>                   <span class="cm">/* 任务延时处理定时器 */</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<h2>工作队列函数</h2>

<p>当用户调用workqueue的初始化接口create_workqueue或者create_singlethread_workqueue对workqueue队列进行初始化时，内核就开始为用户分配一个workqueue对象，并且将其链到一个全局的workqueue队列中。然后Linux根据当前CPU的情况，为workqueue对象分配与CPU个数相同的cpu_workqueue_struct对象，每个cpu_workqueue_struct对象都会存在一条任务队列。紧接着，Linux为每个cpu_workqueue_struct对象分配一个内核thread，即内核daemon去处理每个队列中的任务。至此，用户调用初始化接口将workqueue初始化完毕，返回workqueue的指针。</p>

<p>在初始化workqueue过程中，内核需要初始化内核线程，注册的内核线程工作比较简单，就是不断的扫描对应cpu_workqueue_struct中的任务队列，从中获取一个有效任务，然后执行该任务。所以如果任务队列为空，那么内核daemon就在cpu_workqueue_struct中的等待队列上睡眠，直到有人唤醒daemon去处理任务队列.</p>

<p>Workqueue初始化完毕之后，将任务运行的上下文环境构建起来了，但是具体还没有可执行的任务，所以，需要定义具体的work_struct对象。然后将work_struct加入到任务队列中，Linux会唤醒daemon去处理任务。</p>

<p>queue_work()（封装在work_struct描述符中）把函数插入工作队列，它接收wq和work两个指针。wq指向workqueue_struct描述符，work指向work_struct描述符。queue_work（）主要执行下面的步骤：</p>

<p>1.检查要插入的函数是否已经在工作队列中（work->pending字段等于1），如果是就结束。</p>

<p>2.把work_struct描述符加到工作队列链表中，然后把work->pending置为1。</p>

<p>3.如果工作者线程在本地CPU的cpu_workqueue_struct描述符的more_work等待队列上睡眠，该函数唤醒这个线程。</p>

<h2>预定义工作队列</h2>

<p>在绝大多数情况下，为了运行一个函数而创建整个工作者线程开销太大了。因此，内核引入叫做events的预定义工作队列，所有的内核开发者都可以随便使用它。预定义工作队列只是一个包含不同内核层函数和IO驱动程序的标准工作队列，它的workququq_struct描述符存放在keventd_wq数组中。</p>

<p>工作队列编程接口：</p>

<table border="1"> 
<tr> 
    <th>序号</th> 
    <th>接口函数</th>  
    <th>函数说明</th> 
</tr>  
<tr>  
    <td>1</td>  
    <td>create_workqueue</td> 
    <td>用于创建一个workqueue队列，为系统中的每个CPU都创建一个内核线程。输入参数：@name：workqueue的名称</td> 
</tr>  
<tr>  
    <td>2</td>  
    <td>create_singlethread_workqueue</td>  
    <td>用于创建一个workqueue队列，为系统中的每个CPU都创建一个内核线程。输入参数：@name：workqueue的名称</td> 
</tr> 
<tr> 
    <td>3</td> 
    <td>destroy_workqueue</td> 
    <td>释放workqueue队列。输入参数：@ workqueue_struct：需要释放的workqueue队列指针</td> 
</tr>  
<tr> 
    <td>4</td> 
    <td>schedule_work</td> 
    <td>调度执行一个具体的任务，执行的任务将会被挂入Linux系统提供的workqueue——keventd_wq输入参数：@ work_struct：具体任务对象指针 
</td> 
</tr>  
<tr> 
    <td>5</td> 
    <td>schedule_delayed_work</td> 
    <td>延迟一定时间去执行一个具体的任务，功能与schedule_work类似，多了一个延迟时间，输入参数：@work_struct：具体任务对象指针@delay：延迟时间</td> 
</tr>  
<tr> 
    <td>6</td> 
    <td>queue_work</td> 
    <td>调度执行一个指定workqueue中的任务。输入参数：@ workqueue_struct：指定的workqueue指针@work_struct：具体任务对象指针</td> 
</tr>  
<tr> 
    <td>7</td> 
    <td>queue_delayed_work</td> 
    <td>延迟调度执行一个指定workqueue中的任务，功能与queue_work类似，输入参数多了一个delay</td> 
</tr>  
</table>


<p></p>

<p>预定义工作队列支持函数:</p>

<table > 
<tr> 
    <td>预定义工作队列函数</td> 
    <td>等价的标准工作队列函数</td> 
</tr> 
<tr> 
    <td>schedule_work(w)</td>     
    <td>queue_work( keventd_wq,w)</td> 
</tr> 
<tr> 
    <td>schedule_delayed_work(w,d)</td>     
    <td>queue_delayed_work(keventd_wq,w,d)在任何CPU上</td> 
</tr> 
<tr> 
    <td>schedule_delayed_work_on(cpu,w,d)</td>     
    <td>queue_delayed_work(keventd_wq,w,d)（在某个指定的CPU上）</td> 
</tr> 
<tr> 
    <td>flush_scheduled_work</td>     
    <td>flush_workqueue(keventd_wq)</td> 
</tr> 
</table>


<p></p>

<p>除了一般的events队列，在linux2.6中你还会发现一些专用的工作队列。其中最重要的是快设备层使用的kblockd工作队列。</p>

<p>本文章整理自网络和《深入理解linux内核》。  <br/>
本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<a href="http://tinyxd.me/blog/2012/07/11/linux-workqueue/">http://tinyxd.me/blog/2012/07/11/linux-workqueue/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软中断和tasklet]]></title>
    <link href="http://tinyxd.me/blog/2012/07/11/soft-interrupt-and-tasklet/"/>
    <updated>2012-07-11T22:57:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/11/soft-interrupt-and-tasklet</id>
    <content type="html"><![CDATA[<h2>软中断：</h2>

<p>Linux中的软中断机制用于系统中对时间要求最严格以及最重要的中断下半部进行使用。在系统设计过程中，大家都清楚中断上下文不能处理太多的事情，需要快速的返回，否则很容易导致中断事件的丢失，所以这就产生了一个问题：中断发生之后的事务处理由谁来完成？在前后台程序中，由于只有中断上下文和一个任务上下文，所以中断上下文触发事件，设置标记位，任务上下文循环扫描标记位，执行相应的动作，也就是中断发生之后的事情由任务来完成了，只不过任务上下文采用扫描的方式，实时性不能得到保证。在Linux系统和Windows系统中，这个不断循环的任务就是本文所要讲述的软中断daemon。在Windows中处理耗时的中断事务称之为中断延迟处理，在Linux中称之为中断下半部，显然中断上半部处理清中断之类十分清闲的动作，然后在退出中断服务程序时触发中断下半部，完成具体的功能。</p>

<p>在Linux中，中断下半部的实现基于软中断机制。所以理清楚软中断机制的原理，那么中断下半部的实现也就非常简单了。通过上述的描述，大家也应该清楚为什么要定义软中断机制了，一句话就是为了要处理对时间要求苛刻的任务，恰好中断下半部就有这样的需求，所以其实现采用了软中断机制。</p>

<p>linux2.6中使用的软中断：</p>

<figure class='code'><figcaption><span>interrupt.h</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">enum</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">HI_SOFTIRQ</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="cm">/*用于高优先级的tasklet(下标(优先级0))*/</span>
</span><span class='line'>  <span class="n">TIMER_SOFTIRQ</span><span class="p">,</span> <span class="cm">/*用于定时器的下半部(下标(优先级1))*/</span>
</span><span class='line'>  <span class="n">NET_TX_SOFTIRQ</span><span class="p">,</span><span class="cm">/*用于网络层发包(下标(优先级2))*/</span>
</span><span class='line'>  <span class="n">NET_RX_SOFTIRQ</span><span class="p">,</span> <span class="cm">/*用于网络层收报(下标(优先级3))*/</span>
</span><span class='line'>  <span class="n">SCSI_SOFTIRQ</span><span class="p">,</span> <span class="cm">/*用于scsi设备(下标(优先级4))*/</span>
</span><span class='line'>  <span class="n">TASKLET_SOFTIRQ</span> <span class="cm">/*用于低优先级的tasklet(下标(优先级5))*/</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>一个软中断的下标决定了它的优先级；低下标意味着高优先级，因为软中断函数将从下标0开始执行。</p>

<h2>tasklet:</h2>

<p>Tasklet为一个软中断，考虑到优先级问题，分别占用了向量表中的0号和5号软中断。</p>

<p>tasklet是IO驱动程序中实现可延迟函数的首选方法。其建立在两个叫HI_SOFTIRQ和TASKLET_SOFTIRQ的软中断之上。</p>

<h2>软中断和tasklet</h2>

<p>软中断和tasklet有密切的关系，tasklet是在软中断之上实现。事实上，出现在内核代码中的术语“软中断（softirq）” 常常表示可延迟函数的所有种类。另外一种被广泛使用的术语是“中断上下文”：表示内核当前正在执行一个中断处理程序或一个可延迟的函数。</p>

<p>软中断的分配是静态的（即在编译时定义），而tasklet的分配和初始化可以在运行时进行（例如：安装一个内核模块时）。软中断（即便是同一种类型的软中断）可以并发地运行在多个CPU上。因此，软中断是可重入函数而且必须明确地使用自旋锁保护其数据结构。tasklet不必担心这些问题，因为内核对tasklet的执行进行了更加严格的控制。相同类型的tasklet总是被串行地执行，换句话说就是：不能在两个CPU上同时运行相同类型的tasklet。但是，类型不同的tasklet可以在几个CPU上并发执行。tasklet的串行化使tasklet函数不必是可重入的，因此简化了设备驱动程序开发者的工作。</p>

<p>一般而言，可延迟函数上可以执行四种函数：初始化、激活、屏蔽和执行。</p>

<h2>软中断的主要数据结构</h2>

<p>软中断的主要数据结构是softirq_vec数组，该数组包含类型为softirq_action的32个元素。一个软中断的优先级是相应的softirq_action元素在数组内的下标，只有前六个被有效使用。</p>

<p>/*表示softirq最多可以有32种类型，实际上linux只使用了六种，见文件interrupt.h*/</p>

<p>static struct softirq_action softirq_vec[32] __cacheline_aligned_in_smp;</p>

<p>softirq_action数据结构包括两个字段：指向软中断函数的一个action指针和指向软中断函数需要的通用数据结构的data指针。</p>

<p>还有一个关键的字段是32位的preempt_cout字段，用它来跟踪内核抢占和内核控制路径的嵌套，该字段存放在每个进程描述符的thread_info字段中。</p>

<p>对于softirq，linux kernel中是在中断处理程序执行的，具体的路径为：</p>

<pre><code>do_IRQ() --&gt; irq_exit() --&gt; invoke_softirq() --&gt; do_softirq() --&gt; __do_softirq() 
</code></pre>

<p>在__do_softirq()中有这么一段代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>    <span class="k">do</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">pending</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>                    <span class="n">h</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>                    <span class="n">rcu_bh_qsctr_inc</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">h</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">pending</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pending</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>你看，这里就是对softirq进行处理了，因为pengding是一个__u32的类型，所以每一位都对应了一种softirq，正好是32种（linux kernel中实际上只使用了前6种 ）. h->action(h),就是运行softirq的处理函数。</p>

<p>对于tasklet，前面已经说了，是一种特殊的softirq，具体就是第0和第5种softirq，所以说tasklet是基于softirq来实现的。</p>

<p>tasklet既然对应第0和第5种softirq，那么就应该有对应的处理函数，以便h->action()会运行tasklet的处理函数。</p>

<p>我们看代码：</p>

<figure class='code'><figcaption><span>softirq.c </span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="n">__init</span> <span class="nf">softirq_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">open_softirq</span><span class="p">(</span><span class="n">TASKLET_SOFTIRQ</span><span class="p">,</span> <span class="n">tasklet_action</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">open_softirq</span><span class="p">(</span><span class="n">HI_SOFTIRQ</span><span class="p">,</span> <span class="n">tasklet_hi_action</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里注册了两种tasklet所在的softirq的处理函数，分别对应高优先级的tasklet和低优先级的tasklet。</p>

<p>我们看低优先级的吧（高优先级的也一样）。</p>

<figure class='code'><figcaption><span>tasklet_action</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">tasklet_action</span><span class="p">(</span><span class="k">struct</span> <span class="n">softirq_action</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">local_irq_disable</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">list</span> <span class="o">=</span> <span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">tasklet_vec</span><span class="p">).</span><span class="n">list</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">tasklet_vec</span><span class="p">).</span><span class="n">list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">local_irq_enable</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">while</span> <span class="p">(</span><span class="n">list</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>                <span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>                <span class="n">list</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">tasklet_trylock</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>                                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">TASKLET_STATE_SCHED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'>                                        <span class="n">BUG</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>                                <span class="n">t</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>                                <span class="n">tasklet_unlock</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>                                <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>                        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>                        <span class="n">tasklet_unlock</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>                <span class="n">local_irq_disable</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>                <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">tasklet_vec</span><span class="p">).</span><span class="n">list</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>                <span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">tasklet_vec</span><span class="p">).</span><span class="n">list</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>                <span class="n">__raise_softirq_irqoff</span><span class="p">(</span><span class="n">TASKLET_SOFTIRQ</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>                <span class="n">local_irq_enable</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>你看，在运行softirq的处理时（__do_softirq），对于</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>    <span class="k">do</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">pending</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>                    <span class="n">h</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>                    <span class="n">rcu_bh_qsctr_inc</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">h</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">pending</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pending</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果tasklet有任务需要处理，会运行到h->action()，这个函数指针就会指向tasklet_action()，然后在tasklet_action()里再去执行tasklet对应的各个任务，这些任务都是挂在一个全局链表里面的，具体的代码这里就不分析了。</p>

<p>另外， softirq在smp中是可能被同时运行的，所以softirq的处理函数必须被编写成可重入的函数。</p>

<p>但tasklet是不会在多个cpu之中同时运行的，所以tasklet的处理函数可以编写成不可重入的函数，这样就减轻了编程人员的负担。</p>

<h2>ksoftirqd内核线程</h2>

<p>在最近的内核版本中，每个CPU都有自己的ksoftirqd/n内核线程（这里，n为CPU的逻辑号）。每个ksoftirqd/n内核线程都运行ksoftirqd()函数。在预期的时间内处理挂起的软中断。</p>

<br />


<p>本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<a href="http://tinyxd.me/blog/2012/07/11/soft-interrupt-and-tasklet/">http://tinyxd.me/blog/2012/07/11/soft-interrupt-and-tasklet/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux文件系统]]></title>
    <link href="http://tinyxd.me/blog/2012/07/10/linux-filesysterm/"/>
    <updated>2012-07-10T23:26:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/10/linux-filesysterm</id>
    <content type="html"><![CDATA[<p>linux文件操作：文件操作系统调用（create、open、read、write、lseek、close）、c库文件操作（fopen、fscanf、fprintf、fread、fwrite、fseek、fclose等）。</p>

<p>linux文件系统：在设备驱动程序的设计中，一般会关心file和inode这两个结构体。</p>

<h2>devfs、udev、sysfs的区别：</h2>

<p>以下内容来自<a href="http://blog.csdn.net/yeqishi/article/details/5491413">devfs, sysfs, udev文件系统区别</a> 和 linux设备驱动开发详解（第二版）</p>

<h3>一.devfs设备文件简略介绍(2.6版本以后内核都采用udev设备文件系统)</h3>

<p>devfs(设备文件系统)是由2.4内核引入的，具有如下优点：</p>

<p>1.可以通过程序在设备初始化时在/dev目录下创建设备文件，卸载时将它删除。</p>

<p>2.设备驱动程序可以指定设备号,所有者,和权限位,用户空间可以修改所有者和权限位。</p>

<p>3.不再需要为设备驱动程序分配主设备号以及处理的次设备号，在程序可以直接给register_chrdev()传递0主设备号以动态获得可用的主设备号，并在devfs_register() 中指定次设备号。</p>

<!--more-->


<p>在2.6内核以前一直使用的是 devfs，devfs挂载于/dev目录下，提供了一种类似于文件的方法来管理位于/dev目录下的所有设备，我们知道 /dev目录下的每一个文件都对应的是一个设备，至于当前该设备存在与否先且不论，而且这些特殊文件是位于根文件系统上的，在制作文件系统 的时候我们就已经建立了这些设备文件，因此通过操作这些特殊文件，可以实现与内核进行交互。但是devfs文件系统有一些缺点，例如：不确定的设备映射，有时一个设备映射的设备文件可能不同，例如我的U盘可能对应sda有可能对应sdb；没有足够的主/辅设备号，当设备过多的时候，显然这会成为一个问题；/dev目录下文件太多而且不能表示当前系统上的实际设备；命名不够灵活，不能任意指定等等。</p>

<br />


<h3>二.sysfs</h3>

<p>从Fedora 2开始，在根目录下会有一个/sys目录，mount 看一下，这个目录挂装了一个sysfs的文件系统。</p>

<p>Linux 2.6 的内核引入了 sysfs 文件系统。sysfs 被看成是与 proc，devfs，和 devpty 同类别的文件系统。sysfs 把连接在系统上的设备和总线组织成为一个分级的文件，它们可以被从用户的空间存取到。这是被设计用来处理那些以前驻留在 /proc/ 的设备和驱动程序指定的选件以及用来处理那些以前由 devfs 提供支持的动态加载设备。在早期的 sysfs 实现中，一些驱动和应用仍然被当做老的 proc 条目。但是 sysfs 是未来的发展方向。</p>

<p>sysfs 被加载在 /sys/ 系统中。它所包括的目录可以使用不同的方式来治理连接在系统上的设备。/sysfs/ 中的子目录包括：</p>

<p>/devices/ 目录这个目录包括 /css0/。它的子目录代表了所有被 Linux 内核检测到的子通道。子通道目录的命名格式是 0.0.nnnn，其中的 nnnn 是子通道的十六进制代码 (0到ffff)。子通道目录包括状态文件和其他代表实际设备的设备子目录。设备目录的格式是：0.0.xxxx，其中的 xxxx 是这个设备的单元地址。/devices/ 还包括了状态信息和设备的配置选项。</p>

<p>/bus/ 目录这个目录包括了 /ccw/ 和 /ccwgroup/ 两个子目录。CCW 设备可以通过使用通道命令来存取。在 /ccw/ 目录中的设备只使用一个子通道。CCW 组设备也可以通过使用通道命令来存取，但是它们的每个设备使用多于一个的子通道。比如：一个3390-3 DASD 设备使用一个子通道，但是一个 OSA 适配器的 QDIO 网络连接使用三个子通道。/ccw/ 和 /ccwgroup/ 目录都包括设备目录和驱动器目录：</p>

<p>/devices/ 目录包括了到 /sys/devices/css0/ 目录的设备目录的符号链接。/drivers 目录包括了所有由代表当前被系统加载的设备的驱动程序的目录。zFCP 驱动程序有一个目录在这里。/driver/ 目录包括了设备驱动程序的设置和它使用的符号链接 (/sys/devices/css0/ 目录)/class/ 目录/class/ 目录包括了代表由相似功能的设备组成的组 (ttys，SCSI 磁带驱动器，网络设备&#8230;)的目录。</p>

<p>/block/ 目录这个目录包括了系统中的每一个块设备的目录。块设备主要是磁盘类的设备，例如 DASD，回送设备，以及软件磁盘冗余阵列设备。一个与老版本 Linux 不同的是，使用 sysfs 系统的 Linux 需要使用设备在 sysfs 中的名字来指定设备。在一个 2.4 版本的内核映像中，zFCP 驱动程序是由它的设备地址来指定的。但是在 2.6 版本的内核映像中，它的驱动程序是由 0.0.1600 来指定的。</p>

<br />


<h3>三.udev设备文件详细介绍</h3>

<p>   devfs 存在的主要的问题是它处理设备检测、创建和命名的方式，其中设备节点的命名可能是最严重的问题。一般可接受的方式是，如果设备名是可配置的，那么设备命名策略应该由系统管理员决定，而不是由某些开发者强制规定。devfs 文件系统还存在竞争条件(race conditions)的问题，这是它天生的设计缺陷，不对内核做彻底的修改就无法修正这个问题。</p>

<p>   上篇文章简单介绍sysfs文件系统，您可能想知道 sysfs 是怎么认出系统中存在的设备以及应该使用什么设备号。对于已经编入内核的驱动程序，当被内核检测到的时候，会直接在 sysfs 中注册其对象；对于编译成模块的驱动程序，当模块载入的时候才会这样做。一旦挂载了 sysfs 文件系统(挂载到 /sys)，内建的驱动程序在 sysfs 注册的数据就可以被用户空间的进程使用，并提供给 udev 以创建设备节点。</p>

<p>   udev 初始化脚本负责在 Linux 启动的时候创建设备节点，该脚本首先将 /sbin/udevsend 注册为热插拔事件处理程序。热插拔事件(随后将讨论)本不应该在这个阶段发生，注册 udev 只是为了以防万一。然后 udevstart 遍历 /sys 文件系统，并在 /dev 目录下创建符合描述的设备。例如，/sys/class/tty/vcs/dev 里含有&#8221;7:0&#8221;字符串，udevstart 就根据这个字符串创建主设备号为 7 、次设备号为0 的 /dev/vcs 设备。udevstart 创建的每个设备的名字和权限由 /etc/udev/rules.d/ 目录下的文件指定的规则来设置。如果 udev 找不到所创建设备的权限文件，就将其权限设置为缺省的 660 ，所有者为 root:root 。</p>

<p>   上面的步骤完成后，那些已经存在并且已经内建驱动的设备就可以使用了，那么以模块驱动的设备呢？</p>

<p>   前面我们提到了&#8221;热插拔事件处理程序&#8221;的概念，当内核检测到一个新设备连接时，内核会产生一个热插拔事件，</p>

<p>   并在 /proc/sys/kernel/hotplug 文件里查找处理设备连接的用户空间程序。udev 初始化脚本将 udevsend 注册为该处理程序。</p>

<p>   当产生热插拔事件的时候，内核让 udev 在 /sys 文件系统里检测与新设备的有关信息，并为新设备在 /dev 里创建项目。</p>

<p>   大多数 Linux 发行版通过 /etc/modules.conf 配置文件来处理模块加载，对某个设备节点的访问导致相应的内核模块被加载。对 udev 这个方法就行不通了，因为在模块加载前，设备节点根本不存在。为了解决这个问题，在 LFS-Bootscripts 软件包里加入了 modules 启动脚本，以及 /etc/sysconfig/modules 文件。通过在 modules 文件里添加模块名，就可以在系统启动的时候加载这些模块，这样 udev 就可以检测到设备，并创建相应的设备节点了。如果插入的设备有一个驱动程序模块但是尚未加载，Hotplug 软件包就有用了，它就会响应上述的内核总线驱动热插拔事件并加载相应的模块，为其创建设备节点，这样设备就可以使用了。</p>

<p>   udev是一种工具，它能够根据系统中的硬件设备的状况动态更新设备文件，包括设备文件的创建，删除等。设备文件通常放在/dev目录下，使用udev 后,在/dev下面只包含系统中真实存在的设备。它于硬件平台无关的，位于用户空间，需要内核sysfs和tmpfs的支持，sysfs为udev提供设备入口和uevent通道，tmpfs为udev设备文件提供存放空间。</p>

<p>   显而易见<code>udev设备文件的优点</code>：</p>

<p>   1.udev完全在用户态工作，利用设备加入或移除时内核所发送的热插拔事件。在热插拔时，设备的详细信息会由内核输出到位于/sys的sysfs文件系统。udev的设备命名策略权限控制都在用户态完成的，它利用sysfs信息来进行创建设备文件节点。</p>

<p>   2.udev根据系统中的硬件设备的状态动态更新设备文件，进行设备文件的创建和删除等。</p>

<p>   注：使用udev,/dev目录下就会只包含系统中真正存在的设备。</p>

<p>   注：所有在 sysfs 中显示的设备都可以由 udev 来创建节点。如果内核中增加了其它设备的支持，</p>

<p>   udev 也就自动地可以为它们工作了。在init初始化之前，udev 可以被放入 initramfs 之中，并在每个设备被发现的时候运行。</p>

<p>   也可以让udev 工作在一个真的根分区被加载之后根据 /sys 的内容创建的初始 /dev 目录之中</p>

<br />


<h3>四.udev和devfs设备文件的对比</h3>

<p>1.udev能够实现所有devfs实现的功能。但udev运行在用户模式中，而devfs运行在内核中。</p>

<p>2.当一个并不存在的 /dev 节点被打开的时候， devfs一样自动加载驱动程序而udev确不能。</p>

<p>  udev设计时，是在设备被发现的时候加载模块，而不是当它被访问的时候。</p>

<p>  devfs这个功能对于一个配置正确的计算机是多余的。系统中所有的设备都应该产生</p>

<p>  hotplug 事件、加载恰当的驱动，而 udev 将会注意到这点并且为它创建对应的</p>

<p>  设备节点。如果你不想让所有的设备驱动停留在内存之中，应该使用其它东西来</p>

<p>  管理你的模块 (如脚本, modules.conf, 等等) 。</p>

<p>  其中devfs 用的方法导致了大量无用的 modprobe 尝试，以此程序探测设备是否存在。</p>

<p>  每个试探性探测都新建一个运行 modprobe 的进程，而几乎所有这些都是无用的。</p>

<p>3.udev是通过对内核产生的设备名增加别名的方式来达到上述目的的。前面说过，udev是用户模式程序，不会更改内核的行为。</p>

<p>因此，内核依然会我行我素地产生设备名如sda,sdb等。但是，udev可以根据设备的其他信息如总线（bus），生产商（vendor）等</p>

<p>不同来区分不同的设备，并产生设备文件。udev只要为这个设备文件取一个固定的文件名就可以解决这个问题。在后续对设备的操作中，</p>

<p>只要引用新的设备名就可以了。但为了保证最大限度的兼容，一般来说，</p>

<p>新设备名总是作为一个对内核自动产生的设备名的符号链接（link）来使用的。</p>

<p><strong>例如</strong>：内核产生了sda设备名，而根据信息，这个设备对应于是我的内置硬盘，那我就可以制定udev规则，让udev除了产生/dev/sda设备文件外，另外创建一个符号链接叫/dev/internalHD。这样，我在fstab文件中，就可以用/dev/internalHD来代替原来的 /dev/sda了。下次，由于某些原因，这个硬盘在内核中变成了sdb设备名了，那也不用着急，udev还会自动产生/dev/internalHD这个链接，并指向正确的/dev/sdb设备。所有其他的文件像fstab等都不用修改。</p>

<p>而在在2.6内核以前一直使用的是 devfs，devfs挂载于/dev目录下，提供了一种类似于文件的方法来管理位于/dev目录下的所有设备，但是devfs文件系统有一些缺点，例如：不确定的设备映射，有时一个设备映射的设备文件可能不同，例如我的U盘可能对应sda有可能对应sdb 。</p>

<p>注：可以用命令查看其中的信息，    udevinfo -a -p /sys/block/sda</p>

<p>在此之前的设备文件管理方法（静态文件和devfs）有几个缺点：</p>

<p><strong> 不确定的设备映射。</strong>特别是那些动态设备，比如USB设备，设备文件到实际设备的映射并不可靠和确定。举一个例子：如果你有两个USB打印机。一个可能称为 /dev/usb/lp0,另外一个便是/dev/usb/lp1。但是到底哪个是哪个并不清楚，lp0,lp1和实际的设备没有一一对应的关系，因为他可能因为发现设备的顺序，打印机本身关闭等原因而导致这种映射并不确定。理想的方式应该是：两个打印机应该采用基于他们的序列号或者其他标识信息的唯一设备文件来映射。但是静态文件和devfs都无法做到这点。</p>

<p><strong>没有足够的主/辅设备号。</strong>我们知道，每一个设备文件是有两个8位的数字：一个是主设备号 ，另外一个是辅设备号来分配的。这两个8位的数字加上设备类型（块设备或者字符设备）来唯一标识一个设备。不幸的是，关联这些身边的的数字并不足够。</p>

<p><strong>/dev目录下文件太多。</strong>一个系统采用静态设备文件关联的方式，那么这个目录下的文件必然是足够多。而同时你又不知道在你的系统上到底有那些设备文件是激活的。</p>

<p><strong>命名不够灵活。</strong>尽管devfs解决了以前的一些问题，但是它自身又带来了一些问题。其中一个就是命名不够灵活；你别想非常简单的就能修改设备文件的名字。缺省的devfs命令机制本身也很奇怪，他需要修改大量的配置文件和程序。;</p>

<p><strong>内核内存使用</strong>，devfs特有的另外一个问题是，作为内核驱动模块，devfs需要消耗大量的内存，特别当系统上有大量的设备时（比如上面我们提到的系统一个上有好几千磁盘时）</p>

<p>udev的目标是想解决上面提到的这些问题，他通采用用户空间(user-space)工具来管理/dev/目录树，他和文件系统分开。知道如何改变缺省配置能让你如何定制自己的系统，比如创建设备字符连接，改变设备文件属组，权限等。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给octopress博客添加豆瓣侧边栏]]></title>
    <link href="http://tinyxd.me/blog/2012/07/09/add-douban-aside/"/>
    <updated>2012-07-09T22:38:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/09/add-douban-aside</id>
    <content type="html"><![CDATA[<p>1.添加<code>source/_includes/custom/asides/douban.html</code></p>

<div><script src='https://gist.github.com/3076932.js?file=douban.html'></script>
<noscript><pre><code>{% if site.douban_user %}
&lt;section&gt;
&lt;h2&gt;Reading List&lt;/h2&gt;
&lt;div&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.douban.com/service/badge/tinyxd/?show=dolist&amp;amp;select=random&amp;amp;n=6&amp;amp;columns=3&amp;amp;hidelogo=yes&amp;amp;hideself=yes&quot; &gt;&lt;/script&gt;
&lt;/div&gt;
&lt;/section&gt;
{% endif %}</code></pre></noscript></div>


<p>其中<code>&lt;div&gt; &lt;/div&gt;</code>中间的代码从<a href="http://www.douban.com/service/badgemakerjs">这里</a>获取，记得改成自己的哦！ <br/>
2.在<code>_config.yml</code>中添加：     <br/>
douban_user: XXX<br/>
(XXX为你的豆瓣用户名) <br/>
3.记得把这里（default_asides: ）加上douban.html的位置
然后，<code>rake generate</code> 和<code>rake preview</code>看看效果吧  <br/>
类似微薄侧边浪也是这么弄的。</p>

<br />


<p>本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<a href="http://tinyxd.me/blog/2012/07/09/add-douban-aside/">http://tinyxd.me/blog/2012/07/09/add-douban-aside/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IT生活：10个继续干IT的理由]]></title>
    <link href="http://tinyxd.me/blog/2012/07/09/reasons-to-stay-in-it/"/>
    <updated>2012-07-09T00:25:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/09/reasons-to-stay-in-it</id>
    <content type="html"><![CDATA[<blockquote><p>前面我们曾经分析过不要做IT的十个理由，现在反方有话要说了。一位曾经混迹IT江湖几进几出的过来人现身说法：“曾经有一份美好的工作摆在我的面前，我没有珍惜，等到失去时才后悔莫及。人生最悲哀的事情莫过于此。如果上天能再给我一次重来的机会，我会对那份工作说三个字：我爱你。如果非给这份职业加个期限，我希望是一万年！”</p></blockquote>


<p></p>

<br />


<p>作者：Alan Norton 2011年7月1日， 1:27 PM PDT <br/>
摘要： 不想干IT了？ Alan Norton就是这么想的，还不止一次。看看为什么他会说有10个理由继续呆在IT这个行当里。</p>

<p>在其文章<a href="http://article.yeeyan.org/view/boxi/176955">《不干IT的十个理由》</a>中，Jack Wallen列举了一些离开IT这个行业的理由。而我呢，则愿意提供一个不同的观点，下面有我自己的一些思考，这些也许能对阐明为什么你应当留在IT有所帮助。</p>

<p>1: 钱，钱，钱</p>

<p>对，我们努力工作就是为了赚钱，而IT专业人士的努力工作的确得到了很好的补偿。报酬不仅仅是好而已，而是非常棒。根据美国劳工部<a href="http://www.bls.gov/oes/highlight_2010.pdf">《2010年美国就业与报酬情况概览》</a>（表6，PDF）的统计数据 ，在所有的职业群体当中，计算机和数学2010年的排行并列第三，年均工资为77230美元。只有管理和法律的报酬比IT高。</p>

<br />




<!--more-->


<p> <br/>
2: 专业</p>

<p>如果你跟我一样，跟谁在一起工作是件非常重要的事情。毕竟，在你生命里将会有超过四分之一的时间要跟他们在一起。我跟<a href="http://www.techrepublic.com/blog/10things/10-things-that-define-a-true-professional/1685">专业的人</a>和<a href="http://www.techrepublic.com/blog/10things/10-toxic-character-types-youll-meet-on-the-job/2492">不那么专业的人</a>都共事过。我倾向于接触前者、回避后者。我也在别的职业领域遇到过专业人士，如果要我列举说明的话，比如说国防工业，但是IT的专业人士依旧排行前列。</p>

<p>3: 职业连续性</p>

<p>我第二次离开IT的时候，就只想着休息，什么事都不做。然后我发现（太迟了）离开自己的职业后想要返回会更加困难。最大的问题是潜在的老板会怎么看你。老板不希望看到你的履历中出现断层。这种不幸的机会可能会被你撞上，那就是你会发现<a href="http://www.techrepublic.com/blog/career/are-the-jobless-discriminated-against-in-hiring/3072">对失业的歧视的真实性存在</a>会给你带来一条艰困之道。<br/>
4: 挑战</p>

<p>我现则写计算机程序的其中一个理由是我发现它充满挑战。在编写代码的时候，前进的道路上没有一天是不会遇到至少一个障碍的。IT专业人士在解决困惑和问题中成长。有了正确的态度（这对于在IT上取得成功是必不可少的），障碍就会变成挑战。信息技术是充满挑战，但是你却不会感到厌烦。无论你在IT里面的角色怎样，你明天所遇到的挑战很可能就会跟今天所经历的不一样。
5: 回报
当你遇到挑战的时候是有回报的——这是选择并留在这个行当的另一个理由。当自己写的程序按照设计运行，没有错误出现的时候，或者是当一个长期的系统项目成功地按时完成的时候，我的职业满意度就会前所未有地高。好吧，也许你对拯救生命并没有什么帮助。但是，如果实在为医疗人员提供支持的话，那么你就是在拯救生命。同时你也在拯救蓝领和白领工人，拯救他们于单调乏味的、可由、也应该由机器完成的任务之中。喜欢做繁重工作的人寥寥无几。我职业生涯中建设的系统替代了若干的无意义工作。坦率地说， 除了少数几段艰难时期，意识到我正在帮助别人把工作做得更好之后，我工作结束的时候都是满意地离开的。无论你在IT的众所担当的角色是什么，帮助别人并出色完成工作都会令人产生自尊感和成就感，这都是很高的回报。</p>

<p><a href="http://www.techrepublic.com/forum/discussions/102-342385-3430107?tag=discussion-thread">正如TR的成员Chronological所说的那样</a>，“有史以来最具挑战的性工作？也许是。最有内涵的工作？——100%确定。”<br/>
6: 畅销</p>

<p>IT职业人员找工作保工作的机会要好得多。IT专业人士的前途一片光明——至少在美国是这样的。前20佳职业中有5个是IT岗位，前50大薪水最高且最具增长潜力的的职业里面有14个也是IT岗位，这是<a href="http://money.cnn.com/magazines/moneymag/bestjobs/2010/full_list/index.html">CNN金钱与薪资表的调查结果</a>。<br/>
7: 技能
那些想干IT的人通常都是相当聪明的，都具有<a href="http://www.techrepublic.com/blog/10things/10-things-you-gotta-have-to-succeed-in-it/2421">独特的品质</a>和技能。 IT吸引了<a href="http://www.techrepublic.com/blog/10things/10-curses-of-the-analytical-thinker/2466">分析型人士</a>并让世界发生技术性倾斜。如果你具备这些品质和技能，你就能在IT找到一个家。</p>

<p>另一个留在IT的好理由是让你的技能与时俱进。离开IT太久的话的你的技能就会过时或者甚至被淘汰。在你离开IT之前，想想吧，是你的老板出钱让你学习新技能并保持已有技能跟得上形势。那些技能是对你未来的投资。</p>

<p>8: 尊重
Jack在他的文章中提到，IT专业人士得不到大众的尊重。我从在论坛的反馈中得知你们当中有许多人都同意这一点，并感觉到自己没有得到威望以及渴望中的尊重。如果你自己的工作干得很出色却感到缺乏尊重，也许其原因要归咎于旁观者地无知，而非你自己的过失。</p>

<p>公众也许是块硬骨头，但是你可以在你的同事那里获得尊重。富于知识和智慧的专业人士重视他人的贡献，并会表明其对同事的尊重。IT是赢得尊重的好地方。如果你不能够在IT这个领域赢得尊重，那么很有可能在别的任何地方也得不到它。</p>

<p>也许只是我本人比较幸运或幼稚了点，但我一直都认为自己赢得了经理、助手和客户的尊重。可能最重要的是，尊重是一种态度，你的态度，以及你对别人如何看待你的感知。<br/>
9: 极客</p>

<p>IT是满足你对极端技术之渴望的绝佳场所。还有什么别的地方既能够满足你的极客需求又能为此付钱给你的呢？ 如果你享受按字节、GHz、图表、里程碑，还有IF THEN ELSE语句进行思考的方式，你就会喜欢上跟你有着共同兴趣和相同的独特语言的他人共事。</p>

<p>10: 热爱
许多选择干IT的人热爱这项事业。快点承认吧。在内心深处你热爱自己的工作。就那些不是这样的人来说，那也是相对而言的。在考虑其他面向大众的工作及其薪水时，你就会热爱上IT。如果你从自身和自己的IT工作上面找不出一丝的热爱，那么也许分道扬镳的时候快到了。</p>

<p>也许<a href="http://www.techrepublic.com/forum/discussions/102-254217-2432699?tag=discussion-thread">讲得最好</a>的是在一次讨论中IT_Goddess的说法： “有多少人能够说自己真的喜欢乃至热爱自己的工作？我认识的好多人，都不是干IT的，都害怕投入工作。而我认识的大多IT人士，只要他们的实际工作能够获得应有的补偿，他们都很热爱自己的工作。”</p>

<p>总结
我曾在“正规”IT这个行当中几进几出。已经从挫折这所学校里面了解到了许多坚守下来的理由。说实话，或多或少地，上述每一条我都有做不到的地方。当你真正了解了干IT的基本理由之后，你就会知道，是IT而不是别的职业能够满足技术头脑的更多需求。况且IT工作十分好工作。根据《华尔街日报》的说法， <a href="http://online.wsj.com/article/SB10001424052748704723104576062173458318658.html">2011年前5佳工作里面有2个</a>是IT的：即软件工程师和系统分析师。</p>

<p>当然，我太了解哪些日常琐碎的折磨人之处了，身兼重担日复一日的压力，漫长、疲惫的时光以及众多永不见天日的坎坷挫折。一旦你的注意力停留在核销掉又一条待办事宜列表，再回复一封电子邮件这些小事情的时候，不难理解你会只见树木不见森林。我想，意识不到自己当时所处的积极面乃是人之本性。正如琼尼·蜜雪儿（Joni Mitchell，加拿大歌手）<a href="http://www.youtube.com/watch?v=ZgMEPk6fvpg">曾说过那样</a>， “它似乎永远不会走，直到它真的走了，你得到了什么自己才知道。”真的，考虑到IT这么多的好处，没必要像我曾经做过的那样离开IT。</p>

<p>本文转自：<a href="http://www.yixieshi.com/zhichang/8072.html">http://www.yixieshi.com/zhichang/8072.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IT生活：10个不干IT的理由]]></title>
    <link href="http://tinyxd.me/blog/2012/07/09/reasons-for-quitting-it/"/>
    <updated>2012-07-09T00:16:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/09/reasons-for-quitting-it</id>
    <content type="html"><![CDATA[<p>作者：Jack Wallen     来源：http://www.techrepublic.com   <br/>
摘要： 搞IT有很多好处——但是审时度势一下，你也许会考虑别的职业选择。Jack Wallen 阐述了哪些影响因素会成为压垮某些IT人士的最后一根稻草。</p>

<p>有谁起码有那么一两次快想不干了的？请举手。来吧，不要不好意思。IT的压力，没有最大，只有更大，路人皆知。更为不幸的是，大学并没有教你度过并坚守这些岁月的应对机制。我们来看看有哪些原因会导致你决意离开所挚爱的IT行业。</p>

<p>注：本文有<a href="http://www.techrepublic.com/downloads/10-reasons-for-quitting-it/2568617">PDF版</a>可供下载。</p>

<p>1: 压力</p>

<p>千万不要相信IT很好做的鬼话。能拿到一个毫无压力的IT岗位这种情况少之又少。记住，IT就是灾难管理。一旦客户或用户打电话给你，几乎就是需要马上处置的紧急情况。且一旦你在做这些工作的时候，你最好任何事情都没有出错，因为出娄子的代价是一份合同或工作。更糟糕的是压力鲜见减轻的时候。日复一日，每一分每一秒，你干得越来越累，超出自己的意料。</p>

<!--more-->


<p>2: 时间</p>

<p>如果你想找一份周一至周五、朝九晚五的工作，到别处去找——IT似乎是一份7乘24小时全天候不间断的工作。跟其他一般职业相比，做IT的不单要在办公室呆久一点，工作以外你还得拔高自己，以保证不被你后面那些家伙踩下去。还有一些人，他们虽不是你的客户或用户，却希望能免费利用你的知识让自己的电脑运转保持顺畅。</p>

<p>3: 薪水</p>

<p>如果你是独立承揽人，面临的其中一个最大的压力就是支付酬金。为了拿到报酬，我认得的顾问不得不施加威胁或聘请律师，这种情况数不胜数。而如果你是自由职业者，要是人家不给你钱你就没饭吃。这种压力很沉重。你没有那种优势，每周或半周支票会定时给你送来。锤炼自己的人际交往技巧是尽可能保持好关系的关键。良好的关系（即便是跟一些不那么好的人）有助于确保你最终拿到酬劳。（译注：看来美国人也有拖欠IT民工工资现象）</p>

<p>4: 人事</p>

<p>提出这一点实非我所愿。很久以前，我是那种充满朝气、乐观向上、人见人爱、花见花开、车见爆胎的好青年。自从做了咨询顾问以后，却发现自己成了被利用的对象，干得多、挣得少、怀才不遇、未受赏识，诸如此类。必须不断忍受着归隐山林、甩手不干这种想法的煎熬。这并不是说人之初，性本恶。而是一旦你有了IT的光环，人们似乎就会对你另眼相看。同一个躯体下，你既被视为救世主，又被当成原罪人，不堪重负。</p>

<p>5: 上级</p>

<p>面对现实。没有多少个上级能理解你的工作。他们总认为你仅靠微薄成本、无需帮忙就能把一切搞定，他们还认为你对待客户应当像春天那样温暖，就好像他们个个人品都比你好。雪上加霜的是，上级希望你能够神奇地让那些PC顶用十几年。对责任和技术的理解误区导致了一件事：让你的工作成为不可能完成的任务。一旦高层事无巨细地插足你的部门管理，每一个不好的因素都会更加恶化。你了解自己的工作，你也知道自己了解自己的工作，但他们却不知道自己并不了解你的工作。如此一环扣一环，形成压力传递的恶性循环。</p>

<p>6: 技术</p>

<p>你有没有经历过那样的日子，一时间似乎所有技术都跟你作对，看起来就好像是殊方异类？这时候你是不是只想着收拾自己的一切用品、逃之夭夭了事？ 这曾经是我不得不去处理的麻烦之一，既然我是在一家主要为Windows客户服务的咨询公司工作。有时候你能赢得战争，有时候你会输掉。但是胜利的日子总会被失败的日子所淹没。</p>

<p>7: 竞争</p>

<p>有一件事你可以肯定 — 总会有人比你更出色。但在IT这个行当里面，它不是1:1这样的比例。相反，似乎每一个你这样的人后面总是总是有一百个更聪慧、更敏捷、更优秀的人出现。这种对比马上就会转化为收入差距。记住，IT的大势总是日新月异，如果你跟不上形势，你的饭碗是保不住的，也没人会雇你。我在这个行当待得越长，就越能意识到这是年轻人的游戏。要足够敏捷、工作能打持久战&#8230;&#8230;总而言之你得面面俱到。我并不是说我们这些老家伙就经不起来回折腾。我们也能。但我们每工作一天，这个领域的竞争就累积多一点，这种竞争是残酷的。</p>

<p>8: 云端</p>

<p>每次听见电视上的演员说“腾云驾雾”的时候，我就恨不得扯掉自己的头发然后一脚踹烂电视机。云已经成为IT的一个不断变化的概念之一，“不知所云”，很有可能今后也一直如此。到底什么是“云”？我该不该用它？“云”安不安全？“云”多少钱一斤？我不断为这些问题抓狂。通常客户问到我这些问题的时候，我就反问他们用没用过谷歌文档（Google Docs），如果他们回答用过，我就告诉他们说他们已经用上“云”了。但这永远也不会令人满意的。客户和最终用户希望“云”能带来某种魔幻般的体验，能令其工作更简单、更出色、更快速。除非他们了解真相。</p>

<p>9: 无序</p>

<p>毫无疑问，如果某些规范能在整个IT范围得到应用的话，我们的生活会更美好。为了实现一组规范，许多开源项目已经竭尽所能，却只迎来被专利软件推翻的下场。那些专利软件供应商就是不想公开自己的代码，不跟规范兼容，以便让自己的腰包越鼓越好。我理解这一点，真的。但是只要他们拒绝遵守规范，就会让最终用户和IT专业人士每天都头疼无比。如果不能阻止专利软件供应商大发横财，遵守规范也就无从谈起。</p>

<p>10: 尊重</p>

<p>IT专业人士在公众中的口碑不好。为什么？其中有诸多原因。有的是一朝被蛇咬十年怕井绳。有的遇到的顾问似乎总是想向他们推销更大更好的东西。只要这些事情延续，公众就会变得疲倦，IT专业人士就难以赢得尊重。哦，当然，当他们看见你进门的时候，你是他们最好的朋友&#8230;&#8230;那一刻是。 但是一旦你解决了那个“大难临头”的问题之后，要么赶紧拍拍屁股走人，要么就得不断强调你的所为已经超出了他们雇你的范围（或者超出了时间范围）。（译注：意思是说拿IT人当牛当马）</p>

<p>想打退堂鼓了吗？</p>

<p>这些IT工作的负面影响是不是已经超出了其积极面？如果不干IT的话你想从事什么职业？希望你能在评论中分享自己的观点。</p>

<p><strong><em>如果你还是感同身受的IT人士，请帮顶支持一下</em></strong></p>

<p><strong><em>如果你是脱离苦海的非IT人士，请帮顶同情一下</em></strong> <br/>
　看完了<a href="http://tinyxd.me/blog/07/09/reasons-for-quitting-it/">《IT生活：10个不干IT的理由》</a>，下面再看看<a href="http://tinyxd.me/blog/2012/07/09/reasons-to-stay-in-it/">《IT生活：10个继续干IT的理由》</a>  <br/>
本文转自：<a href="http://article.yeeyan.org/view/boxi/176955">http://article.yeeyan.org/view/boxi/176955</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git分支管理策略]]></title>
    <link href="http://tinyxd.me/blog/2012/07/08/git-branch-management-strategy/"/>
    <updated>2012-07-08T23:46:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/08/git-branch-management-strategy</id>
    <content type="html"><![CDATA[<p>如果你严肃对待编程，就必定会使用&#8221;<a href="http://www.ruanyifeng.com/blog/2008/12/a_visual_guide_to_version_control.html">版本管理系统</a>&#8220;（Version Control System）。</p>

<p>眼下最流行的&#8221;版本管理系统&#8221;，非<a href="https://github.com/">Git</a>莫属。</p>

<iframe src="https://skydrive.live.com/embed?cid=1F260DE1061FCF3E&resid=1F260DE1061FCF3E%21131&authkey=AAPFgWVBfiUqHeo" width="320" height="134" frameborder="0" scrolling="no"></iframe>


<p> <br/>
相比同类软件，Git有很多优点。其中很显著的一点，就是版本的分支（branch）和合并（merge）十分方便。有些传统的版本管理软件，分支操作实际上会生成一份现有代码的物理拷贝，而Git只生成一个指向当前版本（又称&#8221;快照&#8221;）的指针，因此非常快捷易用。</p>

<!--more-->


<p>但是，太方便了也会产生副作用。如果你不加注意，很可能会留下一个枝节蔓生、四处开放的版本库，到处都是分支，完全看不出主干发展的脉络。</p>

<iframe src="https://skydrive.live.com/embed?cid=1F260DE1061FCF3E&resid=1F260DE1061FCF3E%21132&authkey=AOWpB7QlaRtAdFA" width="320" height="169" frameborder="0" scrolling="no"></iframe>


<p> <br/>
<a href="http://nvie.com/">Vincent Driessen</a>提出了一个分支管理的<a href="http://nvie.com/posts/a-successful-git-branching-model/">策略</a>，我觉得非常值得借鉴。它可以使得版本库的演进保持简洁，主干清晰，各个分支各司其职、井井有条。理论上，这些策略对所有的版本管理系统都适用，Git只是用来举例而已。如果你不熟悉Git，跳过举例部分就可以了。</p>

<p>一、主分支Master</p>

<p>首先，代码库应该有一个、且仅有一个主分支。所有提供给用户使用的正式版本，都在这个主分支上发布。</p>

<iframe src="https://skydrive.live.com/embed?cid=1F260DE1061FCF3E&resid=1F260DE1061FCF3E%21130&authkey=AGTrDkY9-vGp3os" width="160" height="320" frameborder="0" scrolling="no"></iframe>


<p> <br/>
Git主分支的名字，默认叫做Master。它是自动建立的，版本库初始化以后，默认就是在主分支在进行开发。</p>

<p>二、开发分支Develop</p>

<p>主分支只用来分布重大版本，日常开发应该在另一条分支上完成。我们把开发用的分支，叫做Develop。</p>

<iframe src="https://skydrive.live.com/embed?cid=1F260DE1061FCF3E&resid=1F260DE1061FCF3E%21137&authkey=AKPfVNUBKokrRFU" width="289" height="320" frameborder="0" scrolling="no"></iframe>


<p> <br/>
这个分支可以用来生成代码的最新隔夜版本（nightly）。如果想正式对外发布，就在Master分支上，对Develop分支进行&#8221;合并&#8221;（merge）。</p>

<p>Git创建Develop分支的命令：</p>

<pre><code>　　git checkout -b develop master
</code></pre>

<p>将Develop分支发布到Master分支的命令：</p>

<pre><code>　　# 切换到Master分支
　　git checkout master

　　# 对Develop分支进行合并
　　git merge --no-ff develop
</code></pre>

<p>这里稍微解释一下，上一条命令的&#8211;no-ff参数是什么意思。默认情况下，Git执行&#8221;快进式合并&#8221;（fast-farward merge），会直接将Master分支指向Develop分支。</p>

<iframe src="https://skydrive.live.com/embed?cid=1F260DE1061FCF3E&resid=1F260DE1061FCF3E%21134&authkey=AN9912ePTGm_jHA" width="264" height="320" frameborder="0" scrolling="no"></iframe>


<p> <br/>
使用&#8211;no-ff参数后，会执行正常合并，在Master分支上生成一个新节点。为了保证版本演进的清晰，我们希望采用这种做法。关于合并的更多解释，请参考Benjamin Sandofsky的<a href="http://sandofsky.com/blog/git-workflow.html">《Understanding the Git Workflow》</a>。</p>

<iframe src="https://skydrive.live.com/embed?cid=1F260DE1061FCF3E&resid=1F260DE1061FCF3E%21133&authkey=AGXTd8Ijt7ax2Nw" width="110" height="319" frameborder="0" scrolling="no"></iframe>


<p> <br/>
三、临时性分支</p>

<p>前面讲到版本库的两条主要分支：Master和Develop。前者用于正式发布，后者用于日常开发。其实，常设分支只需要这两条就够了，不需要其他了。</p>

<p>但是，除了常设分支以外，还有一些临时性分支，用于应对一些特定目的的版本开发。临时性分支主要有三种：</p>

<pre><code>　　* 功能（feature）分支

　　* 预发布（release）分支

　　* 修补bug（fixbug）分支
</code></pre>

<p>这三种分支都属于临时性需要，使用完以后，应该删除，使得代码库的常设分支始终只有Master和Develop。</p>

<p>四、 功能分支</p>

<p>接下来，一个个来看这三种&#8221;临时性分支&#8221;。</p>

<p>第一种是功能分支，它是为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop。</p>

<iframe src="https://skydrive.live.com/embed?cid=1F260DE1061FCF3E&resid=1F260DE1061FCF3E%21135&authkey=APEKOZ5K-E-yHZE" width="176" height="320" frameborder="0" scrolling="no"></iframe>


<p> <br/>
功能分支的名字，可以采用feature-*的形式命名。</p>

<iframe src="https://skydrive.live.com/embed?cid=1F260DE1061FCF3E&resid=1F260DE1061FCF3E%21136&authkey=AHLTEmtvBwaY3dM" width="320" height="273" frameborder="0" scrolling="no"></iframe>


<p> <br/>
创建一个功能分支：</p>

<pre><code>　　git checkout -b feature-x develop
</code></pre>

<p>开发完成后，将功能分支合并到develop分支：</p>

<pre><code>　　git checkout develop

　　git merge --no-ff feature-x
</code></pre>

<p>删除feature分支：</p>

<pre><code>　　git branch -d feature-x
</code></pre>

<p>五、预发布分支</p>

<p>第二种是预发布分支，它是指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。</p>

<p>预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支。它的命名，可以采用release-*的形式。</p>

<p>创建一个预发布分支：</p>

<pre><code>　　git checkout -b release-1.2 develop
</code></pre>

<p>确认没有问题后，合并到master分支：</p>

<pre><code>　　git checkout master

　　git merge --no-ff release-1.2

　　# 对合并生成的新节点，做一个标签
　　git tag -a 1.2
</code></pre>

<p>再合并到develop分支：</p>

<pre><code>　　git checkout develop

　　git merge --no-ff release-1.2
</code></pre>

<p>最后，删除预发布分支：</p>

<pre><code>　　git branch -d release-1.2
</code></pre>

<p>六、修补bug分支</p>

<p>最后一种是修补bug分支。软件正式发布以后，难免会出现bug。这时就需要创建一个分支，进行bug修补。</p>

<p>修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支。它的命名，可以采用fixbug-*的形式。</p>

<p>创建一个修补bug分支：</p>

<pre><code>　　git checkout -b fixbug-0.1 master
</code></pre>

<p>修补结束后，合并到master分支：</p>

<pre><code>　　git checkout master

　　git merge --no-ff fixbug-0.1

　　git tag -a 0.1.1
</code></pre>

<p>再合并到develop分支：</p>

<pre><code>　　git checkout develop

　　git merge --no-ff fixbug-0.1
</code></pre>

<p>最后，删除&#8221;修补bug分支&#8221;：</p>

<pre><code>　　git branch -d fixbug-0.1
</code></pre>

<br />


<p>原文网址：<a href="http://www.ruanyifeng.com/blog/2012/07/git.html">http://www.ruanyifeng.com/blog/2012/07/git.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[写在开博一个月]]></title>
    <link href="http://tinyxd.me/blog/2012/07/08/blog-one-month/"/>
    <updated>2012-07-08T23:31:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/08/blog-one-month</id>
    <content type="html"><![CDATA[<p>其实说开博一个月，不太妥当。用octopress搭建博客是在5月底，域名是在6月9号申请的。Anyway，在这一个月中，深切体会到了“隔行如隔山”。从刚开始一点不懂，到现在知道了“SEO”、“sitemap”、&#8221;PR&#8221;、还有各种博客工具，学习了ruby、html，css等等。
到现在google PR值仍然为0（站长真是不容易啊），不过bing、yahoo、sogou等搜索引擎已经开始收录了，只是baidu还没有动静（伤感中），只好继续等待了。
先写到这吧，有啥体会了再继续。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[互联网创业降级论]]></title>
    <link href="http://tinyxd.me/blog/2012/07/08/degrading-for-success/"/>
    <updated>2012-07-08T00:46:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/08/degrading-for-success</id>
    <content type="html"><![CDATA[<p>本文来自：<a href="http://meditic.com/degrading-for-success/">meditic</a>  <br/>
几乎一年没有写博客了，说没时间那是借口，唯一的原因是，年纪越大越发觉自己肤浅。有些想法还没提笔，就发现很幼稚，就不敢发出来贻笑大方了。这次先给大家说个小故事：</p>

<p>从前有三个屌丝，聚在一起做网络，提供免费的网络服务，砸锅卖铁，通宵达旦，除了卖肾啥都做了。3年后终于做到了五百万用户，对于年轻人来说，能把五百万人玩弄于鼓掌之间，已经是很牛逼轰轰的事了，不过用户越多，成本越高，每年服务器、带宽租金、房租水电、广告运营等成本，已经达到了十七八万，屌丝们不得不面对一个终极问题：如何盈利？</p>

<p>屌丝们定了三盘沙县水饺，围着一箱子的冰啤酒开始计算：按照最近一月的登陆情况来看，四百万个账号已经不活跃了，真正有商业价值的只有一百万人，如 果开通xx功能，收点高级会员费，让其中1%的人升级为高级会员，每年付30块钱年费，那么每年收入就是100万x1%x30元=30万元！不错嘛， 扣除十七八万的运营成本，还剩毛利润12万，每个屌丝年底能分到4万大洋，如果按照打工者的算法，这三个人每人月薪3333元，木有奖金，木有津贴、木有任何福利，上班还得带自家的电脑。</p>

<p>尽管如此，屌丝们还是激动得热泪盈眶：老子有钱啦！老子有钱啦！！！那一夜，人们看到三个发疯的屌丝在屋顶翩翩起舞。</p>

<p>韩寒说，中国人民是最有忍耐力的族群，一点好处就感激涕零。他一定不知道，IT创业界里的屌丝，才是这群傻逼中的战斗机。他们可以平静地忍受每年都持续亏钱，而且还能信心十足的对所有人说公司的状态非常好，如果有一天居然收支平衡了，他们会激动的趁夜难眠，比北朝鲜倒掉还开心。</p>

<!--more-->


<p>本文开头的三个屌丝，其实是非常幸运的，至少能做到月薪3333元。大部分的屌丝在第一年做到几万用户的时候就会挂掉，原因众多，最主要要的是意志太弱，受不了最初的寂寞；意志稍微坚强点的会在第二年第三年慢慢挂掉，原因主要是资金断裂、团队分裂；能成功熬到第四年还没饿死、还没被口水淹死、还没被肠胃病颈椎病腰肌劳损折磨死的，甚至员工不减反增的，基本上属于神仙级别了。</p>

<p>我为什么要说三个屌丝的故事呢。首先是因为这是身边每天都在发生的故事，其次是因为感到可惜，IT界在我眼里一直是一个无比高级的职业，聚集着全球最聪明、最富有的人类精英。以IT创业界的青年们的智商，他们可以做成任何一件事情，包括改造银行到制造汽车到发射航天飞机 。结果这帮人却整天在蓬头垢面得为3k的月薪而挣扎，太悲催了。</p>

<p>为什么用悲催这个词？ 如果一个人生下来就在山沟沟里，一辈子都没机会去见什么好东西，这不叫悲催，这只叫苦难；而如果一个人生出来有一个奇怪的特异功能：皮肤出来的汗水会凝结成昂贵的水晶，本来只靠出汗就能赚钱，结果这傻逼居然觉得出汗这个行为太低级，做手术把自己的汗腺全给切了，而且丝毫没有意识到他做了什么傻事，这才叫真的悲催。</p>

<p>我们IT界中的很多人，生下来就是有这个出汗成水晶的特异功能的，正是因为这种与众不同，这群人能混入牛逼的大学，整天打网游还能写出像样的毕业论文， 拿到学位，进外企，考CPA，做咨询、做证券分析，研究高分子材料，做电子商务，做云计算。。。一级一级的上升，直到有一天，发现身边的人里，已经没有一个不是CPA，不是咨询师，不是高级研究员了，身边的人全是业界精英，个个都超级强悍。在这个所谓的高级圈子里，自己并没有任何过人之处，只不过是just another analyst而已。在高级圈子里拼的头破血流，最后也只能混到给台湾人整理数据而已。莫然回首，发现当年的血气方刚、年少时的无限梦想，进化成了一身肥胖的赘肉。这个时候，有个旁观者说：“升级到头了，该降级了”</p>

<p>当一个社会疯狂鼓吹快节奏的时候，一定需要有人来宣扬慢生活；当全社会跟打了鸡血似的吹捧升级的时候，一定需要有人来说说降级论。</p>

<p>IT青年们喜欢打游戏，喜欢升级。他们的人生也和游戏一样，沉醉于不停的升级中，不仅喜欢升级自己手上的技术，把MySql改成MongoDB，把Apache升级为Nginx，在Mac上装Ubuntu，Ubuntu里再装个虚拟机去跑Mac OS。。。IT青年们也喜欢升级自己的人生，从程序员升级到项目经理，再升级到技术总监或产品总监，再升级到合伙人。。。</p>

<p>在不断追求升级的过程中，所面临的一个很大事实是：当一个人从A刚升级到A+级的时候，其实这个人的能力层级依然只是A的层级，还未胜任A+的层级，他必须要到A+的后期，才可以胜任A+。就好像一个高中生，高考完之后，虽然理论上已经属于大学生了，但是他的实际能力依然只是高三毕业的水平，除非他全部pass了大一的期末考试。同样的道理，这个世界上有很多人的身份和称谓，都是在描述“未来的自己”，而不是现在的自己。当你从销售员升级为销售经理的时候，你自我感觉很好：“我现在是销售经理了”，但是这个时候 ，你并未通过公司对你作为销售经理这一年的工作成果的考核，你只是一个“未来可能是合格的销售经理”的前身。如果年终考核你失败了，那么这一年最准确的描述是：一个销售员，占了整整一年销售经理的位子，最后失败了。而且这一年一定会过的很累，因为通过考核的其他销售经理，才是真正胜任这个层级的人，跟一帮真正属于这个圈子的人厮杀，就好像拳击馆里当陪练的小角色，去和泰森比了一年的武，怎么可能不累呢？</p>

<p>当我07年进入互联网行业的时候，就是那个拳击馆里陪练的小角色，我被迫去跟全国各地的泰森比拼，结果累的半死。后来我开始反思最初的目标，为什么要在自己身上挂一个“拳击高手”的招牌，被那么多泰森追着打？ 我把这块招牌卸了，找个完全没练武的人去比拼，不是更容易赢么？于是果断照做，去找了一个没人懂拳击的小乡村，做了纯英文的<a href="http://www.tucia.com/">Tucia.com</a>(需翻墙)，只做国外的业务。在那个地方，作为一个知名武馆的拳击小陪练，我成了村子里拳击技术最高超的人，受人仰慕，还开武馆教人拳击，活的非常滋润，而且在教人拳击的过程中，自己的拳术也比以前提高了很多，发展出一套属于自己的拳法，我虽然进不了泰森们的大圈子，但他们也进不了我的小圈子。</p>

<p>关于圈子，有一个很赤裸裸的现实：不会是你进入圈子，只能是圈子进入你。很多人会四处找关系，“帮我介绍给xxx吧，我想进入你们的圈子”，这样的人是永远进不去这个圈子的，因为圈子的天性是，永远追求更高一个层级的人。而我们的大部分人，其实都在以低一级的属性，占着更高一级的位子，徘徊在更高一级的圈子边缘，与更高一级的人竞争，幻想着自己可以升级到那个圈子里去。也许永远进不去，悲催的努力一辈子；也许运气好，某一天真的进入这个圈子了，但那个时候又会有下一个目标，希望进入更高级的圈子，这是一场没有终点的战斗。永远的追求升级，永远的累。</p>

<p>有没有想过降级呢？</p>

<p>如果一个来自微软的高级工程师，辞职去一个养猪场做开放平台经理，那么他的到来不仅会让养猪圈感到无比荣幸，更是意味着，利用他在IT界训练出来的高效工作方式和逻辑思维能力，他可以掀起一场养猪行业的革命，使得20年后才会出现的人性、高效、开放、协作、健康的养殖方式提前到达。在这场革命中，他会活的非常有价值。这种价值，在原先的圈子里，是完全体验不到的，因为他此前的所有工作，只是在满身疮痍的windows系统上不停的打补丁，无论打多少都逃不开产品衰落、被人鄙视的命运。</p>

<p>很多人的命运，都像是上面那个微软工程师。只需要降级，就能创造更大的价值，也能获得更大的满足。那为什么不呢？为什么要死死抱着那个所谓的“高级职业”不放呢？</p>

<p>去年我曾犯贱去趟了移动互联网的浑水，做了个手机app，刚开始的时候感觉很高级，但很快，铺天盖地的竞争对手就出现了，我又发现自己陷入了07年一样的场景：作为一个小小陪练，我他妈的又被一帮泰森们给围住了。当泰森中的战斗机&#8212;微信，变得无比牛逼之后，我就知道，战胜这群泰森是绝对不可能的事情了。于是我再次投靠了“降级论”，把自己从牛逼哄哄的移动互联网行业，降级到了一个被人不齿的低级项目：<a href="http://www.tuciababy.com/">Tucia Baby</a>。</p>

<p>这个项目虽然是传统行业，但是我们基本上是按照互联网产品的思路去做的，除了拍摄需要来店里以外，其他一切，包括营销、预约、客服、后期、选片、取片、客户关系等，所有环节都放在网络上，尤其是微博（<a href="http://weibo.com/tuciababy">@tuciababy官网</a>）。当然，最重要的是，作为一个脑残的果粉，我按照iPhone的做工和品质去要求每一张作品，必须达到我们能力可以做到的最好水准，不计成本的最好水准，才允许送给客户。正式接客不到两个月时间，虽然还远未达到成功，但目前已做到每天都有客户订单，财务上已实现盈利，未来相信一定会比大部分app开发者更光明。（ps:我们没有请工商、税务、城管去吃饭喝酒泡桑拿，也没有塞钱给任何政府机关。当你的产品真的用心做到很好的时候，其实你不需要讨好任何人的。）</p>

<p>这个项目让我沉思了很久：07年我曾把一个纯纯的web2.0网站做到了alexa中国区前1000名（如有质疑，请查询2010年附近的tucia.com排名），结果一路亏损，到最后只剩下一个员工；11年我把那个纯纯的app做到苹果官方推荐区免费榜的第一位（<a href="http://ww3.sinaimg.cn/bmiddle/823ddc58gw1dkiqty41ukj.jpg">点此看截图</a>），那段时间每天四五千iPhone安装量，结果一路烧钱，到最后濒临关闭；而如今，我只需把自己从纯纯的互联网降级下来，做一些看起来有些“低级”的项目，居然就能立即实现收支平衡。</p>

<p>除此以外，我还发现一个现象，中国消费者在与奸商们的长期斗争中，已经培养出了一种非常苦B的品质：只要不被坑，他就谢天谢地。如果商家严格做到了承诺的每一件事情，客户就会感动的泪如泉涌。如果商家不仅做到了所有承诺的事情，还很贴心的提供了一些额外的服务（比如我们给每位客户赠送非常好吃的樱桃和昂贵的进口巧克力作为甜点），那么客户就会激动的哭天喊地、奔走相告，推荐给他认识的每一个人。</p>

<p>其实这片肮脏的国土，就是上天赐予IT青年们的最好机会。</p>

<p>在一个不会练武的村子里，只要你会打两拳，你就是拳术最厉害的人；在一个没有服务意识、忽视产品质量的土地上，只要你用心做服务，用最高的标准去要求自己，你就会成为这块土地上最出色的商家；在一个没有现代管理意识，不懂网络、不懂微博、不懂用户体验、不懂口碑传播的粗犷社会里，你只需要把之前花在IT产品上的心思的10%拿过来用，就可以秒杀一切天朝对手。</p>

<p>所以，</p>

<p>IT青年们，当你在为网站的转化率苦苦思索的时候，当你在为app的活跃度辗转反侧的时候，当你在为融资计划苦苦哀求各界大佬引荐的时候，也许犯了一个错误，也许你们的脑子最值得闪光的地方，不是去悲催的IT界当炮灰，而应该是去按摩界、餐饮界、烧烤界、早餐界、理发界、家政界、按摩界、送花界、纺织界、成人用品界、现代化养殖界、有机蔬果界、个人护理界、汽车修理界。。。。与IT界相比，这些行业的确无比低级，他们的老板连qq都会发音成“抠抠”，他们的员工一辈子都没用过Email；跟他们解释什么是SEO，什么是用户体验，什么是数据挖掘，他们会在听你说完之前就开枪自杀掉。正是因为如此，这些行业才是如此的不堪一击。正是因为如此，当智商高达147的IT青年还在为3k薪水拼命、而智商不到50的烧烤店老板正坐在porsche里玩着前面那位青年开发的app的时候，我就忍不住仰望星空。</p>

<p>这些原始而纯粹的行业，正在等待IT精英们的降级，如同蒲公英一般的伞兵，在黑夜里从天而降，长驱直入，用最智慧的产品、最优质的服务拯救这些早就该死的行业，屌丝的生命将会绽放出银色的羽翼，无比丰满，无比性感。</p>

<p>最后注意，请珍惜生命，远离我的微博：<a href="http://weibo.com/meditic">@meditic</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[正则表达式]]></title>
    <link href="http://tinyxd.me/blog/2012/07/07/regular-expressions-in-ruby/"/>
    <updated>2012-07-07T23:40:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/07/regular-expressions-in-ruby</id>
    <content type="html"><![CDATA[<p>Ruby语言是一种“万事万物皆对象”的程序语言，正则表达式也是一个对象。正则表达式所属的类，就是Regexp类。<br/>
要建立正则表达式两种方法： <br/>
1.用“//”括住。  <br/>
2.当正则表达式内部用到“/”字符的时候，改用%r会比较方便。 示例%r(样式)
下面介绍一些规则。 <br/>
1.^ 行首匹配 $行尾匹配 \A 字符串头 \Z字符串尾 <br/>
2.指定想要匹配成功的文字范围用[]</p>

<pre><code>比如[A-Z]所有大写英文字母[A-Za-z]所有英文字母[0-9]所有阿拉伯数字[^ABC]A、B、C以外的字   
</code></pre>

<p>3.匹配任意字符用.</p>

<pre><code>想要指定字数/^…$/ 刚好三个字的一行   
配合“*”等转义字符使用   
</code></pre>

<!--more-->


<p>4.使用反斜杠的样式（“\”+“一个英文字母”）</p>

<pre><code>\s 空白 会与空白字符（0x20）、定位字符、换行字符、换页字符匹配成功   
\d与0-9之间的数字匹配成功
\w与英文与数字匹配成功
\A与字符串前端匹配成功
\Z与字符串末端匹配成功
</code></pre>

<p>5.将转义字符当作一般字符</p>

<pre><code>“\”后接上“^”、“$”、“[”这些英文、数字以外的转义字符时，这些字符就不在具备转义字符的效用了，而可以去匹配这些字符本身。
</code></pre>

<p>6.匹配连续出现的相同字符或单字</p>

<pre><code>*出现0次以上
+出现1次以上
?出现0次或1次
</code></pre>

<p>7.最短匹配</p>

<pre><code>*?出现0次以上，但取最短的匹配结果
+?出现1次以上，但取最短的匹配结果
</code></pre>

<p>8.“()”与反复</p>

<pre><code>使用“()”可以多个字构成的字符串反复匹配
</code></pre>

<p>9.多选</p>

<pre><code>/^(ABC|DEF)$/
正则项选项/```/后面类似/.../ei
i忽略英文大小写差异
s e u n 指定字符编码方式 s是Shift_JIS,e是EUC-JP，u是UTF-8 n是匹配是不考虑文字编码。
x忽略正则表达式内部的空白，并忽略“#”后面的内容。加上这个选项就可以在正则表达式内部写注释了。
m 让“.”能与换行符号匹配成功
p /DEF.GHI/m =~ "ABC\nDEF\nGHI" #=&gt; 4 匹配成功
</code></pre>

<br />


<p><strong>正则表达式的方法</strong>  <br/>
sub、gsub、scan  <br/>
sub方法只会取代第一个匹配成功处的字符串，而gsub则会取代所有匹配成功的字符串</p>

<pre><code>str = “abc def g hi”    
p str.sub(/\s+/,' ') #=&gt; "abc def g hi"   
p str.gsub(/\s+/,' ') #=&gt; "abc def g hi"   
</code></pre>

<p>scan跟gsub一样会匹配字符串里所有符合样式的部分，但只是获取不会取代。</p>

<br />


<p>取出服务器的地址的正则表达式：</p>

<pre><code>/http:\/\/([^\/]*)\// %r|http://([^/]*)/|   
</code></pre>

<figure class='code'><figcaption><span>url_match.rb</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">str</span> <span class="o">=</span> <span class="s2">&quot;http://www.ruby-lang.org/ja/&quot;</span>
</span><span class='line'><span class="sr">%r|http://([^/]*)/|</span> <span class="o">=~</span> <span class="n">str</span>
</span><span class='line'><span class="nb">print</span> <span class="s2">&quot;server address: &quot;</span><span class="p">,</span> <span class="vg">$1</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>
运行：</p>

<pre><code>&gt;ruby url_match.rb   
server address: www.ruby-lang.org
</code></pre>

<p>正则表达式的圣书：<code>Mastering Regular Expressions, Third Edition (Jeffrey E.F.Friedl 著/O'REILLY 出版)</code></p>

<br />


<p>本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<code>http://tinyxd.me/blog/2012/07/07/regular-expressions-in-ruby/</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ruby初学]]></title>
    <link href="http://tinyxd.me/blog/2012/07/06/ruby-learning/"/>
    <updated>2012-07-06T23:43:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/06/ruby-learning</id>
    <content type="html"><![CDATA[<p>这几天在学习Ruby，面对一个陌生的脚本语言，虽然陌生但是既然是脚本语言，自然也有与shell类似的地方，所以学习起来困难不是很大。 <br/>
在感受到脚本语言的方便后，试了个例子，如下计算一个文件中单词的个数，以空格来区分。</p>

<figure class='code'><figcaption><span>统计单词个数ruby脚本word.rb</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1">#计算单词个数</span>
</span><span class='line'><span class="n">count</span> <span class="o">=</span> <span class="no">Hash</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">##统计单字</span>
</span><span class='line'><span class="k">while</span> <span class="n">line</span> <span class="o">=</span> <span class="nb">gets</span>
</span><span class='line'><span class="n">words</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span>
</span><span class='line'><span class="n">words</span><span class="o">.</span><span class="n">each</span><span class="p">{</span><span class="o">|</span><span class="n">word</span><span class="o">|</span>
</span><span class='line'><span class="n">count</span><span class="o">[</span><span class="n">word</span><span class="o">]</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1">##输出结果</span>
</span><span class='line'><span class="n">count</span><span class="o">.</span><span class="n">sort</span><span class="p">{</span><span class="o">|</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="o">|</span>
</span><span class='line'><span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&lt;=&gt;</span> <span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
</span><span class='line'><span class="p">}</span><span class="o">.</span><span class="n">each</span><span class="p">{</span><span class="o">|</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="o">|</span>
</span><span class='line'><span class="nb">print</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">key</span><span class="si">}</span><span class="s2">: </span><span class="si">#{</span><span class="n">value</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>用法：<code>ruby word.rb your_file</code></p>

<!--more-->


<p>还有个问题以后可能会经常遇到，用p方法来输出包括日文或者中文的字符串的时候，会发生一般所谓的“乱码”的输出结果。所以在执行ruby程序时需要加上-Ks、-Ke之类的环境参数，这些参数用来指定文字编码。针对中文字符串，可以制定-Ku参数（UTF-8）来取得正常的显示效果。</p>

<br />


<p>本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<code>http://tinyxd.me/blog/2012/07/06/ruby-learning/</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux sleep 的用法]]></title>
    <link href="http://tinyxd.me/blog/2012/07/06/linux-sleep-usage/"/>
    <updated>2012-07-06T12:40:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/06/linux-sleep-usage</id>
    <content type="html"><![CDATA[<p><strong>应用程序</strong>：</p>

<pre><code>#include &lt;syswait.h&gt;
usleep(n) //n微秒
Sleep（n）//n毫秒
sleep（n）//n秒
</code></pre>

<!--more-->


<p><strong>驱动程序</strong>：</p>

<pre><code>#include &lt;linux/delay.h&gt;
mdelay(n) //milliseconds 其实现
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#ifdef notdef
</span><span class='line'>#define mdelay(n) (\
</span><span class='line'>{unsigned long msec=(n); while (msec--) udelay(1000);})
</span><span class='line'>#else
</span><span class='line'>#define mdelay(n) (\
</span><span class='line'>(__builtin_constant_p(n) && (n)&lt;=MAX_UDELAY_MS) ? udelay((n)*1000) : \
</span><span class='line'>({unsigned long msec=(n); while (msec--) udelay(1000);}))
</span><span class='line'>#endif</span></code></pre></td></tr></table></div></figure>


<p>调用asm/delay.h的udelay,udelay应该是纳秒级的延时</p>

<p>dos:</p>

<pre><code>sleep(1); //停留1秒 
delay(100); //停留100毫秒   
</code></pre>

<p>Windows:</p>

<pre><code>Sleep(100); //停留100毫秒 
</code></pre>

<p>Linux:</p>

<pre><code>sleep(1); //停留1秒 
usleep(1000); //停留1毫秒 
</code></pre>

<p>每一个平台不太一样,最好自己定义一套跨平台的宏进行控制   <br/>
附：Linux下（使用的gcc的库），sleep()函数是以秒为单位的，sleep(1);就是休眠1秒。而MFC下的sleep()函数是以微秒为单位的，sleep(1000);才是休眠1秒。而如果在Linux下也用微妙为单位休眠，可以使用线程休眠函数:void usleep(unsigned long usec);当然，使用的时候别忘记#include &lt;system.h>哦。另外，linux下还有个delay()函数，原型为extern void delay(unsigned int msec);它可以延时msec*4毫秒，也就是如果想延时一秒钟的话，可以这么用 delay(250)。 <br/>
转载请注明出处：<a href="http://tinyxd.me/blog/2012/07/06/linux-sleep-usage/">http://tinyxd.me/blog/2012/07/06/linux-sleep-usage/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[中国大陆linux源镜像地址]]></title>
    <link href="http://tinyxd.me/blog/2012/07/05/linux-mirrors-china/"/>
    <updated>2012-07-05T09:39:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/05/linux-mirrors-china</id>
    <content type="html"><![CDATA[<p>1.企业 <br/>
搜狐开源镜像站：</p>

<pre><code>http://mirrors.sohu.com/
</code></pre>

<p>网易开源镜像站：</p>

<pre><code>http://mirrors.163.com/
</code></pre>

<p>2.大学 <br/>
西安电子科技大学：</p>

<pre><code>http://ftp.xdlinux.info/  (IPv4+IPv6)
ftp://linux.xidian.edu.cn/
</code></pre>

<p>中国科学技术大学：</p>

<pre><code>http://mirrors.ustc.edu.cn/ (IPv4+IPv6)
http://mirrors4.ustc.edu.cn/
http://mirrors6.ustc.edu.cn/
</code></pre>

<!--more-->


<p>上海交通大学：</p>

<pre><code>http://ftp.sjtu.edu.cn/ (IPv4 only)
http://ftp6.sjtu.edu.cn (IPv6 only)
</code></pre>

<p>清华大学：</p>

<pre><code>http://mirrors.tuna.tsinghua.edu.cn/ (IPv4+IPv6)
http://mirrors.6.tuna.tsinghua.edu.cn/ (IPv6 only)
http://mirrors.4.tuna.tsinghua.edu.cn/ (IPv4 only)
</code></pre>

<p>天津大学：</p>

<pre><code>http://mirror.tju.edu.cn/
</code></pre>

<p>西南大学：</p>

<pre><code>http://linux.swu.edu.cn/swudownload/Distributions/
</code></pre>

<p>东北大学：</p>

<pre><code>http://mirror.neu.edu.cn/ (IPv4 only)
http://mirror.neu6.edu.cn/ (IPv6 only)
</code></pre>

<p>电子科技大学：</p>

<pre><code>http://ubuntu.uestc.edu.cn/
</code></pre>

<p>青岛大学：</p>

<pre><code>http://mirror.qdu.edu.cn/
</code></pre>

<p>兰州大学：</p>

<pre><code>http://mirror.lzu.edu.cn/
</code></pre>

<p>厦门大学：</p>

<pre><code>http://mirrors.xmu.edu.cn/
</code></pre>

<p>北京理工大学：</p>

<pre><code>http://mirror.bit.edu.cn (IPv4 only)
http://mirror.bit6.edu.cn (IPv6 only)
</code></pre>

<p>北京交通大学：</p>

<pre><code>http://mirror.bjtu.edu.cn (IPv4 only)
http://mirror6.bjtu.edu.cn (IPv6 only)
http://debian.bjtu.edu.cn (IPv4+IPv6)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[vc debug 变 release]]></title>
    <link href="http://tinyxd.me/blog/2012/07/03/vc-debug-release/"/>
    <updated>2012-07-03T12:23:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/03/vc-debug-release</id>
    <content type="html"><![CDATA[<p>今天遇到将debug改为release版本出现好多问题，最后一一解决，现将方法贴到下面 <br/>
生成release版的步骤： <br/>
1.首先修改<code>project-setting-general-using mfc in a static libraryproject-setting</code>右键点击菜单空白处——选择“组建”——选择“Win32 Release“——重新编译链接。 <br/>
2.然后<code>project-setting -c++ -precompiled Headers- not using</code> <br/>
最后出现这个错误</p>

<pre><code>nafxcwd.lib(afxmem.obj) : error LNK2005: "void __cdecl operator delete(void *)" (??3@YAXPAX@Z) already defined in LIBCMTD.lib(dbgdel.obj)   
</code></pre>

<p>关于静态库引发 nafxcw.lib LNK2005 错误的解决方法</p>

<!--more-->


<p>解决方法，进入vc6 选择菜单：</p>

<pre><code>project -&gt; settings -&gt; link -&gt; Category : input   -&gt; Object/library modeules ,
</code></pre>

<p>输入：nafxcw.lib 即可。 <br/>
原因：必须先编译这个库，才能避免函数名字重复引用。</p>

<br />


<p>Note：记住rebuiled</p>

<br />


<p>附：debug版本和release版本的区别： <br/>
Debug 通常称为调试版本，它包含调试信息，并且不作任何优化，便于程序员调试程序。Release 称为发布版本，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用。Debug 和 Release 的真正秘密，在于一组编译选项。下面列出了分别针对二者的选项</p>

<br />


<p>Debug 版本：</p>

<blockquote><p>/MDd /MLd 或 /MTd 使用 Debug runtime library(调试版本的运行时刻函数库)<br/>/Od 关闭优化开关<br/>/D &#8220;_DEBUG&#8221; 相当于 #define _DEBUG,打开编译调试代码开关(主要针对assert函数)<br/>/ZI 创建 Edit and continue(编辑继续)数据库，这样在调试过程中如果修改了源代码不需重新编译<br/>/GZ 可以帮助捕获内存错误<br/>/Gm 打开最小化重链接开关，减少链接时间</p></blockquote>


<br />


<p>Release 版本：</p>

<blockquote><p>/MD /ML 或 /MT 使用发布版本的运行时刻函数库<br/>/O1 或 /O2 优化开关，使程序最小或最快<br/>/D &#8220;NDEBUG&#8221; 关闭条件编译调试代码开关(即不编译assert函数)<br/>/GF 合并重复的字符串，并将字符串常量放到只读内存，防止 被修改</p></blockquote>


<p></p>

<br />


<p> 实际上，Debug 和 Release 并没有本质的界限，他们只是一组编译选项的集合，编译器只是按照预定的选项行动。事实上，我们甚至可以修改这些选项，从而得到优化过的调试版本或是带跟踪语句的发布版本。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress博客添加flickr侧边栏]]></title>
    <link href="http://tinyxd.me/blog/2012/07/02/add-flickr-aside-in-octopress/"/>
    <updated>2012-07-02T11:14:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/02/add-flickr-aside-in-octopress</id>
    <content type="html"><![CDATA[<p>octopress添加侧边栏： <br/>
1.新建 <code>source/_includes/custom/asides/flickr.html</code>，代码如下：</p>

<div><script src='https://gist.github.com/1421792.js?file=flickr.html'></script>
<noscript><pre><code>{% if site.flickr_user %}
&lt;section class=&quot;flickr&quot;&gt;
&lt;h1&gt;My Flickr&lt;/h1&gt;
&lt;!-- Start of Flickr Badge --&gt;
&lt;style type=&quot;text/css&quot;&gt;
/*
Images are wrapped in divs classed &quot;flickr_badge_image&quot; with ids &quot;flickr_badge_imageX&quot; where &quot;X&quot; is an integer specifying ordinal position. Below are some styles to get you started!
*/
#flickr_badge_wrapper {padding:10px 0 10px 0;}
.flickr_badge_image {margin: 0 9px 8px 0px;display: inline-block;}
&lt;/style&gt;
&lt;div id=&quot;flickr_badge_uber_wrapper&quot;&gt;&lt;div id=&quot;flickr_badge_wrapper&quot;&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.flickr.com/badge_code_v2.gne?count={{ site.flickr_count }}&amp;display=latest&amp;size=s&amp;layout=x&amp;source=user&amp;user={{ site.flickr_user }}&quot;&gt;&lt;/script&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;!-- End of Flickr Badge --&gt;
&lt;/section&gt;
{% endif %}</code></pre></noscript></div>




<!--more-->


<p>
2.在_config.yml添加</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># Flick Badges
</span><span class='line'># Find your user id here: http://idgettr.com/ It should be something like "81221217@N08".
</span><span class='line'>flickr_user: 81221217@N08
</span><span class='line'>flickr_count: 6</span></code></pre></td></tr></table></div></figure>


<p> <br/>
记住要把 flickr_user 换成你自己的 id。 <br/>
ID在这个<a href="http://idgettr.com/">网址</a>获取，只需把username换成自己的，然后点find。 <br/>
3.在<code>_config_yml</code>中<code>default_asides</code>添加<code>custom/asides/flickr.html</code>。 <br/>
4.大功告成。
本文参考了：<a href="http://lucifr.com/2011/12/02/add-flickr-aside-to-octopress/">Lucifr</a>和<a href="http://melandri.net/2012/01/10/octopress-flickr-aside/">melandri</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[排序算法总结（五）]]></title>
    <link href="http://tinyxd.me/blog/2012/07/01/merge-sort/"/>
    <updated>2012-07-01T23:45:00+08:00</updated>
    <id>http://tinyxd.me/blog/2012/07/01/merge-sort</id>
    <content type="html"><![CDATA[<p>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。 <br/>
归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 <br/>
将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 <br/>
与快速排序比较：归并排序是稳定的排序.即相等的元素的顺序不会改变。如输入记录 1(1) 3(2) 2(3) 2(4) 5(5) (括号中是记录的关键字)时输出的 1(1) 2(3) 2(4) 3(2) 5(5) 中的2 和 2 是按输入的顺序。这对要排序数据包含多个信息而要按其中的某一个信息排序，要求其它信息尽量按输入的顺序排列时很重要。这也是它比快速排序优势的地方.。</p>

<!--more-->


<p>用途： <br/>
1、排序 <br/>
速度仅次于快速排序，但较稳定。 <br/>
2、求逆序对数 <br/>
具体思路是，在归并的过程中计算每个小区间的逆序对数，进而计算出大区间的逆序对数（也可以用树状数组来求解）。 <br/>
c语言实现  <br/>
输入参数中，需要排序的数组为array[],起始索引为first，终止索引为last。调用完成后，array[]中从first到last处于升序排列。</p>

<figure class='code'><figcaption><span>归并算法（Merge sort）</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">MergeSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">array</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">first</span><span class="p">,</span> <span class="kt">int</span> <span class="n">last</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">first</span><span class="o">&lt;</span><span class="n">last</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">first</span><span class="o">+</span><span class="n">last</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'>      <span class="n">MergeSort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
</span><span class='line'>      <span class="n">MergeSort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">last</span><span class="p">);</span>
</span><span class='line'>      <span class="n">Merge</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="n">first</span><span class="p">,</span><span class="n">mid</span><span class="p">,</span><span class="n">last</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>本文是查阅书籍和网络资料整理而来，转载请注明出处。并以超链接的形式注明本文地址： <br/>
<code>http://tinyxd.me/blog/2012/07/01/merge-sort/</code></p>
]]></content>
  </entry>
  
</feed>
